(self.webpackChunk_codemodsquad_try_it_pages=self.webpackChunk_codemodsquad_try_it_pages||[]).push([[967],{28649:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = void 0;\nconst SPACES_RE = /^[ \\t]+$/;\n\nclass Buffer {\n  constructor(map) {\n    this._map = null;\n    this._buf = [];\n    this._last = "";\n    this._queue = [];\n    this._position = {\n      line: 1,\n      column: 0\n    };\n    this._sourcePosition = {\n      identifierName: null,\n      line: null,\n      column: null,\n      filename: null\n    };\n    this._disallowedPop = null;\n    this._map = map;\n  }\n\n  get() {\n    this._flush();\n\n    const map = this._map;\n    const result = {\n      code: this._buf.join("").trimRight(),\n      map: null,\n      rawMappings: map == null ? void 0 : map.getRawMappings()\n    };\n\n    if (map) {\n      Object.defineProperty(result, "map", {\n        configurable: true,\n        enumerable: true,\n\n        get() {\n          return this.map = map.get();\n        },\n\n        set(value) {\n          Object.defineProperty(this, "map", {\n            value,\n            writable: true\n          });\n        }\n\n      });\n    }\n\n    return result;\n  }\n\n  append(str) {\n    this._flush();\n\n    const {\n      line,\n      column,\n      filename,\n      identifierName,\n      force\n    } = this._sourcePosition;\n\n    this._append(str, line, column, identifierName, filename, force);\n  }\n\n  queue(str) {\n    if (str === "\\n") {\n      while (this._queue.length > 0 && SPACES_RE.test(this._queue[0][0])) {\n        this._queue.shift();\n      }\n    }\n\n    const {\n      line,\n      column,\n      filename,\n      identifierName,\n      force\n    } = this._sourcePosition;\n\n    this._queue.unshift([str, line, column, identifierName, filename, force]);\n  }\n\n  _flush() {\n    let item;\n\n    while (item = this._queue.pop()) this._append(...item);\n  }\n\n  _append(str, line, column, identifierName, filename, force) {\n    this._buf.push(str);\n\n    this._last = str[str.length - 1];\n    let i = str.indexOf("\\n");\n    let last = 0;\n\n    if (i !== 0) {\n      this._mark(line, column, identifierName, filename, force);\n    }\n\n    while (i !== -1) {\n      this._position.line++;\n      this._position.column = 0;\n      last = i + 1;\n\n      if (last < str.length) {\n        this._mark(++line, 0, identifierName, filename, force);\n      }\n\n      i = str.indexOf("\\n", last);\n    }\n\n    this._position.column += str.length - last;\n  }\n\n  _mark(line, column, identifierName, filename, force) {\n    var _this$_map;\n\n    (_this$_map = this._map) == null ? void 0 : _this$_map.mark(this._position.line, this._position.column, line, column, identifierName, filename, force);\n  }\n\n  removeTrailingNewline() {\n    if (this._queue.length > 0 && this._queue[0][0] === "\\n") {\n      this._queue.shift();\n    }\n  }\n\n  removeLastSemicolon() {\n    if (this._queue.length > 0 && this._queue[0][0] === ";") {\n      this._queue.shift();\n    }\n  }\n\n  endsWith(suffix) {\n    if (suffix.length === 1) {\n      let last;\n\n      if (this._queue.length > 0) {\n        const str = this._queue[0][0];\n        last = str[str.length - 1];\n      } else {\n        last = this._last;\n      }\n\n      return last === suffix;\n    }\n\n    const end = this._last + this._queue.reduce((acc, item) => item[0] + acc, "");\n\n    if (suffix.length <= end.length) {\n      return end.slice(-suffix.length) === suffix;\n    }\n\n    return false;\n  }\n\n  hasContent() {\n    return this._queue.length > 0 || !!this._last;\n  }\n\n  exactSource(loc, cb) {\n    this.source("start", loc, true);\n    cb();\n    this.source("end", loc);\n\n    this._disallowPop("start", loc);\n  }\n\n  source(prop, loc, force) {\n    if (prop && !loc) return;\n\n    this._normalizePosition(prop, loc, this._sourcePosition, force);\n  }\n\n  withSource(prop, loc, cb) {\n    if (!this._map) return cb();\n    const originalLine = this._sourcePosition.line;\n    const originalColumn = this._sourcePosition.column;\n    const originalFilename = this._sourcePosition.filename;\n    const originalIdentifierName = this._sourcePosition.identifierName;\n    this.source(prop, loc);\n    cb();\n\n    if ((!this._sourcePosition.force || this._sourcePosition.line !== originalLine || this._sourcePosition.column !== originalColumn || this._sourcePosition.filename !== originalFilename) && (!this._disallowedPop || this._disallowedPop.line !== originalLine || this._disallowedPop.column !== originalColumn || this._disallowedPop.filename !== originalFilename)) {\n      this._sourcePosition.line = originalLine;\n      this._sourcePosition.column = originalColumn;\n      this._sourcePosition.filename = originalFilename;\n      this._sourcePosition.identifierName = originalIdentifierName;\n      this._sourcePosition.force = false;\n      this._disallowedPop = null;\n    }\n  }\n\n  _disallowPop(prop, loc) {\n    if (prop && !loc) return;\n    this._disallowedPop = this._normalizePosition(prop, loc);\n  }\n\n  _normalizePosition(prop, loc, targetObj, force) {\n    const pos = loc ? loc[prop] : null;\n\n    if (targetObj === undefined) {\n      targetObj = {\n        identifierName: null,\n        line: null,\n        column: null,\n        filename: null,\n        force: false\n      };\n    }\n\n    const origLine = targetObj.line;\n    const origColumn = targetObj.column;\n    const origFilename = targetObj.filename;\n    targetObj.identifierName = prop === "start" && (loc == null ? void 0 : loc.identifierName) || null;\n    targetObj.line = pos == null ? void 0 : pos.line;\n    targetObj.column = pos == null ? void 0 : pos.column;\n    targetObj.filename = loc == null ? void 0 : loc.filename;\n\n    if (force || targetObj.line !== origLine || targetObj.column !== origColumn || targetObj.filename !== origFilename) {\n      targetObj.force = force;\n    }\n\n    return targetObj;\n  }\n\n  getCurrentColumn() {\n    const extra = this._queue.reduce((acc, item) => item[0] + acc, "");\n\n    const lastIndex = extra.lastIndexOf("\\n");\n    return lastIndex === -1 ? this._position.column + extra.length : extra.length - 1 - lastIndex;\n  }\n\n  getCurrentLine() {\n    const extra = this._queue.reduce((acc, item) => item[0] + acc, "");\n\n    let count = 0;\n\n    for (let i = 0; i < extra.length; i++) {\n      if (extra[i] === "\\n") count++;\n    }\n\n    return this._position.line + count;\n  }\n\n}\n\nexports.default = Buffer;\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/generator/lib/buffer.js?')},28516:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.File = File;\nexports.Program = Program;\nexports.BlockStatement = BlockStatement;\nexports.Noop = Noop;\nexports.Directive = Directive;\nexports.DirectiveLiteral = DirectiveLiteral;\nexports.InterpreterDirective = InterpreterDirective;\nexports.Placeholder = Placeholder;\n\nfunction File(node) {\n  if (node.program) {\n    this.print(node.program.interpreter, node);\n  }\n\n  this.print(node.program, node);\n}\n\nfunction Program(node) {\n  this.printInnerComments(node, false);\n  this.printSequence(node.directives, node);\n  if (node.directives && node.directives.length) this.newline();\n  this.printSequence(node.body, node);\n}\n\nfunction BlockStatement(node) {\n  var _node$directives;\n\n  this.token("{");\n  this.printInnerComments(node);\n  const hasDirectives = (_node$directives = node.directives) == null ? void 0 : _node$directives.length;\n\n  if (node.body.length || hasDirectives) {\n    this.newline();\n    this.printSequence(node.directives, node, {\n      indent: true\n    });\n    if (hasDirectives) this.newline();\n    this.printSequence(node.body, node, {\n      indent: true\n    });\n    this.removeTrailingNewline();\n    this.source("end", node.loc);\n    if (!this.endsWith("\\n")) this.newline();\n    this.rightBrace();\n  } else {\n    this.source("end", node.loc);\n    this.token("}");\n  }\n}\n\nfunction Noop() {}\n\nfunction Directive(node) {\n  this.print(node.value, node);\n  this.semicolon();\n}\n\nconst unescapedSingleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*\'/;\nconst unescapedDoubleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*"/;\n\nfunction DirectiveLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n\n  if (raw != null) {\n    this.token(raw);\n    return;\n  }\n\n  const {\n    value\n  } = node;\n\n  if (!unescapedDoubleQuoteRE.test(value)) {\n    this.token(`"${value}"`);\n  } else if (!unescapedSingleQuoteRE.test(value)) {\n    this.token(`\'${value}\'`);\n  } else {\n    throw new Error("Malformed AST: it is not possible to print a directive containing" + " both unescaped single and double quotes.");\n  }\n}\n\nfunction InterpreterDirective(node) {\n  this.token(`#!${node.value}\\n`);\n}\n\nfunction Placeholder(node) {\n  this.token("%%");\n  this.print(node.name);\n  this.token("%%");\n\n  if (node.expectedNode === "Statement") {\n    this.semicolon();\n  }\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/generator/lib/generators/base.js?')},505:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.ClassExpression = exports.ClassDeclaration = ClassDeclaration;\nexports.ClassBody = ClassBody;\nexports.ClassProperty = ClassProperty;\nexports.ClassPrivateProperty = ClassPrivateProperty;\nexports.ClassMethod = ClassMethod;\nexports.ClassPrivateMethod = ClassPrivateMethod;\nexports._classMethodHead = _classMethodHead;\nexports.StaticBlock = StaticBlock;\n\nvar t = _interopRequireWildcard(__webpack_require__(38218));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction ClassDeclaration(node, parent) {\n  if (!this.format.decoratorsBeforeExport || !t.isExportDefaultDeclaration(parent) && !t.isExportNamedDeclaration(parent)) {\n    this.printJoin(node.decorators, node);\n  }\n\n  if (node.declare) {\n    this.word("declare");\n    this.space();\n  }\n\n  if (node.abstract) {\n    this.word("abstract");\n    this.space();\n  }\n\n  this.word("class");\n\n  if (node.id) {\n    this.space();\n    this.print(node.id, node);\n  }\n\n  this.print(node.typeParameters, node);\n\n  if (node.superClass) {\n    this.space();\n    this.word("extends");\n    this.space();\n    this.print(node.superClass, node);\n    this.print(node.superTypeParameters, node);\n  }\n\n  if (node.implements) {\n    this.space();\n    this.word("implements");\n    this.space();\n    this.printList(node.implements, node);\n  }\n\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction ClassBody(node) {\n  this.token("{");\n  this.printInnerComments(node);\n\n  if (node.body.length === 0) {\n    this.token("}");\n  } else {\n    this.newline();\n    this.indent();\n    this.printSequence(node.body, node);\n    this.dedent();\n    if (!this.endsWith("\\n")) this.newline();\n    this.rightBrace();\n  }\n}\n\nfunction ClassProperty(node) {\n  this.printJoin(node.decorators, node);\n  this.tsPrintClassMemberModifiers(node, true);\n\n  if (node.computed) {\n    this.token("[");\n    this.print(node.key, node);\n    this.token("]");\n  } else {\n    this._variance(node);\n\n    this.print(node.key, node);\n  }\n\n  if (node.optional) {\n    this.token("?");\n  }\n\n  if (node.definite) {\n    this.token("!");\n  }\n\n  this.print(node.typeAnnotation, node);\n\n  if (node.value) {\n    this.space();\n    this.token("=");\n    this.space();\n    this.print(node.value, node);\n  }\n\n  this.semicolon();\n}\n\nfunction ClassPrivateProperty(node) {\n  this.printJoin(node.decorators, node);\n\n  if (node.static) {\n    this.word("static");\n    this.space();\n  }\n\n  this.print(node.key, node);\n  this.print(node.typeAnnotation, node);\n\n  if (node.value) {\n    this.space();\n    this.token("=");\n    this.space();\n    this.print(node.value, node);\n  }\n\n  this.semicolon();\n}\n\nfunction ClassMethod(node) {\n  this._classMethodHead(node);\n\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction ClassPrivateMethod(node) {\n  this._classMethodHead(node);\n\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction _classMethodHead(node) {\n  this.printJoin(node.decorators, node);\n  this.tsPrintClassMemberModifiers(node, false);\n\n  this._methodHead(node);\n}\n\nfunction StaticBlock(node) {\n  this.word("static");\n  this.space();\n  this.token("{");\n\n  if (node.body.length === 0) {\n    this.token("}");\n  } else {\n    this.newline();\n    this.printSequence(node.body, node, {\n      indent: true\n    });\n    this.rightBrace();\n  }\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/generator/lib/generators/classes.js?')},36361:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.UnaryExpression = UnaryExpression;\nexports.DoExpression = DoExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.NewExpression = NewExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.ThisExpression = ThisExpression;\nexports.Super = Super;\nexports.Decorator = Decorator;\nexports.OptionalMemberExpression = OptionalMemberExpression;\nexports.OptionalCallExpression = OptionalCallExpression;\nexports.CallExpression = CallExpression;\nexports.Import = Import;\nexports.EmptyStatement = EmptyStatement;\nexports.ExpressionStatement = ExpressionStatement;\nexports.AssignmentPattern = AssignmentPattern;\nexports.LogicalExpression = exports.BinaryExpression = exports.AssignmentExpression = AssignmentExpression;\nexports.BindExpression = BindExpression;\nexports.MemberExpression = MemberExpression;\nexports.MetaProperty = MetaProperty;\nexports.PrivateName = PrivateName;\nexports.V8IntrinsicIdentifier = V8IntrinsicIdentifier;\nexports.AwaitExpression = exports.YieldExpression = void 0;\n\nvar t = _interopRequireWildcard(__webpack_require__(38218));\n\nvar n = _interopRequireWildcard(__webpack_require__(32866));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction UnaryExpression(node) {\n  if (node.operator === "void" || node.operator === "delete" || node.operator === "typeof" || node.operator === "throw") {\n    this.word(node.operator);\n    this.space();\n  } else {\n    this.token(node.operator);\n  }\n\n  this.print(node.argument, node);\n}\n\nfunction DoExpression(node) {\n  this.word("do");\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction ParenthesizedExpression(node) {\n  this.token("(");\n  this.print(node.expression, node);\n  this.token(")");\n}\n\nfunction UpdateExpression(node) {\n  if (node.prefix) {\n    this.token(node.operator);\n    this.print(node.argument, node);\n  } else {\n    this.startTerminatorless(true);\n    this.print(node.argument, node);\n    this.endTerminatorless();\n    this.token(node.operator);\n  }\n}\n\nfunction ConditionalExpression(node) {\n  this.print(node.test, node);\n  this.space();\n  this.token("?");\n  this.space();\n  this.print(node.consequent, node);\n  this.space();\n  this.token(":");\n  this.space();\n  this.print(node.alternate, node);\n}\n\nfunction NewExpression(node, parent) {\n  this.word("new");\n  this.space();\n  this.print(node.callee, node);\n\n  if (this.format.minified && node.arguments.length === 0 && !node.optional && !t.isCallExpression(parent, {\n    callee: node\n  }) && !t.isMemberExpression(parent) && !t.isNewExpression(parent)) {\n    return;\n  }\n\n  this.print(node.typeArguments, node);\n  this.print(node.typeParameters, node);\n\n  if (node.optional) {\n    this.token("?.");\n  }\n\n  this.token("(");\n  this.printList(node.arguments, node);\n  this.token(")");\n}\n\nfunction SequenceExpression(node) {\n  this.printList(node.expressions, node);\n}\n\nfunction ThisExpression() {\n  this.word("this");\n}\n\nfunction Super() {\n  this.word("super");\n}\n\nfunction Decorator(node) {\n  this.token("@");\n  this.print(node.expression, node);\n  this.newline();\n}\n\nfunction OptionalMemberExpression(node) {\n  this.print(node.object, node);\n\n  if (!node.computed && t.isMemberExpression(node.property)) {\n    throw new TypeError("Got a MemberExpression for MemberExpression property");\n  }\n\n  let computed = node.computed;\n\n  if (t.isLiteral(node.property) && typeof node.property.value === "number") {\n    computed = true;\n  }\n\n  if (node.optional) {\n    this.token("?.");\n  }\n\n  if (computed) {\n    this.token("[");\n    this.print(node.property, node);\n    this.token("]");\n  } else {\n    if (!node.optional) {\n      this.token(".");\n    }\n\n    this.print(node.property, node);\n  }\n}\n\nfunction OptionalCallExpression(node) {\n  this.print(node.callee, node);\n  this.print(node.typeArguments, node);\n  this.print(node.typeParameters, node);\n\n  if (node.optional) {\n    this.token("?.");\n  }\n\n  this.token("(");\n  this.printList(node.arguments, node);\n  this.token(")");\n}\n\nfunction CallExpression(node) {\n  this.print(node.callee, node);\n  this.print(node.typeArguments, node);\n  this.print(node.typeParameters, node);\n  this.token("(");\n  this.printList(node.arguments, node);\n  this.token(")");\n}\n\nfunction Import() {\n  this.word("import");\n}\n\nfunction buildYieldAwait(keyword) {\n  return function (node) {\n    this.word(keyword);\n\n    if (node.delegate) {\n      this.token("*");\n    }\n\n    if (node.argument) {\n      this.space();\n      const terminatorState = this.startTerminatorless();\n      this.print(node.argument, node);\n      this.endTerminatorless(terminatorState);\n    }\n  };\n}\n\nconst YieldExpression = buildYieldAwait("yield");\nexports.YieldExpression = YieldExpression;\nconst AwaitExpression = buildYieldAwait("await");\nexports.AwaitExpression = AwaitExpression;\n\nfunction EmptyStatement() {\n  this.semicolon(true);\n}\n\nfunction ExpressionStatement(node) {\n  this.print(node.expression, node);\n  this.semicolon();\n}\n\nfunction AssignmentPattern(node) {\n  this.print(node.left, node);\n  if (node.left.optional) this.token("?");\n  this.print(node.left.typeAnnotation, node);\n  this.space();\n  this.token("=");\n  this.space();\n  this.print(node.right, node);\n}\n\nfunction AssignmentExpression(node, parent) {\n  const parens = this.inForStatementInitCounter && node.operator === "in" && !n.needsParens(node, parent);\n\n  if (parens) {\n    this.token("(");\n  }\n\n  this.print(node.left, node);\n  this.space();\n\n  if (node.operator === "in" || node.operator === "instanceof") {\n    this.word(node.operator);\n  } else {\n    this.token(node.operator);\n  }\n\n  this.space();\n  this.print(node.right, node);\n\n  if (parens) {\n    this.token(")");\n  }\n}\n\nfunction BindExpression(node) {\n  this.print(node.object, node);\n  this.token("::");\n  this.print(node.callee, node);\n}\n\nfunction MemberExpression(node) {\n  this.print(node.object, node);\n\n  if (!node.computed && t.isMemberExpression(node.property)) {\n    throw new TypeError("Got a MemberExpression for MemberExpression property");\n  }\n\n  let computed = node.computed;\n\n  if (t.isLiteral(node.property) && typeof node.property.value === "number") {\n    computed = true;\n  }\n\n  if (computed) {\n    this.token("[");\n    this.print(node.property, node);\n    this.token("]");\n  } else {\n    this.token(".");\n    this.print(node.property, node);\n  }\n}\n\nfunction MetaProperty(node) {\n  this.print(node.meta, node);\n  this.token(".");\n  this.print(node.property, node);\n}\n\nfunction PrivateName(node) {\n  this.token("#");\n  this.print(node.id, node);\n}\n\nfunction V8IntrinsicIdentifier(node) {\n  this.token("%");\n  this.word(node.name);\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/generator/lib/generators/expressions.js?')},48076:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.AnyTypeAnnotation = AnyTypeAnnotation;\nexports.ArrayTypeAnnotation = ArrayTypeAnnotation;\nexports.BooleanTypeAnnotation = BooleanTypeAnnotation;\nexports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;\nexports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;\nexports.DeclareClass = DeclareClass;\nexports.DeclareFunction = DeclareFunction;\nexports.InferredPredicate = InferredPredicate;\nexports.DeclaredPredicate = DeclaredPredicate;\nexports.DeclareInterface = DeclareInterface;\nexports.DeclareModule = DeclareModule;\nexports.DeclareModuleExports = DeclareModuleExports;\nexports.DeclareTypeAlias = DeclareTypeAlias;\nexports.DeclareOpaqueType = DeclareOpaqueType;\nexports.DeclareVariable = DeclareVariable;\nexports.DeclareExportDeclaration = DeclareExportDeclaration;\nexports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;\nexports.EnumDeclaration = EnumDeclaration;\nexports.EnumBooleanBody = EnumBooleanBody;\nexports.EnumNumberBody = EnumNumberBody;\nexports.EnumStringBody = EnumStringBody;\nexports.EnumSymbolBody = EnumSymbolBody;\nexports.EnumDefaultedMember = EnumDefaultedMember;\nexports.EnumBooleanMember = EnumBooleanMember;\nexports.EnumNumberMember = EnumNumberMember;\nexports.EnumStringMember = EnumStringMember;\nexports.ExistsTypeAnnotation = ExistsTypeAnnotation;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.FunctionTypeParam = FunctionTypeParam;\nexports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends;\nexports._interfaceish = _interfaceish;\nexports._variance = _variance;\nexports.InterfaceDeclaration = InterfaceDeclaration;\nexports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;\nexports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;\nexports.MixedTypeAnnotation = MixedTypeAnnotation;\nexports.EmptyTypeAnnotation = EmptyTypeAnnotation;\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.NumberTypeAnnotation = NumberTypeAnnotation;\nexports.StringTypeAnnotation = StringTypeAnnotation;\nexports.ThisTypeAnnotation = ThisTypeAnnotation;\nexports.TupleTypeAnnotation = TupleTypeAnnotation;\nexports.TypeofTypeAnnotation = TypeofTypeAnnotation;\nexports.TypeAlias = TypeAlias;\nexports.TypeAnnotation = TypeAnnotation;\nexports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation;\nexports.TypeParameter = TypeParameter;\nexports.OpaqueType = OpaqueType;\nexports.ObjectTypeAnnotation = ObjectTypeAnnotation;\nexports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;\nexports.ObjectTypeCallProperty = ObjectTypeCallProperty;\nexports.ObjectTypeIndexer = ObjectTypeIndexer;\nexports.ObjectTypeProperty = ObjectTypeProperty;\nexports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;\nexports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;\nexports.SymbolTypeAnnotation = SymbolTypeAnnotation;\nexports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.TypeCastExpression = TypeCastExpression;\nexports.Variance = Variance;\nexports.VoidTypeAnnotation = VoidTypeAnnotation;\nObject.defineProperty(exports, "NumberLiteralTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _types2.NumericLiteral;\n  }\n}));\nObject.defineProperty(exports, "StringLiteralTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _types2.StringLiteral;\n  }\n}));\n\nvar t = _interopRequireWildcard(__webpack_require__(38218));\n\nvar _modules = __webpack_require__(97064);\n\nvar _types2 = __webpack_require__(55718);\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction AnyTypeAnnotation() {\n  this.word("any");\n}\n\nfunction ArrayTypeAnnotation(node) {\n  this.print(node.elementType, node);\n  this.token("[");\n  this.token("]");\n}\n\nfunction BooleanTypeAnnotation() {\n  this.word("boolean");\n}\n\nfunction BooleanLiteralTypeAnnotation(node) {\n  this.word(node.value ? "true" : "false");\n}\n\nfunction NullLiteralTypeAnnotation() {\n  this.word("null");\n}\n\nfunction DeclareClass(node, parent) {\n  if (!t.isDeclareExportDeclaration(parent)) {\n    this.word("declare");\n    this.space();\n  }\n\n  this.word("class");\n  this.space();\n\n  this._interfaceish(node);\n}\n\nfunction DeclareFunction(node, parent) {\n  if (!t.isDeclareExportDeclaration(parent)) {\n    this.word("declare");\n    this.space();\n  }\n\n  this.word("function");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.id.typeAnnotation.typeAnnotation, node);\n\n  if (node.predicate) {\n    this.space();\n    this.print(node.predicate, node);\n  }\n\n  this.semicolon();\n}\n\nfunction InferredPredicate() {\n  this.token("%");\n  this.word("checks");\n}\n\nfunction DeclaredPredicate(node) {\n  this.token("%");\n  this.word("checks");\n  this.token("(");\n  this.print(node.value, node);\n  this.token(")");\n}\n\nfunction DeclareInterface(node) {\n  this.word("declare");\n  this.space();\n  this.InterfaceDeclaration(node);\n}\n\nfunction DeclareModule(node) {\n  this.word("declare");\n  this.space();\n  this.word("module");\n  this.space();\n  this.print(node.id, node);\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction DeclareModuleExports(node) {\n  this.word("declare");\n  this.space();\n  this.word("module");\n  this.token(".");\n  this.word("exports");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction DeclareTypeAlias(node) {\n  this.word("declare");\n  this.space();\n  this.TypeAlias(node);\n}\n\nfunction DeclareOpaqueType(node, parent) {\n  if (!t.isDeclareExportDeclaration(parent)) {\n    this.word("declare");\n    this.space();\n  }\n\n  this.OpaqueType(node);\n}\n\nfunction DeclareVariable(node, parent) {\n  if (!t.isDeclareExportDeclaration(parent)) {\n    this.word("declare");\n    this.space();\n  }\n\n  this.word("var");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.id.typeAnnotation, node);\n  this.semicolon();\n}\n\nfunction DeclareExportDeclaration(node) {\n  this.word("declare");\n  this.space();\n  this.word("export");\n  this.space();\n\n  if (node.default) {\n    this.word("default");\n    this.space();\n  }\n\n  FlowExportDeclaration.apply(this, arguments);\n}\n\nfunction DeclareExportAllDeclaration() {\n  this.word("declare");\n  this.space();\n\n  _modules.ExportAllDeclaration.apply(this, arguments);\n}\n\nfunction EnumDeclaration(node) {\n  const {\n    id,\n    body\n  } = node;\n  this.word("enum");\n  this.space();\n  this.print(id, node);\n  this.print(body, node);\n}\n\nfunction enumExplicitType(context, name, hasExplicitType) {\n  if (hasExplicitType) {\n    context.space();\n    context.word("of");\n    context.space();\n    context.word(name);\n  }\n\n  context.space();\n}\n\nfunction enumBody(context, node) {\n  const {\n    members\n  } = node;\n  context.token("{");\n  context.indent();\n  context.newline();\n\n  for (const member of members) {\n    context.print(member, node);\n    context.newline();\n  }\n\n  context.dedent();\n  context.token("}");\n}\n\nfunction EnumBooleanBody(node) {\n  const {\n    explicitType\n  } = node;\n  enumExplicitType(this, "boolean", explicitType);\n  enumBody(this, node);\n}\n\nfunction EnumNumberBody(node) {\n  const {\n    explicitType\n  } = node;\n  enumExplicitType(this, "number", explicitType);\n  enumBody(this, node);\n}\n\nfunction EnumStringBody(node) {\n  const {\n    explicitType\n  } = node;\n  enumExplicitType(this, "string", explicitType);\n  enumBody(this, node);\n}\n\nfunction EnumSymbolBody(node) {\n  enumExplicitType(this, "symbol", true);\n  enumBody(this, node);\n}\n\nfunction EnumDefaultedMember(node) {\n  const {\n    id\n  } = node;\n  this.print(id, node);\n  this.token(",");\n}\n\nfunction enumInitializedMember(context, node) {\n  const {\n    id,\n    init\n  } = node;\n  context.print(id, node);\n  context.space();\n  context.token("=");\n  context.space();\n  context.print(init, node);\n  context.token(",");\n}\n\nfunction EnumBooleanMember(node) {\n  enumInitializedMember(this, node);\n}\n\nfunction EnumNumberMember(node) {\n  enumInitializedMember(this, node);\n}\n\nfunction EnumStringMember(node) {\n  enumInitializedMember(this, node);\n}\n\nfunction FlowExportDeclaration(node) {\n  if (node.declaration) {\n    const declar = node.declaration;\n    this.print(declar, node);\n    if (!t.isStatement(declar)) this.semicolon();\n  } else {\n    this.token("{");\n\n    if (node.specifiers.length) {\n      this.space();\n      this.printList(node.specifiers, node);\n      this.space();\n    }\n\n    this.token("}");\n\n    if (node.source) {\n      this.space();\n      this.word("from");\n      this.space();\n      this.print(node.source, node);\n    }\n\n    this.semicolon();\n  }\n}\n\nfunction ExistsTypeAnnotation() {\n  this.token("*");\n}\n\nfunction FunctionTypeAnnotation(node, parent) {\n  this.print(node.typeParameters, node);\n  this.token("(");\n  this.printList(node.params, node);\n\n  if (node.rest) {\n    if (node.params.length) {\n      this.token(",");\n      this.space();\n    }\n\n    this.token("...");\n    this.print(node.rest, node);\n  }\n\n  this.token(")");\n\n  if (parent.type === "ObjectTypeCallProperty" || parent.type === "DeclareFunction" || parent.type === "ObjectTypeProperty" && parent.method) {\n    this.token(":");\n  } else {\n    this.space();\n    this.token("=>");\n  }\n\n  this.space();\n  this.print(node.returnType, node);\n}\n\nfunction FunctionTypeParam(node) {\n  this.print(node.name, node);\n  if (node.optional) this.token("?");\n\n  if (node.name) {\n    this.token(":");\n    this.space();\n  }\n\n  this.print(node.typeAnnotation, node);\n}\n\nfunction InterfaceExtends(node) {\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n}\n\nfunction _interfaceish(node) {\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n\n  if (node.extends.length) {\n    this.space();\n    this.word("extends");\n    this.space();\n    this.printList(node.extends, node);\n  }\n\n  if (node.mixins && node.mixins.length) {\n    this.space();\n    this.word("mixins");\n    this.space();\n    this.printList(node.mixins, node);\n  }\n\n  if (node.implements && node.implements.length) {\n    this.space();\n    this.word("implements");\n    this.space();\n    this.printList(node.implements, node);\n  }\n\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction _variance(node) {\n  if (node.variance) {\n    if (node.variance.kind === "plus") {\n      this.token("+");\n    } else if (node.variance.kind === "minus") {\n      this.token("-");\n    }\n  }\n}\n\nfunction InterfaceDeclaration(node) {\n  this.word("interface");\n  this.space();\n\n  this._interfaceish(node);\n}\n\nfunction andSeparator() {\n  this.space();\n  this.token("&");\n  this.space();\n}\n\nfunction InterfaceTypeAnnotation(node) {\n  this.word("interface");\n\n  if (node.extends && node.extends.length) {\n    this.space();\n    this.word("extends");\n    this.space();\n    this.printList(node.extends, node);\n  }\n\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction IntersectionTypeAnnotation(node) {\n  this.printJoin(node.types, node, {\n    separator: andSeparator\n  });\n}\n\nfunction MixedTypeAnnotation() {\n  this.word("mixed");\n}\n\nfunction EmptyTypeAnnotation() {\n  this.word("empty");\n}\n\nfunction NullableTypeAnnotation(node) {\n  this.token("?");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction NumberTypeAnnotation() {\n  this.word("number");\n}\n\nfunction StringTypeAnnotation() {\n  this.word("string");\n}\n\nfunction ThisTypeAnnotation() {\n  this.word("this");\n}\n\nfunction TupleTypeAnnotation(node) {\n  this.token("[");\n  this.printList(node.types, node);\n  this.token("]");\n}\n\nfunction TypeofTypeAnnotation(node) {\n  this.word("typeof");\n  this.space();\n  this.print(node.argument, node);\n}\n\nfunction TypeAlias(node) {\n  this.word("type");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n  this.space();\n  this.token("=");\n  this.space();\n  this.print(node.right, node);\n  this.semicolon();\n}\n\nfunction TypeAnnotation(node) {\n  this.token(":");\n  this.space();\n  if (node.optional) this.token("?");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction TypeParameterInstantiation(node) {\n  this.token("<");\n  this.printList(node.params, node, {});\n  this.token(">");\n}\n\nfunction TypeParameter(node) {\n  this._variance(node);\n\n  this.word(node.name);\n\n  if (node.bound) {\n    this.print(node.bound, node);\n  }\n\n  if (node.default) {\n    this.space();\n    this.token("=");\n    this.space();\n    this.print(node.default, node);\n  }\n}\n\nfunction OpaqueType(node) {\n  this.word("opaque");\n  this.space();\n  this.word("type");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n\n  if (node.supertype) {\n    this.token(":");\n    this.space();\n    this.print(node.supertype, node);\n  }\n\n  if (node.impltype) {\n    this.space();\n    this.token("=");\n    this.space();\n    this.print(node.impltype, node);\n  }\n\n  this.semicolon();\n}\n\nfunction ObjectTypeAnnotation(node) {\n  if (node.exact) {\n    this.token("{|");\n  } else {\n    this.token("{");\n  }\n\n  const props = node.properties.concat(node.callProperties || [], node.indexers || [], node.internalSlots || []);\n\n  if (props.length) {\n    this.space();\n    this.printJoin(props, node, {\n      addNewlines(leading) {\n        if (leading && !props[0]) return 1;\n      },\n\n      indent: true,\n      statement: true,\n      iterator: () => {\n        if (props.length !== 1 || node.inexact) {\n          this.token(",");\n          this.space();\n        }\n      }\n    });\n    this.space();\n  }\n\n  if (node.inexact) {\n    this.indent();\n    this.token("...");\n\n    if (props.length) {\n      this.newline();\n    }\n\n    this.dedent();\n  }\n\n  if (node.exact) {\n    this.token("|}");\n  } else {\n    this.token("}");\n  }\n}\n\nfunction ObjectTypeInternalSlot(node) {\n  if (node.static) {\n    this.word("static");\n    this.space();\n  }\n\n  this.token("[");\n  this.token("[");\n  this.print(node.id, node);\n  this.token("]");\n  this.token("]");\n  if (node.optional) this.token("?");\n\n  if (!node.method) {\n    this.token(":");\n    this.space();\n  }\n\n  this.print(node.value, node);\n}\n\nfunction ObjectTypeCallProperty(node) {\n  if (node.static) {\n    this.word("static");\n    this.space();\n  }\n\n  this.print(node.value, node);\n}\n\nfunction ObjectTypeIndexer(node) {\n  if (node.static) {\n    this.word("static");\n    this.space();\n  }\n\n  this._variance(node);\n\n  this.token("[");\n\n  if (node.id) {\n    this.print(node.id, node);\n    this.token(":");\n    this.space();\n  }\n\n  this.print(node.key, node);\n  this.token("]");\n  this.token(":");\n  this.space();\n  this.print(node.value, node);\n}\n\nfunction ObjectTypeProperty(node) {\n  if (node.proto) {\n    this.word("proto");\n    this.space();\n  }\n\n  if (node.static) {\n    this.word("static");\n    this.space();\n  }\n\n  if (node.kind === "get" || node.kind === "set") {\n    this.word(node.kind);\n    this.space();\n  }\n\n  this._variance(node);\n\n  this.print(node.key, node);\n  if (node.optional) this.token("?");\n\n  if (!node.method) {\n    this.token(":");\n    this.space();\n  }\n\n  this.print(node.value, node);\n}\n\nfunction ObjectTypeSpreadProperty(node) {\n  this.token("...");\n  this.print(node.argument, node);\n}\n\nfunction QualifiedTypeIdentifier(node) {\n  this.print(node.qualification, node);\n  this.token(".");\n  this.print(node.id, node);\n}\n\nfunction SymbolTypeAnnotation() {\n  this.word("symbol");\n}\n\nfunction orSeparator() {\n  this.space();\n  this.token("|");\n  this.space();\n}\n\nfunction UnionTypeAnnotation(node) {\n  this.printJoin(node.types, node, {\n    separator: orSeparator\n  });\n}\n\nfunction TypeCastExpression(node) {\n  this.token("(");\n  this.print(node.expression, node);\n  this.print(node.typeAnnotation, node);\n  this.token(")");\n}\n\nfunction Variance(node) {\n  if (node.kind === "plus") {\n    this.token("+");\n  } else {\n    this.token("-");\n  }\n}\n\nfunction VoidTypeAnnotation() {\n  this.word("void");\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/generator/lib/generators/flow.js?')},38217:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\n\nvar _templateLiterals = __webpack_require__(82347);\n\nObject.keys(_templateLiterals).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (key in exports && exports[key] === _templateLiterals[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _templateLiterals[key];\n    }\n  });\n});\n\nvar _expressions = __webpack_require__(36361);\n\nObject.keys(_expressions).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (key in exports && exports[key] === _expressions[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _expressions[key];\n    }\n  });\n});\n\nvar _statements = __webpack_require__(16787);\n\nObject.keys(_statements).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (key in exports && exports[key] === _statements[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _statements[key];\n    }\n  });\n});\n\nvar _classes = __webpack_require__(505);\n\nObject.keys(_classes).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (key in exports && exports[key] === _classes[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _classes[key];\n    }\n  });\n});\n\nvar _methods = __webpack_require__(50624);\n\nObject.keys(_methods).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (key in exports && exports[key] === _methods[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _methods[key];\n    }\n  });\n});\n\nvar _modules = __webpack_require__(97064);\n\nObject.keys(_modules).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (key in exports && exports[key] === _modules[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _modules[key];\n    }\n  });\n});\n\nvar _types = __webpack_require__(55718);\n\nObject.keys(_types).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (key in exports && exports[key] === _types[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _types[key];\n    }\n  });\n});\n\nvar _flow = __webpack_require__(48076);\n\nObject.keys(_flow).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (key in exports && exports[key] === _flow[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _flow[key];\n    }\n  });\n});\n\nvar _base = __webpack_require__(28516);\n\nObject.keys(_base).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (key in exports && exports[key] === _base[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _base[key];\n    }\n  });\n});\n\nvar _jsx = __webpack_require__(49598);\n\nObject.keys(_jsx).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (key in exports && exports[key] === _jsx[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _jsx[key];\n    }\n  });\n});\n\nvar _typescript = __webpack_require__(82043);\n\nObject.keys(_typescript).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (key in exports && exports[key] === _typescript[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _typescript[key];\n    }\n  });\n});\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/generator/lib/generators/index.js?')},49598:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.JSXAttribute = JSXAttribute;\nexports.JSXIdentifier = JSXIdentifier;\nexports.JSXNamespacedName = JSXNamespacedName;\nexports.JSXMemberExpression = JSXMemberExpression;\nexports.JSXSpreadAttribute = JSXSpreadAttribute;\nexports.JSXExpressionContainer = JSXExpressionContainer;\nexports.JSXSpreadChild = JSXSpreadChild;\nexports.JSXText = JSXText;\nexports.JSXElement = JSXElement;\nexports.JSXOpeningElement = JSXOpeningElement;\nexports.JSXClosingElement = JSXClosingElement;\nexports.JSXEmptyExpression = JSXEmptyExpression;\nexports.JSXFragment = JSXFragment;\nexports.JSXOpeningFragment = JSXOpeningFragment;\nexports.JSXClosingFragment = JSXClosingFragment;\n\nfunction JSXAttribute(node) {\n  this.print(node.name, node);\n\n  if (node.value) {\n    this.token("=");\n    this.print(node.value, node);\n  }\n}\n\nfunction JSXIdentifier(node) {\n  this.word(node.name);\n}\n\nfunction JSXNamespacedName(node) {\n  this.print(node.namespace, node);\n  this.token(":");\n  this.print(node.name, node);\n}\n\nfunction JSXMemberExpression(node) {\n  this.print(node.object, node);\n  this.token(".");\n  this.print(node.property, node);\n}\n\nfunction JSXSpreadAttribute(node) {\n  this.token("{");\n  this.token("...");\n  this.print(node.argument, node);\n  this.token("}");\n}\n\nfunction JSXExpressionContainer(node) {\n  this.token("{");\n  this.print(node.expression, node);\n  this.token("}");\n}\n\nfunction JSXSpreadChild(node) {\n  this.token("{");\n  this.token("...");\n  this.print(node.expression, node);\n  this.token("}");\n}\n\nfunction JSXText(node) {\n  const raw = this.getPossibleRaw(node);\n\n  if (raw != null) {\n    this.token(raw);\n  } else {\n    this.token(node.value);\n  }\n}\n\nfunction JSXElement(node) {\n  const open = node.openingElement;\n  this.print(open, node);\n  if (open.selfClosing) return;\n  this.indent();\n\n  for (const child of node.children) {\n    this.print(child, node);\n  }\n\n  this.dedent();\n  this.print(node.closingElement, node);\n}\n\nfunction spaceSeparator() {\n  this.space();\n}\n\nfunction JSXOpeningElement(node) {\n  this.token("<");\n  this.print(node.name, node);\n  this.print(node.typeParameters, node);\n\n  if (node.attributes.length > 0) {\n    this.space();\n    this.printJoin(node.attributes, node, {\n      separator: spaceSeparator\n    });\n  }\n\n  if (node.selfClosing) {\n    this.space();\n    this.token("/>");\n  } else {\n    this.token(">");\n  }\n}\n\nfunction JSXClosingElement(node) {\n  this.token("</");\n  this.print(node.name, node);\n  this.token(">");\n}\n\nfunction JSXEmptyExpression(node) {\n  this.printInnerComments(node);\n}\n\nfunction JSXFragment(node) {\n  this.print(node.openingFragment, node);\n  this.indent();\n\n  for (const child of node.children) {\n    this.print(child, node);\n  }\n\n  this.dedent();\n  this.print(node.closingFragment, node);\n}\n\nfunction JSXOpeningFragment() {\n  this.token("<");\n  this.token(">");\n}\n\nfunction JSXClosingFragment() {\n  this.token("</");\n  this.token(">");\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/generator/lib/generators/jsx.js?')},50624:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports._params = _params;\nexports._parameters = _parameters;\nexports._param = _param;\nexports._methodHead = _methodHead;\nexports._predicate = _predicate;\nexports._functionHead = _functionHead;\nexports.FunctionDeclaration = exports.FunctionExpression = FunctionExpression;\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\n\nvar t = _interopRequireWildcard(__webpack_require__(38218));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _params(node) {\n  this.print(node.typeParameters, node);\n  this.token("(");\n\n  this._parameters(node.params, node);\n\n  this.token(")");\n  this.print(node.returnType, node);\n}\n\nfunction _parameters(parameters, parent) {\n  for (let i = 0; i < parameters.length; i++) {\n    this._param(parameters[i], parent);\n\n    if (i < parameters.length - 1) {\n      this.token(",");\n      this.space();\n    }\n  }\n}\n\nfunction _param(parameter, parent) {\n  this.printJoin(parameter.decorators, parameter);\n  this.print(parameter, parent);\n  if (parameter.optional) this.token("?");\n  this.print(parameter.typeAnnotation, parameter);\n}\n\nfunction _methodHead(node) {\n  const kind = node.kind;\n  const key = node.key;\n\n  if (kind === "get" || kind === "set") {\n    this.word(kind);\n    this.space();\n  }\n\n  if (node.async) {\n    this._catchUp("start", key.loc);\n\n    this.word("async");\n    this.space();\n  }\n\n  if (kind === "method" || kind === "init") {\n    if (node.generator) {\n      this.token("*");\n    }\n  }\n\n  if (node.computed) {\n    this.token("[");\n    this.print(key, node);\n    this.token("]");\n  } else {\n    this.print(key, node);\n  }\n\n  if (node.optional) {\n    this.token("?");\n  }\n\n  this._params(node);\n}\n\nfunction _predicate(node) {\n  if (node.predicate) {\n    if (!node.returnType) {\n      this.token(":");\n    }\n\n    this.space();\n    this.print(node.predicate, node);\n  }\n}\n\nfunction _functionHead(node) {\n  if (node.async) {\n    this.word("async");\n    this.space();\n  }\n\n  this.word("function");\n  if (node.generator) this.token("*");\n  this.space();\n\n  if (node.id) {\n    this.print(node.id, node);\n  }\n\n  this._params(node);\n\n  this._predicate(node);\n}\n\nfunction FunctionExpression(node) {\n  this._functionHead(node);\n\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction ArrowFunctionExpression(node) {\n  if (node.async) {\n    this.word("async");\n    this.space();\n  }\n\n  const firstParam = node.params[0];\n\n  if (node.params.length === 1 && t.isIdentifier(firstParam) && !hasTypes(node, firstParam)) {\n    if ((this.format.retainLines || node.async) && node.loc && node.body.loc && node.loc.start.line < node.body.loc.start.line) {\n      this.token("(");\n\n      if (firstParam.loc && firstParam.loc.start.line > node.loc.start.line) {\n        this.indent();\n        this.print(firstParam, node);\n        this.dedent();\n\n        this._catchUp("start", node.body.loc);\n      } else {\n        this.print(firstParam, node);\n      }\n\n      this.token(")");\n    } else {\n      this.print(firstParam, node);\n    }\n  } else {\n    this._params(node);\n  }\n\n  this._predicate(node);\n\n  this.space();\n  this.token("=>");\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction hasTypes(node, param) {\n  return node.typeParameters || node.returnType || param.typeAnnotation || param.optional || param.trailingComments;\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/generator/lib/generators/methods.js?')},97064:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.ImportSpecifier = ImportSpecifier;\nexports.ImportDefaultSpecifier = ImportDefaultSpecifier;\nexports.ExportDefaultSpecifier = ExportDefaultSpecifier;\nexports.ExportSpecifier = ExportSpecifier;\nexports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;\nexports.ExportAllDeclaration = ExportAllDeclaration;\nexports.ExportNamedDeclaration = ExportNamedDeclaration;\nexports.ExportDefaultDeclaration = ExportDefaultDeclaration;\nexports.ImportDeclaration = ImportDeclaration;\nexports.ImportAttribute = ImportAttribute;\nexports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;\n\nvar t = _interopRequireWildcard(__webpack_require__(38218));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction ImportSpecifier(node) {\n  if (node.importKind === "type" || node.importKind === "typeof") {\n    this.word(node.importKind);\n    this.space();\n  }\n\n  this.print(node.imported, node);\n\n  if (node.local && node.local.name !== node.imported.name) {\n    this.space();\n    this.word("as");\n    this.space();\n    this.print(node.local, node);\n  }\n}\n\nfunction ImportDefaultSpecifier(node) {\n  this.print(node.local, node);\n}\n\nfunction ExportDefaultSpecifier(node) {\n  this.print(node.exported, node);\n}\n\nfunction ExportSpecifier(node) {\n  this.print(node.local, node);\n\n  if (node.exported && node.local.name !== node.exported.name) {\n    this.space();\n    this.word("as");\n    this.space();\n    this.print(node.exported, node);\n  }\n}\n\nfunction ExportNamespaceSpecifier(node) {\n  this.token("*");\n  this.space();\n  this.word("as");\n  this.space();\n  this.print(node.exported, node);\n}\n\nfunction ExportAllDeclaration(node) {\n  this.word("export");\n  this.space();\n\n  if (node.exportKind === "type") {\n    this.word("type");\n    this.space();\n  }\n\n  this.token("*");\n  this.space();\n  this.word("from");\n  this.space();\n  this.print(node.source, node);\n  this.printAssertions(node);\n  this.semicolon();\n}\n\nfunction ExportNamedDeclaration(node) {\n  if (this.format.decoratorsBeforeExport && t.isClassDeclaration(node.declaration)) {\n    this.printJoin(node.declaration.decorators, node);\n  }\n\n  this.word("export");\n  this.space();\n  ExportDeclaration.apply(this, arguments);\n}\n\nfunction ExportDefaultDeclaration(node) {\n  if (this.format.decoratorsBeforeExport && t.isClassDeclaration(node.declaration)) {\n    this.printJoin(node.declaration.decorators, node);\n  }\n\n  this.word("export");\n  this.space();\n  this.word("default");\n  this.space();\n  ExportDeclaration.apply(this, arguments);\n}\n\nfunction ExportDeclaration(node) {\n  if (node.declaration) {\n    const declar = node.declaration;\n    this.print(declar, node);\n    if (!t.isStatement(declar)) this.semicolon();\n  } else {\n    if (node.exportKind === "type") {\n      this.word("type");\n      this.space();\n    }\n\n    const specifiers = node.specifiers.slice(0);\n    let hasSpecial = false;\n\n    for (;;) {\n      const first = specifiers[0];\n\n      if (t.isExportDefaultSpecifier(first) || t.isExportNamespaceSpecifier(first)) {\n        hasSpecial = true;\n        this.print(specifiers.shift(), node);\n\n        if (specifiers.length) {\n          this.token(",");\n          this.space();\n        }\n      } else {\n        break;\n      }\n    }\n\n    if (specifiers.length || !specifiers.length && !hasSpecial) {\n      this.token("{");\n\n      if (specifiers.length) {\n        this.space();\n        this.printList(specifiers, node);\n        this.space();\n      }\n\n      this.token("}");\n    }\n\n    if (node.source) {\n      this.space();\n      this.word("from");\n      this.space();\n      this.print(node.source, node);\n      this.printAssertions(node);\n    }\n\n    this.semicolon();\n  }\n}\n\nfunction ImportDeclaration(node) {\n  var _node$attributes;\n\n  this.word("import");\n  this.space();\n\n  if (node.importKind === "type" || node.importKind === "typeof") {\n    this.word(node.importKind);\n    this.space();\n  }\n\n  const specifiers = node.specifiers.slice(0);\n\n  if (specifiers == null ? void 0 : specifiers.length) {\n    for (;;) {\n      const first = specifiers[0];\n\n      if (t.isImportDefaultSpecifier(first) || t.isImportNamespaceSpecifier(first)) {\n        this.print(specifiers.shift(), node);\n\n        if (specifiers.length) {\n          this.token(",");\n          this.space();\n        }\n      } else {\n        break;\n      }\n    }\n\n    if (specifiers.length) {\n      this.token("{");\n      this.space();\n      this.printList(specifiers, node);\n      this.space();\n      this.token("}");\n    }\n\n    this.space();\n    this.word("from");\n    this.space();\n  }\n\n  this.print(node.source, node);\n  this.printAssertions(node);\n\n  if ((_node$attributes = node.attributes) == null ? void 0 : _node$attributes.length) {\n    this.space();\n    this.word("with");\n    this.space();\n    this.printList(node.attributes, node);\n  }\n\n  this.semicolon();\n}\n\nfunction ImportAttribute(node) {\n  this.print(node.key);\n  this.token(":");\n  this.space();\n  this.print(node.value);\n}\n\nfunction ImportNamespaceSpecifier(node) {\n  this.token("*");\n  this.space();\n  this.word("as");\n  this.space();\n  this.print(node.local, node);\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/generator/lib/generators/modules.js?')},16787:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.WithStatement = WithStatement;\nexports.IfStatement = IfStatement;\nexports.ForStatement = ForStatement;\nexports.WhileStatement = WhileStatement;\nexports.DoWhileStatement = DoWhileStatement;\nexports.LabeledStatement = LabeledStatement;\nexports.TryStatement = TryStatement;\nexports.CatchClause = CatchClause;\nexports.SwitchStatement = SwitchStatement;\nexports.SwitchCase = SwitchCase;\nexports.DebuggerStatement = DebuggerStatement;\nexports.VariableDeclaration = VariableDeclaration;\nexports.VariableDeclarator = VariableDeclarator;\nexports.ThrowStatement = exports.BreakStatement = exports.ReturnStatement = exports.ContinueStatement = exports.ForOfStatement = exports.ForInStatement = void 0;\n\nvar t = _interopRequireWildcard(__webpack_require__(38218));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction WithStatement(node) {\n  this.word("with");\n  this.space();\n  this.token("(");\n  this.print(node.object, node);\n  this.token(")");\n  this.printBlock(node);\n}\n\nfunction IfStatement(node) {\n  this.word("if");\n  this.space();\n  this.token("(");\n  this.print(node.test, node);\n  this.token(")");\n  this.space();\n  const needsBlock = node.alternate && t.isIfStatement(getLastStatement(node.consequent));\n\n  if (needsBlock) {\n    this.token("{");\n    this.newline();\n    this.indent();\n  }\n\n  this.printAndIndentOnComments(node.consequent, node);\n\n  if (needsBlock) {\n    this.dedent();\n    this.newline();\n    this.token("}");\n  }\n\n  if (node.alternate) {\n    if (this.endsWith("}")) this.space();\n    this.word("else");\n    this.space();\n    this.printAndIndentOnComments(node.alternate, node);\n  }\n}\n\nfunction getLastStatement(statement) {\n  if (!t.isStatement(statement.body)) return statement;\n  return getLastStatement(statement.body);\n}\n\nfunction ForStatement(node) {\n  this.word("for");\n  this.space();\n  this.token("(");\n  this.inForStatementInitCounter++;\n  this.print(node.init, node);\n  this.inForStatementInitCounter--;\n  this.token(";");\n\n  if (node.test) {\n    this.space();\n    this.print(node.test, node);\n  }\n\n  this.token(";");\n\n  if (node.update) {\n    this.space();\n    this.print(node.update, node);\n  }\n\n  this.token(")");\n  this.printBlock(node);\n}\n\nfunction WhileStatement(node) {\n  this.word("while");\n  this.space();\n  this.token("(");\n  this.print(node.test, node);\n  this.token(")");\n  this.printBlock(node);\n}\n\nconst buildForXStatement = function (op) {\n  return function (node) {\n    this.word("for");\n    this.space();\n\n    if (op === "of" && node.await) {\n      this.word("await");\n      this.space();\n    }\n\n    this.token("(");\n    this.print(node.left, node);\n    this.space();\n    this.word(op);\n    this.space();\n    this.print(node.right, node);\n    this.token(")");\n    this.printBlock(node);\n  };\n};\n\nconst ForInStatement = buildForXStatement("in");\nexports.ForInStatement = ForInStatement;\nconst ForOfStatement = buildForXStatement("of");\nexports.ForOfStatement = ForOfStatement;\n\nfunction DoWhileStatement(node) {\n  this.word("do");\n  this.space();\n  this.print(node.body, node);\n  this.space();\n  this.word("while");\n  this.space();\n  this.token("(");\n  this.print(node.test, node);\n  this.token(")");\n  this.semicolon();\n}\n\nfunction buildLabelStatement(prefix, key = "label") {\n  return function (node) {\n    this.word(prefix);\n    const label = node[key];\n\n    if (label) {\n      this.space();\n      const isLabel = key == "label";\n      const terminatorState = this.startTerminatorless(isLabel);\n      this.print(label, node);\n      this.endTerminatorless(terminatorState);\n    }\n\n    this.semicolon();\n  };\n}\n\nconst ContinueStatement = buildLabelStatement("continue");\nexports.ContinueStatement = ContinueStatement;\nconst ReturnStatement = buildLabelStatement("return", "argument");\nexports.ReturnStatement = ReturnStatement;\nconst BreakStatement = buildLabelStatement("break");\nexports.BreakStatement = BreakStatement;\nconst ThrowStatement = buildLabelStatement("throw", "argument");\nexports.ThrowStatement = ThrowStatement;\n\nfunction LabeledStatement(node) {\n  this.print(node.label, node);\n  this.token(":");\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction TryStatement(node) {\n  this.word("try");\n  this.space();\n  this.print(node.block, node);\n  this.space();\n\n  if (node.handlers) {\n    this.print(node.handlers[0], node);\n  } else {\n    this.print(node.handler, node);\n  }\n\n  if (node.finalizer) {\n    this.space();\n    this.word("finally");\n    this.space();\n    this.print(node.finalizer, node);\n  }\n}\n\nfunction CatchClause(node) {\n  this.word("catch");\n  this.space();\n\n  if (node.param) {\n    this.token("(");\n    this.print(node.param, node);\n    this.print(node.param.typeAnnotation, node);\n    this.token(")");\n    this.space();\n  }\n\n  this.print(node.body, node);\n}\n\nfunction SwitchStatement(node) {\n  this.word("switch");\n  this.space();\n  this.token("(");\n  this.print(node.discriminant, node);\n  this.token(")");\n  this.space();\n  this.token("{");\n  this.printSequence(node.cases, node, {\n    indent: true,\n\n    addNewlines(leading, cas) {\n      if (!leading && node.cases[node.cases.length - 1] === cas) return -1;\n    }\n\n  });\n  this.token("}");\n}\n\nfunction SwitchCase(node) {\n  if (node.test) {\n    this.word("case");\n    this.space();\n    this.print(node.test, node);\n    this.token(":");\n  } else {\n    this.word("default");\n    this.token(":");\n  }\n\n  if (node.consequent.length) {\n    this.newline();\n    this.printSequence(node.consequent, node, {\n      indent: true\n    });\n  }\n}\n\nfunction DebuggerStatement() {\n  this.word("debugger");\n  this.semicolon();\n}\n\nfunction variableDeclarationIndent() {\n  this.token(",");\n  this.newline();\n  if (this.endsWith("\\n")) for (let i = 0; i < 4; i++) this.space(true);\n}\n\nfunction constDeclarationIndent() {\n  this.token(",");\n  this.newline();\n  if (this.endsWith("\\n")) for (let i = 0; i < 6; i++) this.space(true);\n}\n\nfunction VariableDeclaration(node, parent) {\n  if (node.declare) {\n    this.word("declare");\n    this.space();\n  }\n\n  this.word(node.kind);\n  this.space();\n  let hasInits = false;\n\n  if (!t.isFor(parent)) {\n    for (const declar of node.declarations) {\n      if (declar.init) {\n        hasInits = true;\n      }\n    }\n  }\n\n  let separator;\n\n  if (hasInits) {\n    separator = node.kind === "const" ? constDeclarationIndent : variableDeclarationIndent;\n  }\n\n  this.printList(node.declarations, node, {\n    separator\n  });\n\n  if (t.isFor(parent)) {\n    if (parent.left === node || parent.init === node) return;\n  }\n\n  this.semicolon();\n}\n\nfunction VariableDeclarator(node) {\n  this.print(node.id, node);\n  if (node.definite) this.token("!");\n  this.print(node.id.typeAnnotation, node);\n\n  if (node.init) {\n    this.space();\n    this.token("=");\n    this.space();\n    this.print(node.init, node);\n  }\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/generator/lib/generators/statements.js?')},82347:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nexports.TemplateElement = TemplateElement;\nexports.TemplateLiteral = TemplateLiteral;\n\nfunction TaggedTemplateExpression(node) {\n  this.print(node.tag, node);\n  this.print(node.typeParameters, node);\n  this.print(node.quasi, node);\n}\n\nfunction TemplateElement(node, parent) {\n  const isFirst = parent.quasis[0] === node;\n  const isLast = parent.quasis[parent.quasis.length - 1] === node;\n  const value = (isFirst ? "`" : "}") + node.value.raw + (isLast ? "`" : "${");\n  this.token(value);\n}\n\nfunction TemplateLiteral(node) {\n  const quasis = node.quasis;\n\n  for (let i = 0; i < quasis.length; i++) {\n    this.print(quasis[i], node);\n\n    if (i + 1 < quasis.length) {\n      this.print(node.expressions[i], node);\n    }\n  }\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/generator/lib/generators/template-literals.js?')},55718:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.Identifier = Identifier;\nexports.ArgumentPlaceholder = ArgumentPlaceholder;\nexports.SpreadElement = exports.RestElement = RestElement;\nexports.ObjectPattern = exports.ObjectExpression = ObjectExpression;\nexports.ObjectMethod = ObjectMethod;\nexports.ObjectProperty = ObjectProperty;\nexports.ArrayPattern = exports.ArrayExpression = ArrayExpression;\nexports.RecordExpression = RecordExpression;\nexports.TupleExpression = TupleExpression;\nexports.RegExpLiteral = RegExpLiteral;\nexports.BooleanLiteral = BooleanLiteral;\nexports.NullLiteral = NullLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.StringLiteral = StringLiteral;\nexports.BigIntLiteral = BigIntLiteral;\nexports.DecimalLiteral = DecimalLiteral;\nexports.PipelineTopicExpression = PipelineTopicExpression;\nexports.PipelineBareFunction = PipelineBareFunction;\nexports.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;\n\nvar t = _interopRequireWildcard(__webpack_require__(38218));\n\nvar _jsesc = _interopRequireDefault(__webpack_require__(3312));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction Identifier(node) {\n  this.exactSource(node.loc, () => {\n    this.word(node.name);\n  });\n}\n\nfunction ArgumentPlaceholder() {\n  this.token("?");\n}\n\nfunction RestElement(node) {\n  this.token("...");\n  this.print(node.argument, node);\n}\n\nfunction ObjectExpression(node) {\n  const props = node.properties;\n  this.token("{");\n  this.printInnerComments(node);\n\n  if (props.length) {\n    this.space();\n    this.printList(props, node, {\n      indent: true,\n      statement: true\n    });\n    this.space();\n  }\n\n  this.token("}");\n}\n\nfunction ObjectMethod(node) {\n  this.printJoin(node.decorators, node);\n\n  this._methodHead(node);\n\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction ObjectProperty(node) {\n  this.printJoin(node.decorators, node);\n\n  if (node.computed) {\n    this.token("[");\n    this.print(node.key, node);\n    this.token("]");\n  } else {\n    if (t.isAssignmentPattern(node.value) && t.isIdentifier(node.key) && node.key.name === node.value.left.name) {\n      this.print(node.value, node);\n      return;\n    }\n\n    this.print(node.key, node);\n\n    if (node.shorthand && t.isIdentifier(node.key) && t.isIdentifier(node.value) && node.key.name === node.value.name) {\n      return;\n    }\n  }\n\n  this.token(":");\n  this.space();\n  this.print(node.value, node);\n}\n\nfunction ArrayExpression(node) {\n  const elems = node.elements;\n  const len = elems.length;\n  this.token("[");\n  this.printInnerComments(node);\n\n  for (let i = 0; i < elems.length; i++) {\n    const elem = elems[i];\n\n    if (elem) {\n      if (i > 0) this.space();\n      this.print(elem, node);\n      if (i < len - 1) this.token(",");\n    } else {\n      this.token(",");\n    }\n  }\n\n  this.token("]");\n}\n\nfunction RecordExpression(node) {\n  const props = node.properties;\n  let startToken;\n  let endToken;\n\n  if (this.format.recordAndTupleSyntaxType === "bar") {\n    startToken = "{|";\n    endToken = "|}";\n  } else if (this.format.recordAndTupleSyntaxType === "hash") {\n    startToken = "#{";\n    endToken = "}";\n  } else {\n    throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);\n  }\n\n  this.token(startToken);\n  this.printInnerComments(node);\n\n  if (props.length) {\n    this.space();\n    this.printList(props, node, {\n      indent: true,\n      statement: true\n    });\n    this.space();\n  }\n\n  this.token(endToken);\n}\n\nfunction TupleExpression(node) {\n  const elems = node.elements;\n  const len = elems.length;\n  let startToken;\n  let endToken;\n\n  if (this.format.recordAndTupleSyntaxType === "bar") {\n    startToken = "[|";\n    endToken = "|]";\n  } else if (this.format.recordAndTupleSyntaxType === "hash") {\n    startToken = "#[";\n    endToken = "]";\n  } else {\n    throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);\n  }\n\n  this.token(startToken);\n  this.printInnerComments(node);\n\n  for (let i = 0; i < elems.length; i++) {\n    const elem = elems[i];\n\n    if (elem) {\n      if (i > 0) this.space();\n      this.print(elem, node);\n      if (i < len - 1) this.token(",");\n    }\n  }\n\n  this.token(endToken);\n}\n\nfunction RegExpLiteral(node) {\n  this.word(`/${node.pattern}/${node.flags}`);\n}\n\nfunction BooleanLiteral(node) {\n  this.word(node.value ? "true" : "false");\n}\n\nfunction NullLiteral() {\n  this.word("null");\n}\n\nfunction NumericLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n  const opts = this.format.jsescOption;\n  const value = node.value + "";\n\n  if (opts.numbers) {\n    this.number((0, _jsesc.default)(node.value, opts));\n  } else if (raw == null) {\n    this.number(value);\n  } else if (this.format.minified) {\n    this.number(raw.length < value.length ? raw : value);\n  } else {\n    this.number(raw);\n  }\n}\n\nfunction StringLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n\n  if (!this.format.minified && raw != null) {\n    this.token(raw);\n    return;\n  }\n\n  const val = (0, _jsesc.default)(node.value, Object.assign(this.format.jsescOption, this.format.jsonCompatibleStrings && {\n    json: true\n  }));\n  return this.token(val);\n}\n\nfunction BigIntLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n\n  if (!this.format.minified && raw != null) {\n    this.word(raw);\n    return;\n  }\n\n  this.word(node.value + "n");\n}\n\nfunction DecimalLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n\n  if (!this.format.minified && raw != null) {\n    this.word(raw);\n    return;\n  }\n\n  this.word(node.value + "m");\n}\n\nfunction PipelineTopicExpression(node) {\n  this.print(node.expression, node);\n}\n\nfunction PipelineBareFunction(node) {\n  this.print(node.callee, node);\n}\n\nfunction PipelinePrimaryTopicReference() {\n  this.token("#");\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/generator/lib/generators/types.js?')},82043:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.TSTypeAnnotation = TSTypeAnnotation;\nexports.TSTypeParameterDeclaration = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;\nexports.TSTypeParameter = TSTypeParameter;\nexports.TSParameterProperty = TSParameterProperty;\nexports.TSDeclareFunction = TSDeclareFunction;\nexports.TSDeclareMethod = TSDeclareMethod;\nexports.TSQualifiedName = TSQualifiedName;\nexports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;\nexports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;\nexports.TSPropertySignature = TSPropertySignature;\nexports.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;\nexports.TSMethodSignature = TSMethodSignature;\nexports.TSIndexSignature = TSIndexSignature;\nexports.TSAnyKeyword = TSAnyKeyword;\nexports.TSBigIntKeyword = TSBigIntKeyword;\nexports.TSUnknownKeyword = TSUnknownKeyword;\nexports.TSNumberKeyword = TSNumberKeyword;\nexports.TSObjectKeyword = TSObjectKeyword;\nexports.TSBooleanKeyword = TSBooleanKeyword;\nexports.TSStringKeyword = TSStringKeyword;\nexports.TSSymbolKeyword = TSSymbolKeyword;\nexports.TSVoidKeyword = TSVoidKeyword;\nexports.TSUndefinedKeyword = TSUndefinedKeyword;\nexports.TSNullKeyword = TSNullKeyword;\nexports.TSNeverKeyword = TSNeverKeyword;\nexports.TSIntrinsicKeyword = TSIntrinsicKeyword;\nexports.TSThisType = TSThisType;\nexports.TSFunctionType = TSFunctionType;\nexports.TSConstructorType = TSConstructorType;\nexports.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;\nexports.TSTypeReference = TSTypeReference;\nexports.TSTypePredicate = TSTypePredicate;\nexports.TSTypeQuery = TSTypeQuery;\nexports.TSTypeLiteral = TSTypeLiteral;\nexports.tsPrintTypeLiteralOrInterfaceBody = tsPrintTypeLiteralOrInterfaceBody;\nexports.tsPrintBraced = tsPrintBraced;\nexports.TSArrayType = TSArrayType;\nexports.TSTupleType = TSTupleType;\nexports.TSOptionalType = TSOptionalType;\nexports.TSRestType = TSRestType;\nexports.TSNamedTupleMember = TSNamedTupleMember;\nexports.TSUnionType = TSUnionType;\nexports.TSIntersectionType = TSIntersectionType;\nexports.tsPrintUnionOrIntersectionType = tsPrintUnionOrIntersectionType;\nexports.TSConditionalType = TSConditionalType;\nexports.TSInferType = TSInferType;\nexports.TSParenthesizedType = TSParenthesizedType;\nexports.TSTypeOperator = TSTypeOperator;\nexports.TSIndexedAccessType = TSIndexedAccessType;\nexports.TSMappedType = TSMappedType;\nexports.TSLiteralType = TSLiteralType;\nexports.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;\nexports.TSInterfaceDeclaration = TSInterfaceDeclaration;\nexports.TSInterfaceBody = TSInterfaceBody;\nexports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;\nexports.TSAsExpression = TSAsExpression;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSEnumDeclaration = TSEnumDeclaration;\nexports.TSEnumMember = TSEnumMember;\nexports.TSModuleDeclaration = TSModuleDeclaration;\nexports.TSModuleBlock = TSModuleBlock;\nexports.TSImportType = TSImportType;\nexports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;\nexports.TSExternalModuleReference = TSExternalModuleReference;\nexports.TSNonNullExpression = TSNonNullExpression;\nexports.TSExportAssignment = TSExportAssignment;\nexports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;\nexports.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;\nexports.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;\n\nfunction TSTypeAnnotation(node) {\n  this.token(":");\n  this.space();\n  if (node.optional) this.token("?");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction TSTypeParameterInstantiation(node) {\n  this.token("<");\n  this.printList(node.params, node, {});\n  this.token(">");\n}\n\nfunction TSTypeParameter(node) {\n  this.word(node.name);\n\n  if (node.constraint) {\n    this.space();\n    this.word("extends");\n    this.space();\n    this.print(node.constraint, node);\n  }\n\n  if (node.default) {\n    this.space();\n    this.token("=");\n    this.space();\n    this.print(node.default, node);\n  }\n}\n\nfunction TSParameterProperty(node) {\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n\n  if (node.readonly) {\n    this.word("readonly");\n    this.space();\n  }\n\n  this._param(node.parameter);\n}\n\nfunction TSDeclareFunction(node) {\n  if (node.declare) {\n    this.word("declare");\n    this.space();\n  }\n\n  this._functionHead(node);\n\n  this.token(";");\n}\n\nfunction TSDeclareMethod(node) {\n  this._classMethodHead(node);\n\n  this.token(";");\n}\n\nfunction TSQualifiedName(node) {\n  this.print(node.left, node);\n  this.token(".");\n  this.print(node.right, node);\n}\n\nfunction TSCallSignatureDeclaration(node) {\n  this.tsPrintSignatureDeclarationBase(node);\n  this.token(";");\n}\n\nfunction TSConstructSignatureDeclaration(node) {\n  this.word("new");\n  this.space();\n  this.tsPrintSignatureDeclarationBase(node);\n  this.token(";");\n}\n\nfunction TSPropertySignature(node) {\n  const {\n    readonly,\n    initializer\n  } = node;\n\n  if (readonly) {\n    this.word("readonly");\n    this.space();\n  }\n\n  this.tsPrintPropertyOrMethodName(node);\n  this.print(node.typeAnnotation, node);\n\n  if (initializer) {\n    this.space();\n    this.token("=");\n    this.space();\n    this.print(initializer, node);\n  }\n\n  this.token(";");\n}\n\nfunction tsPrintPropertyOrMethodName(node) {\n  if (node.computed) {\n    this.token("[");\n  }\n\n  this.print(node.key, node);\n\n  if (node.computed) {\n    this.token("]");\n  }\n\n  if (node.optional) {\n    this.token("?");\n  }\n}\n\nfunction TSMethodSignature(node) {\n  this.tsPrintPropertyOrMethodName(node);\n  this.tsPrintSignatureDeclarationBase(node);\n  this.token(";");\n}\n\nfunction TSIndexSignature(node) {\n  const {\n    readonly\n  } = node;\n\n  if (readonly) {\n    this.word("readonly");\n    this.space();\n  }\n\n  this.token("[");\n\n  this._parameters(node.parameters, node);\n\n  this.token("]");\n  this.print(node.typeAnnotation, node);\n  this.token(";");\n}\n\nfunction TSAnyKeyword() {\n  this.word("any");\n}\n\nfunction TSBigIntKeyword() {\n  this.word("bigint");\n}\n\nfunction TSUnknownKeyword() {\n  this.word("unknown");\n}\n\nfunction TSNumberKeyword() {\n  this.word("number");\n}\n\nfunction TSObjectKeyword() {\n  this.word("object");\n}\n\nfunction TSBooleanKeyword() {\n  this.word("boolean");\n}\n\nfunction TSStringKeyword() {\n  this.word("string");\n}\n\nfunction TSSymbolKeyword() {\n  this.word("symbol");\n}\n\nfunction TSVoidKeyword() {\n  this.word("void");\n}\n\nfunction TSUndefinedKeyword() {\n  this.word("undefined");\n}\n\nfunction TSNullKeyword() {\n  this.word("null");\n}\n\nfunction TSNeverKeyword() {\n  this.word("never");\n}\n\nfunction TSIntrinsicKeyword() {\n  this.word("intrinsic");\n}\n\nfunction TSThisType() {\n  this.word("this");\n}\n\nfunction TSFunctionType(node) {\n  this.tsPrintFunctionOrConstructorType(node);\n}\n\nfunction TSConstructorType(node) {\n  this.word("new");\n  this.space();\n  this.tsPrintFunctionOrConstructorType(node);\n}\n\nfunction tsPrintFunctionOrConstructorType(node) {\n  const {\n    typeParameters,\n    parameters\n  } = node;\n  this.print(typeParameters, node);\n  this.token("(");\n\n  this._parameters(parameters, node);\n\n  this.token(")");\n  this.space();\n  this.token("=>");\n  this.space();\n  this.print(node.typeAnnotation.typeAnnotation, node);\n}\n\nfunction TSTypeReference(node) {\n  this.print(node.typeName, node);\n  this.print(node.typeParameters, node);\n}\n\nfunction TSTypePredicate(node) {\n  if (node.asserts) {\n    this.word("asserts");\n    this.space();\n  }\n\n  this.print(node.parameterName);\n\n  if (node.typeAnnotation) {\n    this.space();\n    this.word("is");\n    this.space();\n    this.print(node.typeAnnotation.typeAnnotation);\n  }\n}\n\nfunction TSTypeQuery(node) {\n  this.word("typeof");\n  this.space();\n  this.print(node.exprName);\n}\n\nfunction TSTypeLiteral(node) {\n  this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);\n}\n\nfunction tsPrintTypeLiteralOrInterfaceBody(members, node) {\n  this.tsPrintBraced(members, node);\n}\n\nfunction tsPrintBraced(members, node) {\n  this.token("{");\n\n  if (members.length) {\n    this.indent();\n    this.newline();\n\n    for (const member of members) {\n      this.print(member, node);\n      this.newline();\n    }\n\n    this.dedent();\n    this.rightBrace();\n  } else {\n    this.token("}");\n  }\n}\n\nfunction TSArrayType(node) {\n  this.print(node.elementType, node);\n  this.token("[]");\n}\n\nfunction TSTupleType(node) {\n  this.token("[");\n  this.printList(node.elementTypes, node);\n  this.token("]");\n}\n\nfunction TSOptionalType(node) {\n  this.print(node.typeAnnotation, node);\n  this.token("?");\n}\n\nfunction TSRestType(node) {\n  this.token("...");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction TSNamedTupleMember(node) {\n  this.print(node.label, node);\n  if (node.optional) this.token("?");\n  this.token(":");\n  this.space();\n  this.print(node.elementType, node);\n}\n\nfunction TSUnionType(node) {\n  this.tsPrintUnionOrIntersectionType(node, "|");\n}\n\nfunction TSIntersectionType(node) {\n  this.tsPrintUnionOrIntersectionType(node, "&");\n}\n\nfunction tsPrintUnionOrIntersectionType(node, sep) {\n  this.printJoin(node.types, node, {\n    separator() {\n      this.space();\n      this.token(sep);\n      this.space();\n    }\n\n  });\n}\n\nfunction TSConditionalType(node) {\n  this.print(node.checkType);\n  this.space();\n  this.word("extends");\n  this.space();\n  this.print(node.extendsType);\n  this.space();\n  this.token("?");\n  this.space();\n  this.print(node.trueType);\n  this.space();\n  this.token(":");\n  this.space();\n  this.print(node.falseType);\n}\n\nfunction TSInferType(node) {\n  this.token("infer");\n  this.space();\n  this.print(node.typeParameter);\n}\n\nfunction TSParenthesizedType(node) {\n  this.token("(");\n  this.print(node.typeAnnotation, node);\n  this.token(")");\n}\n\nfunction TSTypeOperator(node) {\n  this.word(node.operator);\n  this.space();\n  this.print(node.typeAnnotation, node);\n}\n\nfunction TSIndexedAccessType(node) {\n  this.print(node.objectType, node);\n  this.token("[");\n  this.print(node.indexType, node);\n  this.token("]");\n}\n\nfunction TSMappedType(node) {\n  const {\n    nameType,\n    optional,\n    readonly,\n    typeParameter\n  } = node;\n  this.token("{");\n  this.space();\n\n  if (readonly) {\n    tokenIfPlusMinus(this, readonly);\n    this.word("readonly");\n    this.space();\n  }\n\n  this.token("[");\n  this.word(typeParameter.name);\n  this.space();\n  this.word("in");\n  this.space();\n  this.print(typeParameter.constraint, typeParameter);\n\n  if (nameType) {\n    this.space();\n    this.word("as");\n    this.space();\n    this.print(nameType, node);\n  }\n\n  this.token("]");\n\n  if (optional) {\n    tokenIfPlusMinus(this, optional);\n    this.token("?");\n  }\n\n  this.token(":");\n  this.space();\n  this.print(node.typeAnnotation, node);\n  this.space();\n  this.token("}");\n}\n\nfunction tokenIfPlusMinus(self, tok) {\n  if (tok !== true) {\n    self.token(tok);\n  }\n}\n\nfunction TSLiteralType(node) {\n  this.print(node.literal, node);\n}\n\nfunction TSExpressionWithTypeArguments(node) {\n  this.print(node.expression, node);\n  this.print(node.typeParameters, node);\n}\n\nfunction TSInterfaceDeclaration(node) {\n  const {\n    declare,\n    id,\n    typeParameters,\n    extends: extendz,\n    body\n  } = node;\n\n  if (declare) {\n    this.word("declare");\n    this.space();\n  }\n\n  this.word("interface");\n  this.space();\n  this.print(id, node);\n  this.print(typeParameters, node);\n\n  if (extendz) {\n    this.space();\n    this.word("extends");\n    this.space();\n    this.printList(extendz, node);\n  }\n\n  this.space();\n  this.print(body, node);\n}\n\nfunction TSInterfaceBody(node) {\n  this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);\n}\n\nfunction TSTypeAliasDeclaration(node) {\n  const {\n    declare,\n    id,\n    typeParameters,\n    typeAnnotation\n  } = node;\n\n  if (declare) {\n    this.word("declare");\n    this.space();\n  }\n\n  this.word("type");\n  this.space();\n  this.print(id, node);\n  this.print(typeParameters, node);\n  this.space();\n  this.token("=");\n  this.space();\n  this.print(typeAnnotation, node);\n  this.token(";");\n}\n\nfunction TSAsExpression(node) {\n  const {\n    expression,\n    typeAnnotation\n  } = node;\n  this.print(expression, node);\n  this.space();\n  this.word("as");\n  this.space();\n  this.print(typeAnnotation, node);\n}\n\nfunction TSTypeAssertion(node) {\n  const {\n    typeAnnotation,\n    expression\n  } = node;\n  this.token("<");\n  this.print(typeAnnotation, node);\n  this.token(">");\n  this.space();\n  this.print(expression, node);\n}\n\nfunction TSEnumDeclaration(node) {\n  const {\n    declare,\n    const: isConst,\n    id,\n    members\n  } = node;\n\n  if (declare) {\n    this.word("declare");\n    this.space();\n  }\n\n  if (isConst) {\n    this.word("const");\n    this.space();\n  }\n\n  this.word("enum");\n  this.space();\n  this.print(id, node);\n  this.space();\n  this.tsPrintBraced(members, node);\n}\n\nfunction TSEnumMember(node) {\n  const {\n    id,\n    initializer\n  } = node;\n  this.print(id, node);\n\n  if (initializer) {\n    this.space();\n    this.token("=");\n    this.space();\n    this.print(initializer, node);\n  }\n\n  this.token(",");\n}\n\nfunction TSModuleDeclaration(node) {\n  const {\n    declare,\n    id\n  } = node;\n\n  if (declare) {\n    this.word("declare");\n    this.space();\n  }\n\n  if (!node.global) {\n    this.word(id.type === "Identifier" ? "namespace" : "module");\n    this.space();\n  }\n\n  this.print(id, node);\n\n  if (!node.body) {\n    this.token(";");\n    return;\n  }\n\n  let body = node.body;\n\n  while (body.type === "TSModuleDeclaration") {\n    this.token(".");\n    this.print(body.id, body);\n    body = body.body;\n  }\n\n  this.space();\n  this.print(body, node);\n}\n\nfunction TSModuleBlock(node) {\n  this.tsPrintBraced(node.body, node);\n}\n\nfunction TSImportType(node) {\n  const {\n    argument,\n    qualifier,\n    typeParameters\n  } = node;\n  this.word("import");\n  this.token("(");\n  this.print(argument, node);\n  this.token(")");\n\n  if (qualifier) {\n    this.token(".");\n    this.print(qualifier, node);\n  }\n\n  if (typeParameters) {\n    this.print(typeParameters, node);\n  }\n}\n\nfunction TSImportEqualsDeclaration(node) {\n  const {\n    isExport,\n    id,\n    moduleReference\n  } = node;\n\n  if (isExport) {\n    this.word("export");\n    this.space();\n  }\n\n  this.word("import");\n  this.space();\n  this.print(id, node);\n  this.space();\n  this.token("=");\n  this.space();\n  this.print(moduleReference, node);\n  this.token(";");\n}\n\nfunction TSExternalModuleReference(node) {\n  this.token("require(");\n  this.print(node.expression, node);\n  this.token(")");\n}\n\nfunction TSNonNullExpression(node) {\n  this.print(node.expression, node);\n  this.token("!");\n}\n\nfunction TSExportAssignment(node) {\n  this.word("export");\n  this.space();\n  this.token("=");\n  this.space();\n  this.print(node.expression, node);\n  this.token(";");\n}\n\nfunction TSNamespaceExportDeclaration(node) {\n  this.word("export");\n  this.space();\n  this.word("as");\n  this.space();\n  this.word("namespace");\n  this.space();\n  this.print(node.id, node);\n}\n\nfunction tsPrintSignatureDeclarationBase(node) {\n  const {\n    typeParameters,\n    parameters\n  } = node;\n  this.print(typeParameters, node);\n  this.token("(");\n\n  this._parameters(parameters, node);\n\n  this.token(")");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction tsPrintClassMemberModifiers(node, isField) {\n  if (isField && node.declare) {\n    this.word("declare");\n    this.space();\n  }\n\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n\n  if (node.static) {\n    this.word("static");\n    this.space();\n  }\n\n  if (node.abstract) {\n    this.word("abstract");\n    this.space();\n  }\n\n  if (isField && node.readonly) {\n    this.word("readonly");\n    this.space();\n  }\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/generator/lib/generators/typescript.js?')},39166:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = _default;\nexports.CodeGenerator = void 0;\n\nvar _sourceMap = _interopRequireDefault(__webpack_require__(27853));\n\nvar _printer = _interopRequireDefault(__webpack_require__(13105));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass Generator extends _printer.default {\n  constructor(ast, opts = {}, code) {\n    const format = normalizeOptions(code, opts);\n    const map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;\n    super(format, map);\n    this.ast = void 0;\n    this.ast = ast;\n  }\n\n  generate() {\n    return super.generate(this.ast);\n  }\n\n}\n\nfunction normalizeOptions(code, opts) {\n  const format = {\n    auxiliaryCommentBefore: opts.auxiliaryCommentBefore,\n    auxiliaryCommentAfter: opts.auxiliaryCommentAfter,\n    shouldPrintComment: opts.shouldPrintComment,\n    retainLines: opts.retainLines,\n    retainFunctionParens: opts.retainFunctionParens,\n    comments: opts.comments == null || opts.comments,\n    compact: opts.compact,\n    minified: opts.minified,\n    concise: opts.concise,\n    indent: {\n      adjustMultilineComment: true,\n      style: "  ",\n      base: 0\n    },\n    decoratorsBeforeExport: !!opts.decoratorsBeforeExport,\n    jsescOption: Object.assign({\n      quotes: "double",\n      wrap: true\n    }, opts.jsescOption),\n    recordAndTupleSyntaxType: opts.recordAndTupleSyntaxType\n  };\n  {\n    format.jsonCompatibleStrings = opts.jsonCompatibleStrings;\n  }\n\n  if (format.minified) {\n    format.compact = true;\n\n    format.shouldPrintComment = format.shouldPrintComment || (() => format.comments);\n  } else {\n    format.shouldPrintComment = format.shouldPrintComment || (value => format.comments || value.indexOf("@license") >= 0 || value.indexOf("@preserve") >= 0);\n  }\n\n  if (format.compact === "auto") {\n    format.compact = code.length > 500000;\n\n    if (format.compact) {\n      console.error("[BABEL] Note: The code generator has deoptimised the styling of " + `${opts.filename} as it exceeds the max of ${"500KB"}.`);\n    }\n  }\n\n  if (format.compact) {\n    format.indent.adjustMultilineComment = false;\n  }\n\n  return format;\n}\n\nclass CodeGenerator {\n  constructor(ast, opts, code) {\n    this._generator = new Generator(ast, opts, code);\n  }\n\n  generate() {\n    return this._generator.generate();\n  }\n\n}\n\nexports.CodeGenerator = CodeGenerator;\n\nfunction _default(ast, opts, code) {\n  const gen = new Generator(ast, opts, code);\n  return gen.generate();\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/generator/lib/index.js?')},32866:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.needsWhitespace = needsWhitespace;\nexports.needsWhitespaceBefore = needsWhitespaceBefore;\nexports.needsWhitespaceAfter = needsWhitespaceAfter;\nexports.needsParens = needsParens;\n\nvar whitespace = _interopRequireWildcard(__webpack_require__(24114));\n\nvar parens = _interopRequireWildcard(__webpack_require__(52514));\n\nvar t = _interopRequireWildcard(__webpack_require__(38218));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction expandAliases(obj) {\n  const newObj = {};\n\n  function add(type, func) {\n    const fn = newObj[type];\n    newObj[type] = fn ? function (node, parent, stack) {\n      const result = fn(node, parent, stack);\n      return result == null ? func(node, parent, stack) : result;\n    } : func;\n  }\n\n  for (const type of Object.keys(obj)) {\n    const aliases = t.FLIPPED_ALIAS_KEYS[type];\n\n    if (aliases) {\n      for (const alias of aliases) {\n        add(alias, obj[type]);\n      }\n    } else {\n      add(type, obj[type]);\n    }\n  }\n\n  return newObj;\n}\n\nconst expandedParens = expandAliases(parens);\nconst expandedWhitespaceNodes = expandAliases(whitespace.nodes);\nconst expandedWhitespaceList = expandAliases(whitespace.list);\n\nfunction find(obj, node, parent, printStack) {\n  const fn = obj[node.type];\n  return fn ? fn(node, parent, printStack) : null;\n}\n\nfunction isOrHasCallExpression(node) {\n  if (t.isCallExpression(node)) {\n    return true;\n  }\n\n  return t.isMemberExpression(node) && isOrHasCallExpression(node.object);\n}\n\nfunction needsWhitespace(node, parent, type) {\n  if (!node) return 0;\n\n  if (t.isExpressionStatement(node)) {\n    node = node.expression;\n  }\n\n  let linesInfo = find(expandedWhitespaceNodes, node, parent);\n\n  if (!linesInfo) {\n    const items = find(expandedWhitespaceList, node, parent);\n\n    if (items) {\n      for (let i = 0; i < items.length; i++) {\n        linesInfo = needsWhitespace(items[i], node, type);\n        if (linesInfo) break;\n      }\n    }\n  }\n\n  if (typeof linesInfo === "object" && linesInfo !== null) {\n    return linesInfo[type] || 0;\n  }\n\n  return 0;\n}\n\nfunction needsWhitespaceBefore(node, parent) {\n  return needsWhitespace(node, parent, "before");\n}\n\nfunction needsWhitespaceAfter(node, parent) {\n  return needsWhitespace(node, parent, "after");\n}\n\nfunction needsParens(node, parent, printStack) {\n  if (!parent) return false;\n\n  if (t.isNewExpression(parent) && parent.callee === node) {\n    if (isOrHasCallExpression(node)) return true;\n  }\n\n  return find(expandedParens, node, parent, printStack);\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/generator/lib/node/index.js?')},52514:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.UpdateExpression = UpdateExpression;\nexports.ObjectExpression = ObjectExpression;\nexports.DoExpression = DoExpression;\nexports.Binary = Binary;\nexports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.TSAsExpression = TSAsExpression;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSIntersectionType = exports.TSUnionType = TSUnionType;\nexports.TSInferType = TSInferType;\nexports.BinaryExpression = BinaryExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.AwaitExpression = exports.YieldExpression = YieldExpression;\nexports.ClassExpression = ClassExpression;\nexports.UnaryLike = UnaryLike;\nexports.FunctionExpression = FunctionExpression;\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.OptionalCallExpression = exports.OptionalMemberExpression = OptionalMemberExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.LogicalExpression = LogicalExpression;\n\nvar t = _interopRequireWildcard(__webpack_require__(38218));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst PRECEDENCE = {\n  "||": 0,\n  "??": 0,\n  "&&": 1,\n  "|": 2,\n  "^": 3,\n  "&": 4,\n  "==": 5,\n  "===": 5,\n  "!=": 5,\n  "!==": 5,\n  "<": 6,\n  ">": 6,\n  "<=": 6,\n  ">=": 6,\n  in: 6,\n  instanceof: 6,\n  ">>": 7,\n  "<<": 7,\n  ">>>": 7,\n  "+": 8,\n  "-": 8,\n  "*": 9,\n  "/": 9,\n  "%": 9,\n  "**": 10\n};\n\nconst isClassExtendsClause = (node, parent) => (t.isClassDeclaration(parent) || t.isClassExpression(parent)) && parent.superClass === node;\n\nconst hasPostfixPart = (node, parent) => (t.isMemberExpression(parent) || t.isOptionalMemberExpression(parent)) && parent.object === node || (t.isCallExpression(parent) || t.isOptionalCallExpression(parent) || t.isNewExpression(parent)) && parent.callee === node || t.isTaggedTemplateExpression(parent) && parent.tag === node || t.isTSNonNullExpression(parent);\n\nfunction NullableTypeAnnotation(node, parent) {\n  return t.isArrayTypeAnnotation(parent);\n}\n\nfunction FunctionTypeAnnotation(node, parent, printStack) {\n  return t.isUnionTypeAnnotation(parent) || t.isIntersectionTypeAnnotation(parent) || t.isArrayTypeAnnotation(parent) || t.isTypeAnnotation(parent) && t.isArrowFunctionExpression(printStack[printStack.length - 3]);\n}\n\nfunction UpdateExpression(node, parent) {\n  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);\n}\n\nfunction ObjectExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack, {\n    considerArrow: true\n  });\n}\n\nfunction DoExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack);\n}\n\nfunction Binary(node, parent) {\n  if (node.operator === "**" && t.isBinaryExpression(parent, {\n    operator: "**"\n  })) {\n    return parent.left === node;\n  }\n\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n\n  if (hasPostfixPart(node, parent) || t.isUnaryLike(parent) || t.isAwaitExpression(parent)) {\n    return true;\n  }\n\n  if (t.isBinary(parent)) {\n    const parentOp = parent.operator;\n    const parentPos = PRECEDENCE[parentOp];\n    const nodeOp = node.operator;\n    const nodePos = PRECEDENCE[nodeOp];\n\n    if (parentPos === nodePos && parent.right === node && !t.isLogicalExpression(parent) || parentPos > nodePos) {\n      return true;\n    }\n  }\n}\n\nfunction UnionTypeAnnotation(node, parent) {\n  return t.isArrayTypeAnnotation(parent) || t.isNullableTypeAnnotation(parent) || t.isIntersectionTypeAnnotation(parent) || t.isUnionTypeAnnotation(parent);\n}\n\nfunction TSAsExpression() {\n  return true;\n}\n\nfunction TSTypeAssertion() {\n  return true;\n}\n\nfunction TSUnionType(node, parent) {\n  return t.isTSArrayType(parent) || t.isTSOptionalType(parent) || t.isTSIntersectionType(parent) || t.isTSUnionType(parent) || t.isTSRestType(parent);\n}\n\nfunction TSInferType(node, parent) {\n  return t.isTSArrayType(parent) || t.isTSOptionalType(parent);\n}\n\nfunction BinaryExpression(node, parent) {\n  return node.operator === "in" && (t.isVariableDeclarator(parent) || t.isFor(parent));\n}\n\nfunction SequenceExpression(node, parent) {\n  if (t.isForStatement(parent) || t.isThrowStatement(parent) || t.isReturnStatement(parent) || t.isIfStatement(parent) && parent.test === node || t.isWhileStatement(parent) && parent.test === node || t.isForInStatement(parent) && parent.right === node || t.isSwitchStatement(parent) && parent.discriminant === node || t.isExpressionStatement(parent) && parent.expression === node) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction YieldExpression(node, parent) {\n  return t.isBinary(parent) || t.isUnaryLike(parent) || hasPostfixPart(node, parent) || t.isAwaitExpression(parent) && t.isYieldExpression(node) || t.isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);\n}\n\nfunction ClassExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack, {\n    considerDefaultExports: true\n  });\n}\n\nfunction UnaryLike(node, parent) {\n  return hasPostfixPart(node, parent) || t.isBinaryExpression(parent, {\n    operator: "**",\n    left: node\n  }) || isClassExtendsClause(node, parent);\n}\n\nfunction FunctionExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack, {\n    considerDefaultExports: true\n  });\n}\n\nfunction ArrowFunctionExpression(node, parent) {\n  return t.isExportDeclaration(parent) || ConditionalExpression(node, parent);\n}\n\nfunction ConditionalExpression(node, parent) {\n  if (t.isUnaryLike(parent) || t.isBinary(parent) || t.isConditionalExpression(parent, {\n    test: node\n  }) || t.isAwaitExpression(parent) || t.isTSTypeAssertion(parent) || t.isTSAsExpression(parent)) {\n    return true;\n  }\n\n  return UnaryLike(node, parent);\n}\n\nfunction OptionalMemberExpression(node, parent) {\n  return t.isCallExpression(parent, {\n    callee: node\n  }) || t.isMemberExpression(parent, {\n    object: node\n  });\n}\n\nfunction AssignmentExpression(node, parent, printStack) {\n  if (t.isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression(node, parent, printStack);\n  }\n}\n\nfunction LogicalExpression(node, parent) {\n  switch (node.operator) {\n    case "||":\n      if (!t.isLogicalExpression(parent)) return false;\n      return parent.operator === "??" || parent.operator === "&&";\n\n    case "&&":\n      return t.isLogicalExpression(parent, {\n        operator: "??"\n      });\n\n    case "??":\n      return t.isLogicalExpression(parent) && parent.operator !== "??";\n  }\n}\n\nfunction isFirstInStatement(printStack, {\n  considerArrow = false,\n  considerDefaultExports = false\n} = {}) {\n  let i = printStack.length - 1;\n  let node = printStack[i];\n  i--;\n  let parent = printStack[i];\n\n  while (i >= 0) {\n    if (t.isExpressionStatement(parent, {\n      expression: node\n    }) || considerDefaultExports && t.isExportDefaultDeclaration(parent, {\n      declaration: node\n    }) || considerArrow && t.isArrowFunctionExpression(parent, {\n      body: node\n    })) {\n      return true;\n    }\n\n    if (hasPostfixPart(node, parent) && !t.isNewExpression(parent) || t.isSequenceExpression(parent) && parent.expressions[0] === node || t.isConditional(parent, {\n      test: node\n    }) || t.isBinary(parent, {\n      left: node\n    }) || t.isAssignmentExpression(parent, {\n      left: node\n    })) {\n      node = parent;\n      i--;\n      parent = printStack[i];\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/generator/lib/node/parentheses.js?')},24114:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.list = exports.nodes = void 0;\n\nvar t = _interopRequireWildcard(__webpack_require__(38218));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction crawl(node, state = {}) {\n  if (t.isMemberExpression(node) || t.isOptionalMemberExpression(node)) {\n    crawl(node.object, state);\n    if (node.computed) crawl(node.property, state);\n  } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {\n    crawl(node.left, state);\n    crawl(node.right, state);\n  } else if (t.isCallExpression(node) || t.isOptionalCallExpression(node)) {\n    state.hasCall = true;\n    crawl(node.callee, state);\n  } else if (t.isFunction(node)) {\n    state.hasFunction = true;\n  } else if (t.isIdentifier(node)) {\n    state.hasHelper = state.hasHelper || isHelper(node.callee);\n  }\n\n  return state;\n}\n\nfunction isHelper(node) {\n  if (t.isMemberExpression(node)) {\n    return isHelper(node.object) || isHelper(node.property);\n  } else if (t.isIdentifier(node)) {\n    return node.name === "require" || node.name[0] === "_";\n  } else if (t.isCallExpression(node)) {\n    return isHelper(node.callee);\n  } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {\n    return t.isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);\n  } else {\n    return false;\n  }\n}\n\nfunction isType(node) {\n  return t.isLiteral(node) || t.isObjectExpression(node) || t.isArrayExpression(node) || t.isIdentifier(node) || t.isMemberExpression(node);\n}\n\nconst nodes = {\n  AssignmentExpression(node) {\n    const state = crawl(node.right);\n\n    if (state.hasCall && state.hasHelper || state.hasFunction) {\n      return {\n        before: state.hasFunction,\n        after: true\n      };\n    }\n  },\n\n  SwitchCase(node, parent) {\n    return {\n      before: node.consequent.length || parent.cases[0] === node,\n      after: !node.consequent.length && parent.cases[parent.cases.length - 1] === node\n    };\n  },\n\n  LogicalExpression(node) {\n    if (t.isFunction(node.left) || t.isFunction(node.right)) {\n      return {\n        after: true\n      };\n    }\n  },\n\n  Literal(node) {\n    if (node.value === "use strict") {\n      return {\n        after: true\n      };\n    }\n  },\n\n  CallExpression(node) {\n    if (t.isFunction(node.callee) || isHelper(node)) {\n      return {\n        before: true,\n        after: true\n      };\n    }\n  },\n\n  OptionalCallExpression(node) {\n    if (t.isFunction(node.callee)) {\n      return {\n        before: true,\n        after: true\n      };\n    }\n  },\n\n  VariableDeclaration(node) {\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n      let enabled = isHelper(declar.id) && !isType(declar.init);\n\n      if (!enabled) {\n        const state = crawl(declar.init);\n        enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;\n      }\n\n      if (enabled) {\n        return {\n          before: true,\n          after: true\n        };\n      }\n    }\n  },\n\n  IfStatement(node) {\n    if (t.isBlockStatement(node.consequent)) {\n      return {\n        before: true,\n        after: true\n      };\n    }\n  }\n\n};\nexports.nodes = nodes;\n\nnodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function (node, parent) {\n  if (parent.properties[0] === node) {\n    return {\n      before: true\n    };\n  }\n};\n\nnodes.ObjectTypeCallProperty = function (node, parent) {\n  var _parent$properties;\n\n  if (parent.callProperties[0] === node && !((_parent$properties = parent.properties) == null ? void 0 : _parent$properties.length)) {\n    return {\n      before: true\n    };\n  }\n};\n\nnodes.ObjectTypeIndexer = function (node, parent) {\n  var _parent$properties2, _parent$callPropertie;\n\n  if (parent.indexers[0] === node && !((_parent$properties2 = parent.properties) == null ? void 0 : _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) == null ? void 0 : _parent$callPropertie.length)) {\n    return {\n      before: true\n    };\n  }\n};\n\nnodes.ObjectTypeInternalSlot = function (node, parent) {\n  var _parent$properties3, _parent$callPropertie2, _parent$indexers;\n\n  if (parent.internalSlots[0] === node && !((_parent$properties3 = parent.properties) == null ? void 0 : _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) == null ? void 0 : _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) == null ? void 0 : _parent$indexers.length)) {\n    return {\n      before: true\n    };\n  }\n};\n\nconst list = {\n  VariableDeclaration(node) {\n    return node.declarations.map(decl => decl.init);\n  },\n\n  ArrayExpression(node) {\n    return node.elements;\n  },\n\n  ObjectExpression(node) {\n    return node.properties;\n  }\n\n};\nexports.list = list;\n[["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function ([type, amounts]) {\n  if (typeof amounts === "boolean") {\n    amounts = {\n      after: amounts,\n      before: amounts\n    };\n  }\n\n  [type].concat(t.FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {\n    nodes[type] = function () {\n      return amounts;\n    };\n  });\n});\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/generator/lib/node/whitespace.js?')},13105:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar _buffer = _interopRequireDefault(__webpack_require__(28649));\n\nvar n = _interopRequireWildcard(__webpack_require__(32866));\n\nvar t = _interopRequireWildcard(__webpack_require__(38218));\n\nvar generatorFunctions = _interopRequireWildcard(__webpack_require__(38217));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst NON_DECIMAL_LITERAL = /^0[box]/;\nconst PURE_ANNOTATION_RE = /^\\s*[@#]__PURE__\\s*$/;\n\nclass Printer {\n  constructor(format, map) {\n    this.inForStatementInitCounter = 0;\n    this._printStack = [];\n    this._indent = 0;\n    this._insideAux = false;\n    this._printedCommentStarts = {};\n    this._parenPushNewlineState = null;\n    this._noLineTerminator = false;\n    this._printAuxAfterOnNextUserNode = false;\n    this._printedComments = new WeakSet();\n    this._endsWithInteger = false;\n    this._endsWithWord = false;\n    this.format = format || {};\n    this._buf = new _buffer.default(map);\n  }\n\n  generate(ast) {\n    this.print(ast);\n\n    this._maybeAddAuxComment();\n\n    return this._buf.get();\n  }\n\n  indent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent++;\n  }\n\n  dedent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent--;\n  }\n\n  semicolon(force = false) {\n    this._maybeAddAuxComment();\n\n    this._append(";", !force);\n  }\n\n  rightBrace() {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n\n    this.token("}");\n  }\n\n  space(force = false) {\n    if (this.format.compact) return;\n\n    if (this._buf.hasContent() && !this.endsWith(" ") && !this.endsWith("\\n") || force) {\n      this._space();\n    }\n  }\n\n  word(str) {\n    if (this._endsWithWord || this.endsWith("/") && str.indexOf("/") === 0) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n\n    this._append(str);\n\n    this._endsWithWord = true;\n  }\n\n  number(str) {\n    this.word(str);\n    this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str[str.length - 1] !== ".";\n  }\n\n  token(str) {\n    if (str === "--" && this.endsWith("!") || str[0] === "+" && this.endsWith("+") || str[0] === "-" && this.endsWith("-") || str[0] === "." && this._endsWithInteger) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n\n    this._append(str);\n  }\n\n  newline(i) {\n    if (this.format.retainLines || this.format.compact) return;\n\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n\n    if (this.endsWith("\\n\\n")) return;\n    if (typeof i !== "number") i = 1;\n    i = Math.min(2, i);\n    if (this.endsWith("{\\n") || this.endsWith(":\\n")) i--;\n    if (i <= 0) return;\n\n    for (let j = 0; j < i; j++) {\n      this._newline();\n    }\n  }\n\n  endsWith(str) {\n    return this._buf.endsWith(str);\n  }\n\n  removeTrailingNewline() {\n    this._buf.removeTrailingNewline();\n  }\n\n  exactSource(loc, cb) {\n    this._catchUp("start", loc);\n\n    this._buf.exactSource(loc, cb);\n  }\n\n  source(prop, loc) {\n    this._catchUp(prop, loc);\n\n    this._buf.source(prop, loc);\n  }\n\n  withSource(prop, loc, cb) {\n    this._catchUp(prop, loc);\n\n    this._buf.withSource(prop, loc, cb);\n  }\n\n  _space() {\n    this._append(" ", true);\n  }\n\n  _newline() {\n    this._append("\\n", true);\n  }\n\n  _append(str, queue = false) {\n    this._maybeAddParen(str);\n\n    this._maybeIndent(str);\n\n    if (queue) this._buf.queue(str);else this._buf.append(str);\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _maybeIndent(str) {\n    if (this._indent && this.endsWith("\\n") && str[0] !== "\\n") {\n      this._buf.queue(this._getIndent());\n    }\n  }\n\n  _maybeAddParen(str) {\n    const parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n    let i;\n\n    for (i = 0; i < str.length && str[i] === " "; i++) continue;\n\n    if (i === str.length) {\n      return;\n    }\n\n    const cha = str[i];\n\n    if (cha !== "\\n") {\n      if (cha !== "/" || i + 1 === str.length) {\n        this._parenPushNewlineState = null;\n        return;\n      }\n\n      const chaPost = str[i + 1];\n\n      if (chaPost === "*") {\n        if (PURE_ANNOTATION_RE.test(str.slice(i + 2, str.length - 2))) {\n          return;\n        }\n      } else if (chaPost !== "/") {\n        this._parenPushNewlineState = null;\n        return;\n      }\n    }\n\n    this.token("(");\n    this.indent();\n    parenPushNewlineState.printed = true;\n  }\n\n  _catchUp(prop, loc) {\n    if (!this.format.retainLines) return;\n    const pos = loc ? loc[prop] : null;\n\n    if ((pos == null ? void 0 : pos.line) != null) {\n      const count = pos.line - this._buf.getCurrentLine();\n\n      for (let i = 0; i < count; i++) {\n        this._newline();\n      }\n    }\n  }\n\n  _getIndent() {\n    return this.format.indent.style.repeat(this._indent);\n  }\n\n  startTerminatorless(isLabel = false) {\n    if (isLabel) {\n      this._noLineTerminator = true;\n      return null;\n    } else {\n      return this._parenPushNewlineState = {\n        printed: false\n      };\n    }\n  }\n\n  endTerminatorless(state) {\n    this._noLineTerminator = false;\n\n    if (state == null ? void 0 : state.printed) {\n      this.dedent();\n      this.newline();\n      this.token(")");\n    }\n  }\n\n  print(node, parent) {\n    if (!node) return;\n    const oldConcise = this.format.concise;\n\n    if (node._compact) {\n      this.format.concise = true;\n    }\n\n    const printMethod = this[node.type];\n\n    if (!printMethod) {\n      throw new ReferenceError(`unknown node of type ${JSON.stringify(node.type)} with constructor ${JSON.stringify(node == null ? void 0 : node.constructor.name)}`);\n    }\n\n    this._printStack.push(node);\n\n    const oldInAux = this._insideAux;\n    this._insideAux = !node.loc;\n\n    this._maybeAddAuxComment(this._insideAux && !oldInAux);\n\n    let needsParens = n.needsParens(node, parent, this._printStack);\n\n    if (this.format.retainFunctionParens && node.type === "FunctionExpression" && node.extra && node.extra.parenthesized) {\n      needsParens = true;\n    }\n\n    if (needsParens) this.token("(");\n\n    this._printLeadingComments(node);\n\n    const loc = t.isProgram(node) || t.isFile(node) ? null : node.loc;\n    this.withSource("start", loc, () => {\n      printMethod.call(this, node, parent);\n    });\n\n    this._printTrailingComments(node);\n\n    if (needsParens) this.token(")");\n\n    this._printStack.pop();\n\n    this.format.concise = oldConcise;\n    this._insideAux = oldInAux;\n  }\n\n  _maybeAddAuxComment(enteredPositionlessNode) {\n    if (enteredPositionlessNode) this._printAuxBeforeComment();\n    if (!this._insideAux) this._printAuxAfterComment();\n  }\n\n  _printAuxBeforeComment() {\n    if (this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = true;\n    const comment = this.format.auxiliaryCommentBefore;\n\n    if (comment) {\n      this._printComment({\n        type: "CommentBlock",\n        value: comment\n      });\n    }\n  }\n\n  _printAuxAfterComment() {\n    if (!this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = false;\n    const comment = this.format.auxiliaryCommentAfter;\n\n    if (comment) {\n      this._printComment({\n        type: "CommentBlock",\n        value: comment\n      });\n    }\n  }\n\n  getPossibleRaw(node) {\n    const extra = node.extra;\n\n    if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {\n      return extra.raw;\n    }\n  }\n\n  printJoin(nodes, parent, opts = {}) {\n    if (!(nodes == null ? void 0 : nodes.length)) return;\n    if (opts.indent) this.indent();\n    const newlineOpts = {\n      addNewlines: opts.addNewlines\n    };\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if (!node) continue;\n      if (opts.statement) this._printNewline(true, node, parent, newlineOpts);\n      this.print(node, parent);\n\n      if (opts.iterator) {\n        opts.iterator(node, i);\n      }\n\n      if (opts.separator && i < nodes.length - 1) {\n        opts.separator.call(this);\n      }\n\n      if (opts.statement) this._printNewline(false, node, parent, newlineOpts);\n    }\n\n    if (opts.indent) this.dedent();\n  }\n\n  printAndIndentOnComments(node, parent) {\n    const indent = node.leadingComments && node.leadingComments.length > 0;\n    if (indent) this.indent();\n    this.print(node, parent);\n    if (indent) this.dedent();\n  }\n\n  printBlock(parent) {\n    const node = parent.body;\n\n    if (!t.isEmptyStatement(node)) {\n      this.space();\n    }\n\n    this.print(node, parent);\n  }\n\n  _printTrailingComments(node) {\n    this._printComments(this._getComments(false, node));\n  }\n\n  _printLeadingComments(node) {\n    this._printComments(this._getComments(true, node), true);\n  }\n\n  printInnerComments(node, indent = true) {\n    var _node$innerComments;\n\n    if (!((_node$innerComments = node.innerComments) == null ? void 0 : _node$innerComments.length)) return;\n    if (indent) this.indent();\n\n    this._printComments(node.innerComments);\n\n    if (indent) this.dedent();\n  }\n\n  printSequence(nodes, parent, opts = {}) {\n    opts.statement = true;\n    return this.printJoin(nodes, parent, opts);\n  }\n\n  printList(items, parent, opts = {}) {\n    if (opts.separator == null) {\n      opts.separator = commaSeparator;\n    }\n\n    return this.printJoin(items, parent, opts);\n  }\n\n  _printNewline(leading, node, parent, opts) {\n    if (this.format.retainLines || this.format.compact) return;\n\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n\n    let lines = 0;\n\n    if (this._buf.hasContent()) {\n      if (!leading) lines++;\n      if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;\n      const needs = leading ? n.needsWhitespaceBefore : n.needsWhitespaceAfter;\n      if (needs(node, parent)) lines++;\n    }\n\n    this.newline(lines);\n  }\n\n  _getComments(leading, node) {\n    return node && (leading ? node.leadingComments : node.trailingComments) || [];\n  }\n\n  _printComment(comment, skipNewLines) {\n    if (!this.format.shouldPrintComment(comment.value)) return;\n    if (comment.ignore) return;\n    if (this._printedComments.has(comment)) return;\n\n    this._printedComments.add(comment);\n\n    if (comment.start != null) {\n      if (this._printedCommentStarts[comment.start]) return;\n      this._printedCommentStarts[comment.start] = true;\n    }\n\n    const isBlockComment = comment.type === "CommentBlock";\n    const printNewLines = isBlockComment && !skipNewLines && !this._noLineTerminator;\n    if (printNewLines && this._buf.hasContent()) this.newline(1);\n    if (!this.endsWith("[") && !this.endsWith("{")) this.space();\n    let val = !isBlockComment && !this._noLineTerminator ? `//${comment.value}\\n` : `/*${comment.value}*/`;\n\n    if (isBlockComment && this.format.indent.adjustMultilineComment) {\n      var _comment$loc;\n\n      const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;\n\n      if (offset) {\n        const newlineRegex = new RegExp("\\\\n\\\\s{1," + offset + "}", "g");\n        val = val.replace(newlineRegex, "\\n");\n      }\n\n      const indentSize = Math.max(this._getIndent().length, this.format.retainLines ? 0 : this._buf.getCurrentColumn());\n      val = val.replace(/\\n(?!$)/g, `\\n${" ".repeat(indentSize)}`);\n    }\n\n    if (this.endsWith("/")) this._space();\n    this.withSource("start", comment.loc, () => {\n      this._append(val);\n    });\n    if (printNewLines) this.newline(1);\n  }\n\n  _printComments(comments, inlinePureAnnotation) {\n    if (!(comments == null ? void 0 : comments.length)) return;\n\n    if (inlinePureAnnotation && comments.length === 1 && PURE_ANNOTATION_RE.test(comments[0].value)) {\n      this._printComment(comments[0], this._buf.hasContent() && !this.endsWith("\\n"));\n    } else {\n      for (const comment of comments) {\n        this._printComment(comment);\n      }\n    }\n  }\n\n  printAssertions(node) {\n    var _node$assertions;\n\n    if ((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) {\n      this.space();\n      this.word("assert");\n      this.space();\n      this.token("{");\n      this.space();\n      this.printList(node.assertions, node);\n      this.space();\n      this.token("}");\n    }\n  }\n\n}\n\nexports.default = Printer;\nObject.assign(Printer.prototype, generatorFunctions);\n\nfunction commaSeparator() {\n  this.token(",");\n  this.space();\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/generator/lib/printer.js?')},27853:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar _sourceMap = _interopRequireDefault(__webpack_require__(45515));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass SourceMap {\n  constructor(opts, code) {\n    this._cachedMap = null;\n    this._code = code;\n    this._opts = opts;\n    this._rawMappings = [];\n  }\n\n  get() {\n    if (!this._cachedMap) {\n      const map = this._cachedMap = new _sourceMap.default.SourceMapGenerator({\n        sourceRoot: this._opts.sourceRoot\n      });\n      const code = this._code;\n\n      if (typeof code === "string") {\n        map.setSourceContent(this._opts.sourceFileName.replace(/\\\\/g, "/"), code);\n      } else if (typeof code === "object") {\n        Object.keys(code).forEach(sourceFileName => {\n          map.setSourceContent(sourceFileName.replace(/\\\\/g, "/"), code[sourceFileName]);\n        });\n      }\n\n      this._rawMappings.forEach(mapping => map.addMapping(mapping), map);\n    }\n\n    return this._cachedMap.toJSON();\n  }\n\n  getRawMappings() {\n    return this._rawMappings.slice();\n  }\n\n  mark(generatedLine, generatedColumn, line, column, identifierName, filename, force) {\n    if (this._lastGenLine !== generatedLine && line === null) return;\n\n    if (!force && this._lastGenLine === generatedLine && this._lastSourceLine === line && this._lastSourceColumn === column) {\n      return;\n    }\n\n    this._cachedMap = null;\n    this._lastGenLine = generatedLine;\n    this._lastSourceLine = line;\n    this._lastSourceColumn = column;\n\n    this._rawMappings.push({\n      name: identifierName || undefined,\n      generated: {\n        line: generatedLine,\n        column: generatedColumn\n      },\n      source: line == null ? undefined : (filename || this._opts.sourceFileName).replace(/\\\\/g, "/"),\n      original: line == null ? undefined : {\n        line: line,\n        column: column\n      }\n    });\n  }\n\n}\n\nexports.default = SourceMap;\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/generator/lib/source-map.js?')},74188:(__unused_webpack_module,exports,__webpack_require__)=>{eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = __webpack_require__(88849);\nvar has = Object.prototype.hasOwnProperty;\nvar hasNativeMap = typeof Map !== \"undefined\";\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nfunction ArraySet() {\n  this._array = [];\n  this._set = hasNativeMap ? new Map() : Object.create(null);\n}\n\n/**\n * Static method for creating ArraySet instances from an existing array.\n */\nArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n  var set = new ArraySet();\n  for (var i = 0, len = aArray.length; i < len; i++) {\n    set.add(aArray[i], aAllowDuplicates);\n  }\n  return set;\n};\n\n/**\n * Return how many unique items are in this ArraySet. If duplicates have been\n * added, than those do not count towards the size.\n *\n * @returns Number\n */\nArraySet.prototype.size = function ArraySet_size() {\n  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n};\n\n/**\n * Add the given string to this set.\n *\n * @param String aStr\n */\nArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\n  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\n  var idx = this._array.length;\n  if (!isDuplicate || aAllowDuplicates) {\n    this._array.push(aStr);\n  }\n  if (!isDuplicate) {\n    if (hasNativeMap) {\n      this._set.set(aStr, idx);\n    } else {\n      this._set[sStr] = idx;\n    }\n  }\n};\n\n/**\n * Is the given string a member of this set?\n *\n * @param String aStr\n */\nArraySet.prototype.has = function ArraySet_has(aStr) {\n  if (hasNativeMap) {\n    return this._set.has(aStr);\n  } else {\n    var sStr = util.toSetString(aStr);\n    return has.call(this._set, sStr);\n  }\n};\n\n/**\n * What is the index of the given string in the array?\n *\n * @param String aStr\n */\nArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n  if (hasNativeMap) {\n    var idx = this._set.get(aStr);\n    if (idx >= 0) {\n        return idx;\n    }\n  } else {\n    var sStr = util.toSetString(aStr);\n    if (has.call(this._set, sStr)) {\n      return this._set[sStr];\n    }\n  }\n\n  throw new Error('\"' + aStr + '\" is not in the set.');\n};\n\n/**\n * What is the element at the given index?\n *\n * @param Number aIdx\n */\nArraySet.prototype.at = function ArraySet_at(aIdx) {\n  if (aIdx >= 0 && aIdx < this._array.length) {\n    return this._array[aIdx];\n  }\n  throw new Error('No element indexed by ' + aIdx);\n};\n\n/**\n * Returns the array representation of this set (which has the proper indices\n * indicated by indexOf). Note that this is a copy of the internal array used\n * for storing the members so that no one can mess with internal state.\n */\nArraySet.prototype.toArray = function ArraySet_toArray() {\n  return this._array.slice();\n};\n\nexports.I = ArraySet;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/generator/node_modules/source-map/lib/array-set.js?")},49074:(__unused_webpack_module,exports,__webpack_require__)=>{eval('/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar base64 = __webpack_require__(13985);\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nvar VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0\n    ? ((-aValue) << 1) + 1\n    : (aValue << 1) + 0;\n}\n\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */\nfunction fromVLQSigned(aValue) {\n  var isNegative = (aValue & 1) === 1;\n  var shifted = aValue >> 1;\n  return isNegative\n    ? -shifted\n    : shifted;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  var encoded = "";\n  var digit;\n\n  var vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n\n/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */\nexports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n  var strLen = aStr.length;\n  var result = 0;\n  var shift = 0;\n  var continuation, digit;\n\n  do {\n    if (aIndex >= strLen) {\n      throw new Error("Expected more digits in base 64 VLQ value.");\n    }\n\n    digit = base64.decode(aStr.charCodeAt(aIndex++));\n    if (digit === -1) {\n      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));\n    }\n\n    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n    digit &= VLQ_BASE_MASK;\n    result = result + (digit << shift);\n    shift += VLQ_BASE_SHIFT;\n  } while (continuation);\n\n  aOutParam.value = fromVLQSigned(result);\n  aOutParam.rest = aIndex;\n};\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/generator/node_modules/source-map/lib/base64-vlq.js?')},13985:(__unused_webpack_module,exports)=>{eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function (number) {\n  if (0 <= number && number < intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n\n/**\n * Decode a single base 64 character code digit to an integer. Returns -1 on\n * failure.\n */\nexports.decode = function (charCode) {\n  var bigA = 65;     // 'A'\n  var bigZ = 90;     // 'Z'\n\n  var littleA = 97;  // 'a'\n  var littleZ = 122; // 'z'\n\n  var zero = 48;     // '0'\n  var nine = 57;     // '9'\n\n  var plus = 43;     // '+'\n  var slash = 47;    // '/'\n\n  var littleOffset = 26;\n  var numberOffset = 52;\n\n  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n  if (bigA <= charCode && charCode <= bigZ) {\n    return (charCode - bigA);\n  }\n\n  // 26 - 51: abcdefghijklmnopqrstuvwxyz\n  if (littleA <= charCode && charCode <= littleZ) {\n    return (charCode - littleA + littleOffset);\n  }\n\n  // 52 - 61: 0123456789\n  if (zero <= charCode && charCode <= nine) {\n    return (charCode - zero + numberOffset);\n  }\n\n  // 62: +\n  if (charCode == plus) {\n    return 62;\n  }\n\n  // 63: /\n  if (charCode == slash) {\n    return 63;\n  }\n\n  // Invalid base64 digit.\n  return -1;\n};\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/generator/node_modules/source-map/lib/base64.js?")},94070:(__unused_webpack_module,exports)=>{eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n  // This function terminates when one of the following is true:\n  //\n  //   1. We find the exact element we are looking for.\n  //\n  //   2. We did not find the exact element, but we can return the index of\n  //      the next-closest element.\n  //\n  //   3. We did not find the exact element, and there is no next-closest\n  //      element than the one we are searching for, so we return -1.\n  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n  var cmp = aCompare(aNeedle, aHaystack[mid], true);\n  if (cmp === 0) {\n    // Found the element we are looking for.\n    return mid;\n  }\n  else if (cmp > 0) {\n    // Our needle is greater than aHaystack[mid].\n    if (aHigh - mid > 1) {\n      // The element is in the upper half.\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // The exact needle element was not found in this haystack. Determine if\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return aHigh < aHaystack.length ? aHigh : -1;\n    } else {\n      return mid;\n    }\n  }\n  else {\n    // Our needle is less than aHaystack[mid].\n    if (mid - aLow > 1) {\n      // The element is in the lower half.\n      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return mid;\n    } else {\n      return aLow < 0 ? -1 : aLow;\n    }\n  }\n}\n\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n  if (aHaystack.length === 0) {\n    return -1;\n  }\n\n  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n  if (index < 0) {\n    return -1;\n  }\n\n  // We have found either the exact element, or the next-closest element than\n  // the one we are searching for. However, there may be more than one such\n  // element. Make sure we always return the smallest of these.\n  while (index - 1 >= 0) {\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n      break;\n    }\n    --index;\n  }\n\n  return index;\n};\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/generator/node_modules/source-map/lib/binary-search.js?")},62578:(__unused_webpack_module,exports,__webpack_require__)=>{eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = __webpack_require__(88849);\n\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */\nfunction generatedPositionAfter(mappingA, mappingB) {\n  // Optimized for most common case\n  var lineA = mappingA.generatedLine;\n  var lineB = mappingB.generatedLine;\n  var columnA = mappingA.generatedColumn;\n  var columnB = mappingB.generatedColumn;\n  return lineB > lineA || lineB == lineA && columnB >= columnA ||\n         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n}\n\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a neglibable overhead in general\n * case for a large speedup in case of mappings being added in order.\n */\nfunction MappingList() {\n  this._array = [];\n  this._sorted = true;\n  // Serves as infimum\n  this._last = {generatedLine: -1, generatedColumn: 0};\n}\n\n/**\n * Iterate through internal items. This method takes the same arguments that\n * `Array.prototype.forEach` takes.\n *\n * NOTE: The order of the mappings is NOT guaranteed.\n */\nMappingList.prototype.unsortedForEach =\n  function MappingList_forEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n  };\n\n/**\n * Add the given source mapping.\n *\n * @param Object aMapping\n */\nMappingList.prototype.add = function MappingList_add(aMapping) {\n  if (generatedPositionAfter(this._last, aMapping)) {\n    this._last = aMapping;\n    this._array.push(aMapping);\n  } else {\n    this._sorted = false;\n    this._array.push(aMapping);\n  }\n};\n\n/**\n * Returns the flat, sorted array of mappings. The mappings are sorted by\n * generated position.\n *\n * WARNING: This method returns internal data without copying, for\n * performance. The return value must NOT be mutated, and should be treated as\n * an immutable borrow. If you want to take ownership, you must make your own\n * copy.\n */\nMappingList.prototype.toArray = function MappingList_toArray() {\n  if (!this._sorted) {\n    this._array.sort(util.compareByGeneratedPositionsInflated);\n    this._sorted = true;\n  }\n  return this._array;\n};\n\nexports.H = MappingList;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/generator/node_modules/source-map/lib/mapping-list.js?")},63816:(__unused_webpack_module,exports)=>{eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n// It turns out that some (most?) JavaScript engines don't self-host\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\n// custom comparator function, calling back and forth between the VM's C++ and\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n// worse generated code for the comparator function than would be optimal. In\n// fact, when sorting with a comparator, these costs outweigh the benefits of\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n// a ~3500ms mean speed-up in `bench/bench.html`.\n\n/**\n * Swap the elements indexed by `x` and `y` in the array `ary`.\n *\n * @param {Array} ary\n *        The array.\n * @param {Number} x\n *        The index of the first item.\n * @param {Number} y\n *        The index of the second item.\n */\nfunction swap(ary, x, y) {\n  var temp = ary[x];\n  ary[x] = ary[y];\n  ary[y] = temp;\n}\n\n/**\n * Returns a random integer within the range `low .. high` inclusive.\n *\n * @param {Number} low\n *        The lower bound on the range.\n * @param {Number} high\n *        The upper bound on the range.\n */\nfunction randomIntInRange(low, high) {\n  return Math.round(low + (Math.random() * (high - low)));\n}\n\n/**\n * The Quick Sort algorithm.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n * @param {Number} p\n *        Start index of the array\n * @param {Number} r\n *        End index of the array\n */\nfunction doQuickSort(ary, comparator, p, r) {\n  // If our lower bound is less than our upper bound, we (1) partition the\n  // array into two pieces and (2) recurse on each half. If it is not, this is\n  // the empty array and our base case.\n\n  if (p < r) {\n    // (1) Partitioning.\n    //\n    // The partitioning chooses a pivot between `p` and `r` and moves all\n    // elements that are less than or equal to the pivot to the before it, and\n    // all the elements that are greater than it after it. The effect is that\n    // once partition is done, the pivot is in the exact place it will be when\n    // the array is put in sorted order, and it will not need to be moved\n    // again. This runs in O(n) time.\n\n    // Always choose a random pivot so that an input array which is reverse\n    // sorted does not cause O(n^2) running time.\n    var pivotIndex = randomIntInRange(p, r);\n    var i = p - 1;\n\n    swap(ary, pivotIndex, r);\n    var pivot = ary[r];\n\n    // Immediately after `j` is incremented in this loop, the following hold\n    // true:\n    //\n    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n    //\n    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n    for (var j = p; j < r; j++) {\n      if (comparator(ary[j], pivot) <= 0) {\n        i += 1;\n        swap(ary, i, j);\n      }\n    }\n\n    swap(ary, i + 1, j);\n    var q = i + 1;\n\n    // (2) Recurse on each half.\n\n    doQuickSort(ary, comparator, p, q - 1);\n    doQuickSort(ary, comparator, q + 1, r);\n  }\n}\n\n/**\n * Sort the given array in-place with the given comparator function.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n */\nexports.U = function (ary, comparator) {\n  doQuickSort(ary, comparator, 0, ary.length - 1);\n};\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/generator/node_modules/source-map/lib/quick-sort.js?")},27944:(__unused_webpack_module,exports,__webpack_require__)=>{eval("var __webpack_unused_export__;\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = __webpack_require__(88849);\nvar binarySearch = __webpack_require__(94070);\nvar ArraySet = __webpack_require__(74188)/* .ArraySet */ .I;\nvar base64VLQ = __webpack_require__(49074);\nvar quickSort = __webpack_require__(63816)/* .quickSort */ .U;\n\nfunction SourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  return sourceMap.sections != null\n    ? new IndexedSourceMapConsumer(sourceMap)\n    : new BasicSourceMapConsumer(sourceMap);\n}\n\nSourceMapConsumer.fromSourceMap = function(aSourceMap) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\n\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\n\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n  get: function () {\n    if (!this.__generatedMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappings;\n  }\n});\n\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n  get: function () {\n    if (!this.__originalMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappings;\n  }\n});\n\nSourceMapConsumer.prototype._charIsMappingSeparator =\n  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n    var c = aStr.charAt(index);\n    return c === \";\" || c === \",\";\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  };\n\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\n/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file's line/column\n *        order or the original's source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */\nSourceMapConsumer.prototype.eachMapping =\n  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n    var context = aContext || null;\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    var mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n    }\n\n    var sourceRoot = this.sourceRoot;\n    mappings.map(function (mapping) {\n      var source = mapping.source === null ? null : this._sources.at(mapping.source);\n      if (source != null && sourceRoot != null) {\n        source = util.join(sourceRoot, source);\n      }\n      return {\n        source: source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : this._names.at(mapping.name)\n      };\n    }, this).forEach(aCallback, context);\n  };\n\n/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: Optional. the column number in the original source.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nSourceMapConsumer.prototype.allGeneratedPositionsFor =\n  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n    var line = util.getArg(aArgs, 'line');\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    var needle = {\n      source: util.getArg(aArgs, 'source'),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, 'column', 0)\n    };\n\n    if (this.sourceRoot != null) {\n      needle.source = util.relative(this.sourceRoot, needle.source);\n    }\n    if (!this._sources.has(needle.source)) {\n      return [];\n    }\n    needle.source = this._sources.indexOf(needle.source);\n\n    var mappings = [];\n\n    var index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \"originalLine\",\n                                  \"originalColumn\",\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        var originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping && mapping.originalLine === originalLine) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        var originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &&\n               mapping.originalLine === line &&\n               mapping.originalColumn == originalColumn) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  };\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The only parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nfunction BasicSourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sources = util.getArg(sourceMap, 'sources');\n  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n  // requires the array) to play nice here.\n  var names = util.getArg(sourceMap, 'names', []);\n  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n  var mappings = util.getArg(sourceMap, 'mappings');\n  var file = util.getArg(sourceMap, 'file', null);\n\n  // Once again, Sass deviates from the spec and supplies the version as a\n  // string rather than a number, so we use loose equality checking here.\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  sources = sources\n    .map(String)\n    // Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    .map(util.normalize)\n    // Always ensure that absolute sources are internally stored relative to\n    // the source root, if the source root is absolute. Not doing this would\n    // be particularly problematic when the source root is a prefix of the\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n    .map(function (source) {\n      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n        ? util.relative(sourceRoot, source)\n        : source;\n    });\n\n  // Pass `true` below to allow duplicate names and sources. While source maps\n  // are intended to be compressed and deduplicated, the TypeScript compiler\n  // sometimes generates source maps with duplicates in them. See Github issue\n  // #72 and bugzil.la/889492.\n  this._names = ArraySet.fromArray(names.map(String), true);\n  this._sources = ArraySet.fromArray(sources, true);\n\n  this.sourceRoot = sourceRoot;\n  this.sourcesContent = sourcesContent;\n  this._mappings = mappings;\n  this.file = file;\n}\n\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @returns BasicSourceMapConsumer\n */\nBasicSourceMapConsumer.fromSourceMap =\n  function SourceMapConsumer_fromSourceMap(aSourceMap) {\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n    smc.sourceRoot = aSourceMap._sourceRoot;\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n                                                            smc.sourceRoot);\n    smc.file = aSourceMap._file;\n\n    // Because we are modifying the entries (by converting string sources and\n    // names to indices into the sources and names ArraySets), we have to make\n    // a copy of the entry or else bad things happen. Shared mutable state\n    // strikes again! See github issue #191.\n\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\n    var destGeneratedMappings = smc.__generatedMappings = [];\n    var destOriginalMappings = smc.__originalMappings = [];\n\n    for (var i = 0, length = generatedMappings.length; i < length; i++) {\n      var srcMapping = generatedMappings[i];\n      var destMapping = new Mapping;\n      destMapping.generatedLine = srcMapping.generatedLine;\n      destMapping.generatedColumn = srcMapping.generatedColumn;\n\n      if (srcMapping.source) {\n        destMapping.source = sources.indexOf(srcMapping.source);\n        destMapping.originalLine = srcMapping.originalLine;\n        destMapping.originalColumn = srcMapping.originalColumn;\n\n        if (srcMapping.name) {\n          destMapping.name = names.indexOf(srcMapping.name);\n        }\n\n        destOriginalMappings.push(destMapping);\n      }\n\n      destGeneratedMappings.push(destMapping);\n    }\n\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\n    return smc;\n  };\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nBasicSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    return this._sources.toArray().map(function (s) {\n      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;\n    }, this);\n  }\n});\n\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nBasicSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    var generatedLine = 1;\n    var previousGeneratedColumn = 0;\n    var previousOriginalLine = 0;\n    var previousOriginalColumn = 0;\n    var previousSource = 0;\n    var previousName = 0;\n    var length = aStr.length;\n    var index = 0;\n    var cachedSegments = {};\n    var temp = {};\n    var originalMappings = [];\n    var generatedMappings = [];\n    var mapping, str, segment, end, value;\n\n    while (index < length) {\n      if (aStr.charAt(index) === ';') {\n        generatedLine++;\n        index++;\n        previousGeneratedColumn = 0;\n      }\n      else if (aStr.charAt(index) === ',') {\n        index++;\n      }\n      else {\n        mapping = new Mapping();\n        mapping.generatedLine = generatedLine;\n\n        // Because each offset is encoded relative to the previous one,\n        // many segments often have the same encoding. We can exploit this\n        // fact by caching the parsed variable length fields of each segment,\n        // allowing us to avoid a second parse if we encounter the same\n        // segment again.\n        for (end = index; end < length; end++) {\n          if (this._charIsMappingSeparator(aStr, end)) {\n            break;\n          }\n        }\n        str = aStr.slice(index, end);\n\n        segment = cachedSegments[str];\n        if (segment) {\n          index += str.length;\n        } else {\n          segment = [];\n          while (index < end) {\n            base64VLQ.decode(aStr, index, temp);\n            value = temp.value;\n            index = temp.rest;\n            segment.push(value);\n          }\n\n          if (segment.length === 2) {\n            throw new Error('Found a source, but no line and column');\n          }\n\n          if (segment.length === 3) {\n            throw new Error('Found a source and line, but no column');\n          }\n\n          cachedSegments[str] = segment;\n        }\n\n        // Generated column.\n        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n        previousGeneratedColumn = mapping.generatedColumn;\n\n        if (segment.length > 1) {\n          // Original source.\n          mapping.source = previousSource + segment[1];\n          previousSource += segment[1];\n\n          // Original line.\n          mapping.originalLine = previousOriginalLine + segment[2];\n          previousOriginalLine = mapping.originalLine;\n          // Lines are stored 0-based\n          mapping.originalLine += 1;\n\n          // Original column.\n          mapping.originalColumn = previousOriginalColumn + segment[3];\n          previousOriginalColumn = mapping.originalColumn;\n\n          if (segment.length > 4) {\n            // Original name.\n            mapping.name = previousName + segment[4];\n            previousName += segment[4];\n          }\n        }\n\n        generatedMappings.push(mapping);\n        if (typeof mapping.originalLine === 'number') {\n          originalMappings.push(mapping);\n        }\n      }\n    }\n\n    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n    this.__generatedMappings = generatedMappings;\n\n    quickSort(originalMappings, util.compareByOriginalPositions);\n    this.__originalMappings = originalMappings;\n  };\n\n/**\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\n * we are searching for in the given \"haystack\" of mappings.\n */\nBasicSourceMapConsumer.prototype._findMapping =\n  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n                                         aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError('Line must be greater than or equal to 1, got '\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError('Column must be greater than or equal to 0, got '\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  };\n\n/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */\nBasicSourceMapConsumer.prototype.computeColumnSpans =\n  function SourceMapConsumer_computeColumnSpans() {\n    for (var index = 0; index < this._generatedMappings.length; ++index) {\n      var mapping = this._generatedMappings[index];\n\n      // Mappings do not contain a field for the last generated columnt. We\n      // can come up with an optimistic estimate, however, by assuming that\n      // mappings are contiguous (i.e. given two consecutive mappings, the\n      // first mapping ends where the second one starts).\n      if (index + 1 < this._generatedMappings.length) {\n        var nextMapping = this._generatedMappings[index + 1];\n\n        if (mapping.generatedLine === nextMapping.generatedLine) {\n          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n          continue;\n        }\n      }\n\n      // The last mapping for each line spans the entire line.\n      mapping.lastGeneratedColumn = Infinity;\n    }\n  };\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.\n *   - column: The column number in the generated source.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.\n *   - column: The column number in the original source, or null.\n *   - name: The original identifier, or null.\n */\nBasicSourceMapConsumer.prototype.originalPositionFor =\n  function SourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._generatedMappings,\n      \"generatedLine\",\n      \"generatedColumn\",\n      util.compareByGeneratedPositionsDeflated,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._generatedMappings[index];\n\n      if (mapping.generatedLine === needle.generatedLine) {\n        var source = util.getArg(mapping, 'source', null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          if (this.sourceRoot != null) {\n            source = util.join(this.sourceRoot, source);\n          }\n        }\n        var name = util.getArg(mapping, 'name', null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n        return {\n          source: source,\n          line: util.getArg(mapping, 'originalLine', null),\n          column: util.getArg(mapping, 'originalColumn', null),\n          name: name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function BasicSourceMapConsumer_hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function (sc) { return sc == null; });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nBasicSourceMapConsumer.prototype.sourceContentFor =\n  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    if (this.sourceRoot != null) {\n      aSource = util.relative(this.sourceRoot, aSource);\n    }\n\n    if (this._sources.has(aSource)) {\n      return this.sourcesContent[this._sources.indexOf(aSource)];\n    }\n\n    var url;\n    if (this.sourceRoot != null\n        && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");\n      if (url.scheme == \"file\"\n          && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n      }\n\n      if ((!url.path || url.path == \"/\")\n          && this._sources.has(\"/\" + aSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + aSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: The column number in the original source.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nBasicSourceMapConsumer.prototype.generatedPositionFor =\n  function SourceMapConsumer_generatedPositionFor(aArgs) {\n    var source = util.getArg(aArgs, 'source');\n    if (this.sourceRoot != null) {\n      source = util.relative(this.sourceRoot, source);\n    }\n    if (!this._sources.has(source)) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n    source = this._sources.indexOf(source);\n\n    var needle = {\n      source: source,\n      originalLine: util.getArg(aArgs, 'line'),\n      originalColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._originalMappings,\n      \"originalLine\",\n      \"originalColumn\",\n      util.compareByOriginalPositions,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (mapping.source === needle.source) {\n        return {\n          line: util.getArg(mapping, 'generatedLine', null),\n          column: util.getArg(mapping, 'generatedColumn', null),\n          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  };\n\n__webpack_unused_export__ = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The only parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nfunction IndexedSourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sections = util.getArg(sourceMap, 'sections');\n\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n\n  var lastOffset = {\n    line: -1,\n    column: 0\n  };\n  this._sections = sections.map(function (s) {\n    if (s.url) {\n      // The url field will require support for asynchronicity.\n      // See https://github.com/mozilla/source-map/issues/16\n      throw new Error('Support for url field in sections not implemented.');\n    }\n    var offset = util.getArg(s, 'offset');\n    var offsetLine = util.getArg(offset, 'line');\n    var offsetColumn = util.getArg(offset, 'column');\n\n    if (offsetLine < lastOffset.line ||\n        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n      throw new Error('Section offsets must be ordered and non-overlapping.');\n    }\n    lastOffset = offset;\n\n    return {\n      generatedOffset: {\n        // The offset fields are 0-based, but we use 1-based indices when\n        // encoding/decoding from VLQ.\n        generatedLine: offsetLine + 1,\n        generatedColumn: offsetColumn + 1\n      },\n      consumer: new SourceMapConsumer(util.getArg(s, 'map'))\n    }\n  });\n}\n\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nIndexedSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    var sources = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n});\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.\n *   - column: The column number in the generated source.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.\n *   - column: The column number in the original source, or null.\n *   - name: The original identifier, or null.\n */\nIndexedSourceMapConsumer.prototype.originalPositionFor =\n  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    var sectionIndex = binarySearch.search(needle, this._sections,\n      function(needle, section) {\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (needle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    var section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n    return this._sections.every(function (s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nIndexedSourceMapConsumer.prototype.sourceContentFor =\n  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      var content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: The column number in the original source.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nIndexedSourceMapConsumer.prototype.generatedPositionFor =\n  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {\n        continue;\n      }\n      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        var ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nIndexedSourceMapConsumer.prototype._parseMappings =\n  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    this.__generatedMappings = [];\n    this.__originalMappings = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n      var sectionMappings = section.consumer._generatedMappings;\n      for (var j = 0; j < sectionMappings.length; j++) {\n        var mapping = sectionMappings[j];\n\n        var source = section.consumer._sources.at(mapping.source);\n        if (section.consumer.sourceRoot !== null) {\n          source = util.join(section.consumer.sourceRoot, source);\n        }\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        var name = section.consumer._names.at(mapping.name);\n        this._names.add(name);\n        name = this._names.indexOf(name);\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        var adjustedMapping = {\n          source: source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: name\n        };\n\n        this.__generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === 'number') {\n          this.__originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n  };\n\n__webpack_unused_export__ = IndexedSourceMapConsumer;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/generator/node_modules/source-map/lib/source-map-consumer.js?")},78888:(__unused_webpack_module,exports,__webpack_require__)=>{eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar base64VLQ = __webpack_require__(49074);\nvar util = __webpack_require__(88849);\nvar ArraySet = __webpack_require__(74188)/* .ArraySet */ .I;\nvar MappingList = __webpack_require__(62578)/* .MappingList */ .H;\n\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */\nfunction SourceMapGenerator(aArgs) {\n  if (!aArgs) {\n    aArgs = {};\n  }\n  this._file = util.getArg(aArgs, 'file', null);\n  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n  this._mappings = new MappingList();\n  this._sourcesContents = null;\n}\n\nSourceMapGenerator.prototype._version = 3;\n\n/**\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\n *\n * @param aSourceMapConsumer The SourceMap.\n */\nSourceMapGenerator.fromSourceMap =\n  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n    var sourceRoot = aSourceMapConsumer.sourceRoot;\n    var generator = new SourceMapGenerator({\n      file: aSourceMapConsumer.file,\n      sourceRoot: sourceRoot\n    });\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      var newMapping = {\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn\n        }\n      };\n\n      if (mapping.source != null) {\n        newMapping.source = mapping.source;\n        if (sourceRoot != null) {\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\n        }\n\n        newMapping.original = {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        };\n\n        if (mapping.name != null) {\n          newMapping.name = mapping.name;\n        }\n      }\n\n      generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        generator.setSourceContent(sourceFile, content);\n      }\n    });\n    return generator;\n  };\n\n/**\n * Add a single mapping from original source line and column to the generated\n * source's line and column for this source map being created. The mapping\n * object should have the following properties:\n *\n *   - generated: An object with the generated line and column positions.\n *   - original: An object with the original line and column positions.\n *   - source: The original source file (relative to the sourceRoot).\n *   - name: An optional original token name for this mapping.\n */\nSourceMapGenerator.prototype.addMapping =\n  function SourceMapGenerator_addMapping(aArgs) {\n    var generated = util.getArg(aArgs, 'generated');\n    var original = util.getArg(aArgs, 'original', null);\n    var source = util.getArg(aArgs, 'source', null);\n    var name = util.getArg(aArgs, 'name', null);\n\n    if (!this._skipValidation) {\n      this._validateMapping(generated, original, source, name);\n    }\n\n    if (source != null) {\n      source = String(source);\n      if (!this._sources.has(source)) {\n        this._sources.add(source);\n      }\n    }\n\n    if (name != null) {\n      name = String(name);\n      if (!this._names.has(name)) {\n        this._names.add(name);\n      }\n    }\n\n    this._mappings.add({\n      generatedLine: generated.line,\n      generatedColumn: generated.column,\n      originalLine: original != null && original.line,\n      originalColumn: original != null && original.column,\n      source: source,\n      name: name\n    });\n  };\n\n/**\n * Set the source content for a source file.\n */\nSourceMapGenerator.prototype.setSourceContent =\n  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n    var source = aSourceFile;\n    if (this._sourceRoot != null) {\n      source = util.relative(this._sourceRoot, source);\n    }\n\n    if (aSourceContent != null) {\n      // Add the source content to the _sourcesContents map.\n      // Create a new _sourcesContents map if the property is null.\n      if (!this._sourcesContents) {\n        this._sourcesContents = Object.create(null);\n      }\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n      // Remove the source file from the _sourcesContents map.\n      // If the _sourcesContents map is empty, set the property to null.\n      delete this._sourcesContents[util.toSetString(source)];\n      if (Object.keys(this._sourcesContents).length === 0) {\n        this._sourcesContents = null;\n      }\n    }\n  };\n\n/**\n * Applies the mappings of a sub-source-map for a specific source file to the\n * source map being generated. Each mapping to the supplied source file is\n * rewritten using the supplied source map. Note: The resolution for the\n * resulting mappings is the minimium of this map and the supplied map.\n *\n * @param aSourceMapConsumer The source map to be applied.\n * @param aSourceFile Optional. The filename of the source file.\n *        If omitted, SourceMapConsumer's file property will be used.\n * @param aSourceMapPath Optional. The dirname of the path to the source map\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\n *        This parameter is needed when the two source maps aren't in the same\n *        directory, and the source map to be applied contains relative source\n *        paths. If so, those relative source paths need to be rewritten\n *        relative to the SourceMapGenerator.\n */\nSourceMapGenerator.prototype.applySourceMap =\n  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    var sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n      if (aSourceMapConsumer.file == null) {\n        throw new Error(\n          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n          'or the source map\\'s \"file\" property. Both were omitted.'\n        );\n      }\n      sourceFile = aSourceMapConsumer.file;\n    }\n    var sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n      sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    var newSources = new ArraySet();\n    var newNames = new ArraySet();\n\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function (mapping) {\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\n        // Check if it can be mapped by the source map, then update the mapping.\n        var original = aSourceMapConsumer.originalPositionFor({\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        });\n        if (original.source != null) {\n          // Copy mapping\n          mapping.source = original.source;\n          if (aSourceMapPath != null) {\n            mapping.source = util.join(aSourceMapPath, mapping.source)\n          }\n          if (sourceRoot != null) {\n            mapping.source = util.relative(sourceRoot, mapping.source);\n          }\n          mapping.originalLine = original.line;\n          mapping.originalColumn = original.column;\n          if (original.name != null) {\n            mapping.name = original.name;\n          }\n        }\n      }\n\n      var source = mapping.source;\n      if (source != null && !newSources.has(source)) {\n        newSources.add(source);\n      }\n\n      var name = mapping.name;\n      if (name != null && !newNames.has(name)) {\n        newNames.add(name);\n      }\n\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aSourceMapPath != null) {\n          sourceFile = util.join(aSourceMapPath, sourceFile);\n        }\n        if (sourceRoot != null) {\n          sourceFile = util.relative(sourceRoot, sourceFile);\n        }\n        this.setSourceContent(sourceFile, content);\n      }\n    }, this);\n  };\n\n/**\n * A mapping can have one of the three levels of data:\n *\n *   1. Just the generated position.\n *   2. The Generated position, original position, and original source.\n *   3. Generated and original position, original source, as well as a name\n *      token.\n *\n * To maintain consistency, we validate that any new mapping being added falls\n * in to one of these categories.\n */\nSourceMapGenerator.prototype._validateMapping =\n  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n                                              aName) {\n    // When aOriginal is truthy but has empty values for .line and .column,\n    // it is most likely a programmer error. In this case we throw a very\n    // specific error message to try to guide them the right way.\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\n    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {\n        throw new Error(\n            'original.line and original.column are not numbers -- you probably meant to omit ' +\n            'the original mapping entirely and only map the generated position. If so, pass ' +\n            'null for the original mapping instead of an object with empty or null values.'\n        );\n    }\n\n    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n        && aGenerated.line > 0 && aGenerated.column >= 0\n        && !aOriginal && !aSource && !aName) {\n      // Case 1.\n      return;\n    }\n    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n             && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n             && aGenerated.line > 0 && aGenerated.column >= 0\n             && aOriginal.line > 0 && aOriginal.column >= 0\n             && aSource) {\n      // Cases 2 and 3.\n      return;\n    }\n    else {\n      throw new Error('Invalid mapping: ' + JSON.stringify({\n        generated: aGenerated,\n        source: aSource,\n        original: aOriginal,\n        name: aName\n      }));\n    }\n  };\n\n/**\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\n * specified by the source map format.\n */\nSourceMapGenerator.prototype._serializeMappings =\n  function SourceMapGenerator_serializeMappings() {\n    var previousGeneratedColumn = 0;\n    var previousGeneratedLine = 1;\n    var previousOriginalColumn = 0;\n    var previousOriginalLine = 0;\n    var previousName = 0;\n    var previousSource = 0;\n    var result = '';\n    var next;\n    var mapping;\n    var nameIdx;\n    var sourceIdx;\n\n    var mappings = this._mappings.toArray();\n    for (var i = 0, len = mappings.length; i < len; i++) {\n      mapping = mappings[i];\n      next = ''\n\n      if (mapping.generatedLine !== previousGeneratedLine) {\n        previousGeneratedColumn = 0;\n        while (mapping.generatedLine !== previousGeneratedLine) {\n          next += ';';\n          previousGeneratedLine++;\n        }\n      }\n      else {\n        if (i > 0) {\n          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n            continue;\n          }\n          next += ',';\n        }\n      }\n\n      next += base64VLQ.encode(mapping.generatedColumn\n                                 - previousGeneratedColumn);\n      previousGeneratedColumn = mapping.generatedColumn;\n\n      if (mapping.source != null) {\n        sourceIdx = this._sources.indexOf(mapping.source);\n        next += base64VLQ.encode(sourceIdx - previousSource);\n        previousSource = sourceIdx;\n\n        // lines are stored 0-based in SourceMap spec version 3\n        next += base64VLQ.encode(mapping.originalLine - 1\n                                   - previousOriginalLine);\n        previousOriginalLine = mapping.originalLine - 1;\n\n        next += base64VLQ.encode(mapping.originalColumn\n                                   - previousOriginalColumn);\n        previousOriginalColumn = mapping.originalColumn;\n\n        if (mapping.name != null) {\n          nameIdx = this._names.indexOf(mapping.name);\n          next += base64VLQ.encode(nameIdx - previousName);\n          previousName = nameIdx;\n        }\n      }\n\n      result += next;\n    }\n\n    return result;\n  };\n\nSourceMapGenerator.prototype._generateSourcesContent =\n  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function (source) {\n      if (!this._sourcesContents) {\n        return null;\n      }\n      if (aSourceRoot != null) {\n        source = util.relative(aSourceRoot, source);\n      }\n      var key = util.toSetString(source);\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n        ? this._sourcesContents[key]\n        : null;\n    }, this);\n  };\n\n/**\n * Externalize the source map.\n */\nSourceMapGenerator.prototype.toJSON =\n  function SourceMapGenerator_toJSON() {\n    var map = {\n      version: this._version,\n      sources: this._sources.toArray(),\n      names: this._names.toArray(),\n      mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n      map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n      map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n\n    return map;\n  };\n\n/**\n * Render the source map being generated to a string.\n */\nSourceMapGenerator.prototype.toString =\n  function SourceMapGenerator_toString() {\n    return JSON.stringify(this.toJSON());\n  };\n\nexports.SourceMapGenerator = SourceMapGenerator;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/generator/node_modules/source-map/lib/source-map-generator.js?")},71903:(__unused_webpack_module,exports,__webpack_require__)=>{eval('/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar SourceMapGenerator = __webpack_require__(78888).SourceMapGenerator;\nvar util = __webpack_require__(88849);\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = "$$$isSourceNode$$$";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source\'s filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */\nSourceNode.fromStringWithSourceMap =\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are accessed by calling `shiftNextLine`.\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    var remainingLinesIndex = 0;\n    var shiftNextLine = function() {\n      var lineContents = getNextLine();\n      // The last line of a file might not have a newline.\n      var newLine = getNextLine() || "";\n      return lineContents + newLine;\n\n      function getNextLine() {\n        return remainingLinesIndex < remainingLines.length ?\n            remainingLines[remainingLinesIndex++] : undefined;\n      }\n    };\n\n    // We need to remember the position of "remainingLines"\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    var lastMapping = null;\n\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      if (lastMapping !== null) {\n        // We add the code from "lastMapping" to "mapping":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with "lastMapping"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between "lastGeneratedColumn" and\n          // "mapping.generatedColumn" with "lastMapping"\n          var nextLine = remainingLines[remainingLinesIndex];\n          var code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        var nextLine = remainingLines[remainingLinesIndex];\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLinesIndex < remainingLines.length) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with "lastMapping"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.splice(remainingLinesIndex).join(""));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        var source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  };\n\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === "string") {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  }\n  else {\n    throw new TypeError(\n      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length-1; i >= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === "string") {\n    this.children.unshift(aChunk);\n  }\n  else {\n    throw new TypeError(\n      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source\'s line/column location.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    chunk = this.children[i];\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    }\n    else {\n      if (chunk !== \'\') {\n        aFn(chunk, { source: this.source,\n                     line: this.line,\n                     column: this.column,\n                     name: this.name });\n      }\n    }\n  }\n};\n\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n  if (len > 0) {\n    newChildren = [];\n    for (i = 0; i < len-1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n  return this;\n};\n\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  }\n  else if (typeof lastChild === \'string\') {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  }\n  else {\n    this.children.push(\'\'.replace(aPattern, aReplacement));\n  }\n  return this;\n};\n\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */\nSourceNode.prototype.setSourceContent =\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  };\n\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walkSourceContents =\n  function SourceNode_walkSourceContents(aFn) {\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    var sources = Object.keys(this.sourceContents);\n    for (var i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  };\n\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = "";\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: "",\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n    if (original.source !== null\n        && original.line !== null\n        && original.column !== null) {\n      if(lastOriginalSource !== original.source\n         || lastOriginalLine !== original.line\n         || lastOriginalColumn !== original.column\n         || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0;\n        // Mappings end at eol\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n\n  return { code: generated.code, map: map };\n};\n\nexports.SourceNode = SourceNode;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/generator/node_modules/source-map/lib/source-node.js?')},88849:(__unused_webpack_module,exports)=>{eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error('\"' + aName + '\" is a required argument.');\n  }\n}\nexports.getArg = getArg;\n\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  var url = '';\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + ':';\n  }\n  url += '//';\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + '@';\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nfunction normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n\n  var parts = path.split(/\\/+/);\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n    part = parts[i];\n    if (part === '.') {\n      parts.splice(i, 1);\n    } else if (part === '..') {\n      up++;\n    } else if (up > 0) {\n      if (part === '') {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join('/');\n\n  if (path === '') {\n    path = isAbsolute ? '/' : '.';\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n}\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || '/';\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  var joined = aPath.charAt(0) === '/'\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, '');\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + '/') !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nvar supportsNullProto = (function () {\n  var obj = Object.create(null);\n  return !('__proto__' in obj);\n}());\n\nfunction identity (s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return '$' + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  var length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = mappingA.source - mappingB.source;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return mappingA.name - mappingB.name;\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = mappingA.source - mappingB.source;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return mappingA.name - mappingB.name;\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/generator/node_modules/source-map/lib/util.js?")},45515:(__unused_webpack_module,exports,__webpack_require__)=>{eval("/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nexports.SourceMapGenerator = __webpack_require__(78888).SourceMapGenerator;\nexports.SourceMapConsumer = __webpack_require__(27944).SourceMapConsumer;\nexports.SourceNode = __webpack_require__(71903).SourceNode;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/generator/node_modules/source-map/source-map.js?")},33306:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.isIdentifierStart = isIdentifierStart;\nexports.isIdentifierChar = isIdentifierChar;\nexports.isIdentifierName = isIdentifierName;\nlet nonASCIIidentifierStartChars = "\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08c7\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\u9ffc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7bf\\ua7c2-\\ua7ca\\ua7f5-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc";\nlet nonASCIIidentifierChars = "\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf\\u1ac0\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f";\nconst nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");\nconst nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\nconst astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];\nconst astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\n\nfunction isInAstralSet(code, set) {\n  let pos = 0x10000;\n\n  for (let i = 0, length = set.length; i < length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n\n  return false;\n}\n\nfunction isIdentifierStart(code) {\n  if (code < 65) return code === 36;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  }\n\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\n\nfunction isIdentifierChar(code) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\n\nfunction isIdentifierName(name) {\n  let isFirst = true;\n\n  for (let _i = 0, _Array$from = Array.from(name); _i < _Array$from.length; _i++) {\n    const char = _Array$from[_i];\n    const cp = char.codePointAt(0);\n\n    if (isFirst) {\n      if (!isIdentifierStart(cp)) {\n        return false;\n      }\n\n      isFirst = false;\n    } else if (!isIdentifierChar(cp)) {\n      return false;\n    }\n  }\n\n  return !isFirst;\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/helper-validator-identifier/lib/identifier.js?')},40720:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nObject.defineProperty(exports, "isIdentifierName", ({\n  enumerable: true,\n  get: function () {\n    return _identifier.isIdentifierName;\n  }\n}));\nObject.defineProperty(exports, "isIdentifierChar", ({\n  enumerable: true,\n  get: function () {\n    return _identifier.isIdentifierChar;\n  }\n}));\nObject.defineProperty(exports, "isIdentifierStart", ({\n  enumerable: true,\n  get: function () {\n    return _identifier.isIdentifierStart;\n  }\n}));\nObject.defineProperty(exports, "isReservedWord", ({\n  enumerable: true,\n  get: function () {\n    return _keyword.isReservedWord;\n  }\n}));\nObject.defineProperty(exports, "isStrictBindOnlyReservedWord", ({\n  enumerable: true,\n  get: function () {\n    return _keyword.isStrictBindOnlyReservedWord;\n  }\n}));\nObject.defineProperty(exports, "isStrictBindReservedWord", ({\n  enumerable: true,\n  get: function () {\n    return _keyword.isStrictBindReservedWord;\n  }\n}));\nObject.defineProperty(exports, "isStrictReservedWord", ({\n  enumerable: true,\n  get: function () {\n    return _keyword.isStrictReservedWord;\n  }\n}));\nObject.defineProperty(exports, "isKeyword", ({\n  enumerable: true,\n  get: function () {\n    return _keyword.isKeyword;\n  }\n}));\n\nvar _identifier = __webpack_require__(33306);\n\nvar _keyword = __webpack_require__(12887);\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/helper-validator-identifier/lib/index.js?')},12887:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.isReservedWord = isReservedWord;\nexports.isStrictReservedWord = isStrictReservedWord;\nexports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;\nexports.isStrictBindReservedWord = isStrictBindReservedWord;\nexports.isKeyword = isKeyword;\nconst reservedWords = {\n  keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],\n  strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],\n  strictBind: ["eval", "arguments"]\n};\nconst keywords = new Set(reservedWords.keyword);\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\n\nfunction isReservedWord(word, inModule) {\n  return inModule && word === "await" || word === "enum";\n}\n\nfunction isStrictReservedWord(word, inModule) {\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\n\nfunction isStrictBindOnlyReservedWord(word) {\n  return reservedWordsStrictBindSet.has(word);\n}\n\nfunction isStrictBindReservedWord(word, inModule) {\n  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);\n}\n\nfunction isKeyword(word) {\n  return keywords.has(word);\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/helper-validator-identifier/lib/keyword.js?')},60245:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = assertNode;\n\nvar _isNode = _interopRequireDefault(__webpack_require__(8523));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction assertNode(node) {\n  if (!(0, _isNode.default)(node)) {\n    var _node$type;\n\n    const type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);\n    throw new TypeError(`Not a valid node of type "${type}"`);\n  }\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/asserts/assertNode.js?')},27133:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.assertArrayExpression = assertArrayExpression;\nexports.assertAssignmentExpression = assertAssignmentExpression;\nexports.assertBinaryExpression = assertBinaryExpression;\nexports.assertInterpreterDirective = assertInterpreterDirective;\nexports.assertDirective = assertDirective;\nexports.assertDirectiveLiteral = assertDirectiveLiteral;\nexports.assertBlockStatement = assertBlockStatement;\nexports.assertBreakStatement = assertBreakStatement;\nexports.assertCallExpression = assertCallExpression;\nexports.assertCatchClause = assertCatchClause;\nexports.assertConditionalExpression = assertConditionalExpression;\nexports.assertContinueStatement = assertContinueStatement;\nexports.assertDebuggerStatement = assertDebuggerStatement;\nexports.assertDoWhileStatement = assertDoWhileStatement;\nexports.assertEmptyStatement = assertEmptyStatement;\nexports.assertExpressionStatement = assertExpressionStatement;\nexports.assertFile = assertFile;\nexports.assertForInStatement = assertForInStatement;\nexports.assertForStatement = assertForStatement;\nexports.assertFunctionDeclaration = assertFunctionDeclaration;\nexports.assertFunctionExpression = assertFunctionExpression;\nexports.assertIdentifier = assertIdentifier;\nexports.assertIfStatement = assertIfStatement;\nexports.assertLabeledStatement = assertLabeledStatement;\nexports.assertStringLiteral = assertStringLiteral;\nexports.assertNumericLiteral = assertNumericLiteral;\nexports.assertNullLiteral = assertNullLiteral;\nexports.assertBooleanLiteral = assertBooleanLiteral;\nexports.assertRegExpLiteral = assertRegExpLiteral;\nexports.assertLogicalExpression = assertLogicalExpression;\nexports.assertMemberExpression = assertMemberExpression;\nexports.assertNewExpression = assertNewExpression;\nexports.assertProgram = assertProgram;\nexports.assertObjectExpression = assertObjectExpression;\nexports.assertObjectMethod = assertObjectMethod;\nexports.assertObjectProperty = assertObjectProperty;\nexports.assertRestElement = assertRestElement;\nexports.assertReturnStatement = assertReturnStatement;\nexports.assertSequenceExpression = assertSequenceExpression;\nexports.assertParenthesizedExpression = assertParenthesizedExpression;\nexports.assertSwitchCase = assertSwitchCase;\nexports.assertSwitchStatement = assertSwitchStatement;\nexports.assertThisExpression = assertThisExpression;\nexports.assertThrowStatement = assertThrowStatement;\nexports.assertTryStatement = assertTryStatement;\nexports.assertUnaryExpression = assertUnaryExpression;\nexports.assertUpdateExpression = assertUpdateExpression;\nexports.assertVariableDeclaration = assertVariableDeclaration;\nexports.assertVariableDeclarator = assertVariableDeclarator;\nexports.assertWhileStatement = assertWhileStatement;\nexports.assertWithStatement = assertWithStatement;\nexports.assertAssignmentPattern = assertAssignmentPattern;\nexports.assertArrayPattern = assertArrayPattern;\nexports.assertArrowFunctionExpression = assertArrowFunctionExpression;\nexports.assertClassBody = assertClassBody;\nexports.assertClassExpression = assertClassExpression;\nexports.assertClassDeclaration = assertClassDeclaration;\nexports.assertExportAllDeclaration = assertExportAllDeclaration;\nexports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;\nexports.assertExportNamedDeclaration = assertExportNamedDeclaration;\nexports.assertExportSpecifier = assertExportSpecifier;\nexports.assertForOfStatement = assertForOfStatement;\nexports.assertImportDeclaration = assertImportDeclaration;\nexports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;\nexports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;\nexports.assertImportSpecifier = assertImportSpecifier;\nexports.assertMetaProperty = assertMetaProperty;\nexports.assertClassMethod = assertClassMethod;\nexports.assertObjectPattern = assertObjectPattern;\nexports.assertSpreadElement = assertSpreadElement;\nexports.assertSuper = assertSuper;\nexports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;\nexports.assertTemplateElement = assertTemplateElement;\nexports.assertTemplateLiteral = assertTemplateLiteral;\nexports.assertYieldExpression = assertYieldExpression;\nexports.assertAwaitExpression = assertAwaitExpression;\nexports.assertImport = assertImport;\nexports.assertBigIntLiteral = assertBigIntLiteral;\nexports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;\nexports.assertOptionalMemberExpression = assertOptionalMemberExpression;\nexports.assertOptionalCallExpression = assertOptionalCallExpression;\nexports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;\nexports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;\nexports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;\nexports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;\nexports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;\nexports.assertClassImplements = assertClassImplements;\nexports.assertDeclareClass = assertDeclareClass;\nexports.assertDeclareFunction = assertDeclareFunction;\nexports.assertDeclareInterface = assertDeclareInterface;\nexports.assertDeclareModule = assertDeclareModule;\nexports.assertDeclareModuleExports = assertDeclareModuleExports;\nexports.assertDeclareTypeAlias = assertDeclareTypeAlias;\nexports.assertDeclareOpaqueType = assertDeclareOpaqueType;\nexports.assertDeclareVariable = assertDeclareVariable;\nexports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;\nexports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;\nexports.assertDeclaredPredicate = assertDeclaredPredicate;\nexports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;\nexports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;\nexports.assertFunctionTypeParam = assertFunctionTypeParam;\nexports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;\nexports.assertInferredPredicate = assertInferredPredicate;\nexports.assertInterfaceExtends = assertInterfaceExtends;\nexports.assertInterfaceDeclaration = assertInterfaceDeclaration;\nexports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;\nexports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;\nexports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;\nexports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;\nexports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;\nexports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;\nexports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;\nexports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;\nexports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;\nexports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;\nexports.assertObjectTypeIndexer = assertObjectTypeIndexer;\nexports.assertObjectTypeProperty = assertObjectTypeProperty;\nexports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;\nexports.assertOpaqueType = assertOpaqueType;\nexports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;\nexports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;\nexports.assertStringTypeAnnotation = assertStringTypeAnnotation;\nexports.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;\nexports.assertThisTypeAnnotation = assertThisTypeAnnotation;\nexports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;\nexports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;\nexports.assertTypeAlias = assertTypeAlias;\nexports.assertTypeAnnotation = assertTypeAnnotation;\nexports.assertTypeCastExpression = assertTypeCastExpression;\nexports.assertTypeParameter = assertTypeParameter;\nexports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;\nexports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;\nexports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;\nexports.assertVariance = assertVariance;\nexports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;\nexports.assertEnumDeclaration = assertEnumDeclaration;\nexports.assertEnumBooleanBody = assertEnumBooleanBody;\nexports.assertEnumNumberBody = assertEnumNumberBody;\nexports.assertEnumStringBody = assertEnumStringBody;\nexports.assertEnumSymbolBody = assertEnumSymbolBody;\nexports.assertEnumBooleanMember = assertEnumBooleanMember;\nexports.assertEnumNumberMember = assertEnumNumberMember;\nexports.assertEnumStringMember = assertEnumStringMember;\nexports.assertEnumDefaultedMember = assertEnumDefaultedMember;\nexports.assertJSXAttribute = assertJSXAttribute;\nexports.assertJSXClosingElement = assertJSXClosingElement;\nexports.assertJSXElement = assertJSXElement;\nexports.assertJSXEmptyExpression = assertJSXEmptyExpression;\nexports.assertJSXExpressionContainer = assertJSXExpressionContainer;\nexports.assertJSXSpreadChild = assertJSXSpreadChild;\nexports.assertJSXIdentifier = assertJSXIdentifier;\nexports.assertJSXMemberExpression = assertJSXMemberExpression;\nexports.assertJSXNamespacedName = assertJSXNamespacedName;\nexports.assertJSXOpeningElement = assertJSXOpeningElement;\nexports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;\nexports.assertJSXText = assertJSXText;\nexports.assertJSXFragment = assertJSXFragment;\nexports.assertJSXOpeningFragment = assertJSXOpeningFragment;\nexports.assertJSXClosingFragment = assertJSXClosingFragment;\nexports.assertNoop = assertNoop;\nexports.assertPlaceholder = assertPlaceholder;\nexports.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;\nexports.assertArgumentPlaceholder = assertArgumentPlaceholder;\nexports.assertBindExpression = assertBindExpression;\nexports.assertClassProperty = assertClassProperty;\nexports.assertPipelineTopicExpression = assertPipelineTopicExpression;\nexports.assertPipelineBareFunction = assertPipelineBareFunction;\nexports.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;\nexports.assertClassPrivateProperty = assertClassPrivateProperty;\nexports.assertClassPrivateMethod = assertClassPrivateMethod;\nexports.assertImportAttribute = assertImportAttribute;\nexports.assertDecorator = assertDecorator;\nexports.assertDoExpression = assertDoExpression;\nexports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;\nexports.assertPrivateName = assertPrivateName;\nexports.assertRecordExpression = assertRecordExpression;\nexports.assertTupleExpression = assertTupleExpression;\nexports.assertDecimalLiteral = assertDecimalLiteral;\nexports.assertStaticBlock = assertStaticBlock;\nexports.assertTSParameterProperty = assertTSParameterProperty;\nexports.assertTSDeclareFunction = assertTSDeclareFunction;\nexports.assertTSDeclareMethod = assertTSDeclareMethod;\nexports.assertTSQualifiedName = assertTSQualifiedName;\nexports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;\nexports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;\nexports.assertTSPropertySignature = assertTSPropertySignature;\nexports.assertTSMethodSignature = assertTSMethodSignature;\nexports.assertTSIndexSignature = assertTSIndexSignature;\nexports.assertTSAnyKeyword = assertTSAnyKeyword;\nexports.assertTSBooleanKeyword = assertTSBooleanKeyword;\nexports.assertTSBigIntKeyword = assertTSBigIntKeyword;\nexports.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;\nexports.assertTSNeverKeyword = assertTSNeverKeyword;\nexports.assertTSNullKeyword = assertTSNullKeyword;\nexports.assertTSNumberKeyword = assertTSNumberKeyword;\nexports.assertTSObjectKeyword = assertTSObjectKeyword;\nexports.assertTSStringKeyword = assertTSStringKeyword;\nexports.assertTSSymbolKeyword = assertTSSymbolKeyword;\nexports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;\nexports.assertTSUnknownKeyword = assertTSUnknownKeyword;\nexports.assertTSVoidKeyword = assertTSVoidKeyword;\nexports.assertTSThisType = assertTSThisType;\nexports.assertTSFunctionType = assertTSFunctionType;\nexports.assertTSConstructorType = assertTSConstructorType;\nexports.assertTSTypeReference = assertTSTypeReference;\nexports.assertTSTypePredicate = assertTSTypePredicate;\nexports.assertTSTypeQuery = assertTSTypeQuery;\nexports.assertTSTypeLiteral = assertTSTypeLiteral;\nexports.assertTSArrayType = assertTSArrayType;\nexports.assertTSTupleType = assertTSTupleType;\nexports.assertTSOptionalType = assertTSOptionalType;\nexports.assertTSRestType = assertTSRestType;\nexports.assertTSNamedTupleMember = assertTSNamedTupleMember;\nexports.assertTSUnionType = assertTSUnionType;\nexports.assertTSIntersectionType = assertTSIntersectionType;\nexports.assertTSConditionalType = assertTSConditionalType;\nexports.assertTSInferType = assertTSInferType;\nexports.assertTSParenthesizedType = assertTSParenthesizedType;\nexports.assertTSTypeOperator = assertTSTypeOperator;\nexports.assertTSIndexedAccessType = assertTSIndexedAccessType;\nexports.assertTSMappedType = assertTSMappedType;\nexports.assertTSLiteralType = assertTSLiteralType;\nexports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;\nexports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;\nexports.assertTSInterfaceBody = assertTSInterfaceBody;\nexports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;\nexports.assertTSAsExpression = assertTSAsExpression;\nexports.assertTSTypeAssertion = assertTSTypeAssertion;\nexports.assertTSEnumDeclaration = assertTSEnumDeclaration;\nexports.assertTSEnumMember = assertTSEnumMember;\nexports.assertTSModuleDeclaration = assertTSModuleDeclaration;\nexports.assertTSModuleBlock = assertTSModuleBlock;\nexports.assertTSImportType = assertTSImportType;\nexports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;\nexports.assertTSExternalModuleReference = assertTSExternalModuleReference;\nexports.assertTSNonNullExpression = assertTSNonNullExpression;\nexports.assertTSExportAssignment = assertTSExportAssignment;\nexports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;\nexports.assertTSTypeAnnotation = assertTSTypeAnnotation;\nexports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;\nexports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;\nexports.assertTSTypeParameter = assertTSTypeParameter;\nexports.assertExpression = assertExpression;\nexports.assertBinary = assertBinary;\nexports.assertScopable = assertScopable;\nexports.assertBlockParent = assertBlockParent;\nexports.assertBlock = assertBlock;\nexports.assertStatement = assertStatement;\nexports.assertTerminatorless = assertTerminatorless;\nexports.assertCompletionStatement = assertCompletionStatement;\nexports.assertConditional = assertConditional;\nexports.assertLoop = assertLoop;\nexports.assertWhile = assertWhile;\nexports.assertExpressionWrapper = assertExpressionWrapper;\nexports.assertFor = assertFor;\nexports.assertForXStatement = assertForXStatement;\nexports.assertFunction = assertFunction;\nexports.assertFunctionParent = assertFunctionParent;\nexports.assertPureish = assertPureish;\nexports.assertDeclaration = assertDeclaration;\nexports.assertPatternLike = assertPatternLike;\nexports.assertLVal = assertLVal;\nexports.assertTSEntityName = assertTSEntityName;\nexports.assertLiteral = assertLiteral;\nexports.assertImmutable = assertImmutable;\nexports.assertUserWhitespacable = assertUserWhitespacable;\nexports.assertMethod = assertMethod;\nexports.assertObjectMember = assertObjectMember;\nexports.assertProperty = assertProperty;\nexports.assertUnaryLike = assertUnaryLike;\nexports.assertPattern = assertPattern;\nexports.assertClass = assertClass;\nexports.assertModuleDeclaration = assertModuleDeclaration;\nexports.assertExportDeclaration = assertExportDeclaration;\nexports.assertModuleSpecifier = assertModuleSpecifier;\nexports.assertFlow = assertFlow;\nexports.assertFlowType = assertFlowType;\nexports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;\nexports.assertFlowDeclaration = assertFlowDeclaration;\nexports.assertFlowPredicate = assertFlowPredicate;\nexports.assertEnumBody = assertEnumBody;\nexports.assertEnumMember = assertEnumMember;\nexports.assertJSX = assertJSX;\nexports.assertPrivate = assertPrivate;\nexports.assertTSTypeElement = assertTSTypeElement;\nexports.assertTSType = assertTSType;\nexports.assertTSBaseType = assertTSBaseType;\nexports.assertNumberLiteral = assertNumberLiteral;\nexports.assertRegexLiteral = assertRegexLiteral;\nexports.assertRestProperty = assertRestProperty;\nexports.assertSpreadProperty = assertSpreadProperty;\n\nvar _is = _interopRequireDefault(__webpack_require__(67275));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction assert(type, node, opts) {\n  if (!(0, _is.default)(type, node, opts)) {\n    throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, ` + `but instead got "${node.type}".`);\n  }\n}\n\nfunction assertArrayExpression(node, opts) {\n  assert("ArrayExpression", node, opts);\n}\n\nfunction assertAssignmentExpression(node, opts) {\n  assert("AssignmentExpression", node, opts);\n}\n\nfunction assertBinaryExpression(node, opts) {\n  assert("BinaryExpression", node, opts);\n}\n\nfunction assertInterpreterDirective(node, opts) {\n  assert("InterpreterDirective", node, opts);\n}\n\nfunction assertDirective(node, opts) {\n  assert("Directive", node, opts);\n}\n\nfunction assertDirectiveLiteral(node, opts) {\n  assert("DirectiveLiteral", node, opts);\n}\n\nfunction assertBlockStatement(node, opts) {\n  assert("BlockStatement", node, opts);\n}\n\nfunction assertBreakStatement(node, opts) {\n  assert("BreakStatement", node, opts);\n}\n\nfunction assertCallExpression(node, opts) {\n  assert("CallExpression", node, opts);\n}\n\nfunction assertCatchClause(node, opts) {\n  assert("CatchClause", node, opts);\n}\n\nfunction assertConditionalExpression(node, opts) {\n  assert("ConditionalExpression", node, opts);\n}\n\nfunction assertContinueStatement(node, opts) {\n  assert("ContinueStatement", node, opts);\n}\n\nfunction assertDebuggerStatement(node, opts) {\n  assert("DebuggerStatement", node, opts);\n}\n\nfunction assertDoWhileStatement(node, opts) {\n  assert("DoWhileStatement", node, opts);\n}\n\nfunction assertEmptyStatement(node, opts) {\n  assert("EmptyStatement", node, opts);\n}\n\nfunction assertExpressionStatement(node, opts) {\n  assert("ExpressionStatement", node, opts);\n}\n\nfunction assertFile(node, opts) {\n  assert("File", node, opts);\n}\n\nfunction assertForInStatement(node, opts) {\n  assert("ForInStatement", node, opts);\n}\n\nfunction assertForStatement(node, opts) {\n  assert("ForStatement", node, opts);\n}\n\nfunction assertFunctionDeclaration(node, opts) {\n  assert("FunctionDeclaration", node, opts);\n}\n\nfunction assertFunctionExpression(node, opts) {\n  assert("FunctionExpression", node, opts);\n}\n\nfunction assertIdentifier(node, opts) {\n  assert("Identifier", node, opts);\n}\n\nfunction assertIfStatement(node, opts) {\n  assert("IfStatement", node, opts);\n}\n\nfunction assertLabeledStatement(node, opts) {\n  assert("LabeledStatement", node, opts);\n}\n\nfunction assertStringLiteral(node, opts) {\n  assert("StringLiteral", node, opts);\n}\n\nfunction assertNumericLiteral(node, opts) {\n  assert("NumericLiteral", node, opts);\n}\n\nfunction assertNullLiteral(node, opts) {\n  assert("NullLiteral", node, opts);\n}\n\nfunction assertBooleanLiteral(node, opts) {\n  assert("BooleanLiteral", node, opts);\n}\n\nfunction assertRegExpLiteral(node, opts) {\n  assert("RegExpLiteral", node, opts);\n}\n\nfunction assertLogicalExpression(node, opts) {\n  assert("LogicalExpression", node, opts);\n}\n\nfunction assertMemberExpression(node, opts) {\n  assert("MemberExpression", node, opts);\n}\n\nfunction assertNewExpression(node, opts) {\n  assert("NewExpression", node, opts);\n}\n\nfunction assertProgram(node, opts) {\n  assert("Program", node, opts);\n}\n\nfunction assertObjectExpression(node, opts) {\n  assert("ObjectExpression", node, opts);\n}\n\nfunction assertObjectMethod(node, opts) {\n  assert("ObjectMethod", node, opts);\n}\n\nfunction assertObjectProperty(node, opts) {\n  assert("ObjectProperty", node, opts);\n}\n\nfunction assertRestElement(node, opts) {\n  assert("RestElement", node, opts);\n}\n\nfunction assertReturnStatement(node, opts) {\n  assert("ReturnStatement", node, opts);\n}\n\nfunction assertSequenceExpression(node, opts) {\n  assert("SequenceExpression", node, opts);\n}\n\nfunction assertParenthesizedExpression(node, opts) {\n  assert("ParenthesizedExpression", node, opts);\n}\n\nfunction assertSwitchCase(node, opts) {\n  assert("SwitchCase", node, opts);\n}\n\nfunction assertSwitchStatement(node, opts) {\n  assert("SwitchStatement", node, opts);\n}\n\nfunction assertThisExpression(node, opts) {\n  assert("ThisExpression", node, opts);\n}\n\nfunction assertThrowStatement(node, opts) {\n  assert("ThrowStatement", node, opts);\n}\n\nfunction assertTryStatement(node, opts) {\n  assert("TryStatement", node, opts);\n}\n\nfunction assertUnaryExpression(node, opts) {\n  assert("UnaryExpression", node, opts);\n}\n\nfunction assertUpdateExpression(node, opts) {\n  assert("UpdateExpression", node, opts);\n}\n\nfunction assertVariableDeclaration(node, opts) {\n  assert("VariableDeclaration", node, opts);\n}\n\nfunction assertVariableDeclarator(node, opts) {\n  assert("VariableDeclarator", node, opts);\n}\n\nfunction assertWhileStatement(node, opts) {\n  assert("WhileStatement", node, opts);\n}\n\nfunction assertWithStatement(node, opts) {\n  assert("WithStatement", node, opts);\n}\n\nfunction assertAssignmentPattern(node, opts) {\n  assert("AssignmentPattern", node, opts);\n}\n\nfunction assertArrayPattern(node, opts) {\n  assert("ArrayPattern", node, opts);\n}\n\nfunction assertArrowFunctionExpression(node, opts) {\n  assert("ArrowFunctionExpression", node, opts);\n}\n\nfunction assertClassBody(node, opts) {\n  assert("ClassBody", node, opts);\n}\n\nfunction assertClassExpression(node, opts) {\n  assert("ClassExpression", node, opts);\n}\n\nfunction assertClassDeclaration(node, opts) {\n  assert("ClassDeclaration", node, opts);\n}\n\nfunction assertExportAllDeclaration(node, opts) {\n  assert("ExportAllDeclaration", node, opts);\n}\n\nfunction assertExportDefaultDeclaration(node, opts) {\n  assert("ExportDefaultDeclaration", node, opts);\n}\n\nfunction assertExportNamedDeclaration(node, opts) {\n  assert("ExportNamedDeclaration", node, opts);\n}\n\nfunction assertExportSpecifier(node, opts) {\n  assert("ExportSpecifier", node, opts);\n}\n\nfunction assertForOfStatement(node, opts) {\n  assert("ForOfStatement", node, opts);\n}\n\nfunction assertImportDeclaration(node, opts) {\n  assert("ImportDeclaration", node, opts);\n}\n\nfunction assertImportDefaultSpecifier(node, opts) {\n  assert("ImportDefaultSpecifier", node, opts);\n}\n\nfunction assertImportNamespaceSpecifier(node, opts) {\n  assert("ImportNamespaceSpecifier", node, opts);\n}\n\nfunction assertImportSpecifier(node, opts) {\n  assert("ImportSpecifier", node, opts);\n}\n\nfunction assertMetaProperty(node, opts) {\n  assert("MetaProperty", node, opts);\n}\n\nfunction assertClassMethod(node, opts) {\n  assert("ClassMethod", node, opts);\n}\n\nfunction assertObjectPattern(node, opts) {\n  assert("ObjectPattern", node, opts);\n}\n\nfunction assertSpreadElement(node, opts) {\n  assert("SpreadElement", node, opts);\n}\n\nfunction assertSuper(node, opts) {\n  assert("Super", node, opts);\n}\n\nfunction assertTaggedTemplateExpression(node, opts) {\n  assert("TaggedTemplateExpression", node, opts);\n}\n\nfunction assertTemplateElement(node, opts) {\n  assert("TemplateElement", node, opts);\n}\n\nfunction assertTemplateLiteral(node, opts) {\n  assert("TemplateLiteral", node, opts);\n}\n\nfunction assertYieldExpression(node, opts) {\n  assert("YieldExpression", node, opts);\n}\n\nfunction assertAwaitExpression(node, opts) {\n  assert("AwaitExpression", node, opts);\n}\n\nfunction assertImport(node, opts) {\n  assert("Import", node, opts);\n}\n\nfunction assertBigIntLiteral(node, opts) {\n  assert("BigIntLiteral", node, opts);\n}\n\nfunction assertExportNamespaceSpecifier(node, opts) {\n  assert("ExportNamespaceSpecifier", node, opts);\n}\n\nfunction assertOptionalMemberExpression(node, opts) {\n  assert("OptionalMemberExpression", node, opts);\n}\n\nfunction assertOptionalCallExpression(node, opts) {\n  assert("OptionalCallExpression", node, opts);\n}\n\nfunction assertAnyTypeAnnotation(node, opts) {\n  assert("AnyTypeAnnotation", node, opts);\n}\n\nfunction assertArrayTypeAnnotation(node, opts) {\n  assert("ArrayTypeAnnotation", node, opts);\n}\n\nfunction assertBooleanTypeAnnotation(node, opts) {\n  assert("BooleanTypeAnnotation", node, opts);\n}\n\nfunction assertBooleanLiteralTypeAnnotation(node, opts) {\n  assert("BooleanLiteralTypeAnnotation", node, opts);\n}\n\nfunction assertNullLiteralTypeAnnotation(node, opts) {\n  assert("NullLiteralTypeAnnotation", node, opts);\n}\n\nfunction assertClassImplements(node, opts) {\n  assert("ClassImplements", node, opts);\n}\n\nfunction assertDeclareClass(node, opts) {\n  assert("DeclareClass", node, opts);\n}\n\nfunction assertDeclareFunction(node, opts) {\n  assert("DeclareFunction", node, opts);\n}\n\nfunction assertDeclareInterface(node, opts) {\n  assert("DeclareInterface", node, opts);\n}\n\nfunction assertDeclareModule(node, opts) {\n  assert("DeclareModule", node, opts);\n}\n\nfunction assertDeclareModuleExports(node, opts) {\n  assert("DeclareModuleExports", node, opts);\n}\n\nfunction assertDeclareTypeAlias(node, opts) {\n  assert("DeclareTypeAlias", node, opts);\n}\n\nfunction assertDeclareOpaqueType(node, opts) {\n  assert("DeclareOpaqueType", node, opts);\n}\n\nfunction assertDeclareVariable(node, opts) {\n  assert("DeclareVariable", node, opts);\n}\n\nfunction assertDeclareExportDeclaration(node, opts) {\n  assert("DeclareExportDeclaration", node, opts);\n}\n\nfunction assertDeclareExportAllDeclaration(node, opts) {\n  assert("DeclareExportAllDeclaration", node, opts);\n}\n\nfunction assertDeclaredPredicate(node, opts) {\n  assert("DeclaredPredicate", node, opts);\n}\n\nfunction assertExistsTypeAnnotation(node, opts) {\n  assert("ExistsTypeAnnotation", node, opts);\n}\n\nfunction assertFunctionTypeAnnotation(node, opts) {\n  assert("FunctionTypeAnnotation", node, opts);\n}\n\nfunction assertFunctionTypeParam(node, opts) {\n  assert("FunctionTypeParam", node, opts);\n}\n\nfunction assertGenericTypeAnnotation(node, opts) {\n  assert("GenericTypeAnnotation", node, opts);\n}\n\nfunction assertInferredPredicate(node, opts) {\n  assert("InferredPredicate", node, opts);\n}\n\nfunction assertInterfaceExtends(node, opts) {\n  assert("InterfaceExtends", node, opts);\n}\n\nfunction assertInterfaceDeclaration(node, opts) {\n  assert("InterfaceDeclaration", node, opts);\n}\n\nfunction assertInterfaceTypeAnnotation(node, opts) {\n  assert("InterfaceTypeAnnotation", node, opts);\n}\n\nfunction assertIntersectionTypeAnnotation(node, opts) {\n  assert("IntersectionTypeAnnotation", node, opts);\n}\n\nfunction assertMixedTypeAnnotation(node, opts) {\n  assert("MixedTypeAnnotation", node, opts);\n}\n\nfunction assertEmptyTypeAnnotation(node, opts) {\n  assert("EmptyTypeAnnotation", node, opts);\n}\n\nfunction assertNullableTypeAnnotation(node, opts) {\n  assert("NullableTypeAnnotation", node, opts);\n}\n\nfunction assertNumberLiteralTypeAnnotation(node, opts) {\n  assert("NumberLiteralTypeAnnotation", node, opts);\n}\n\nfunction assertNumberTypeAnnotation(node, opts) {\n  assert("NumberTypeAnnotation", node, opts);\n}\n\nfunction assertObjectTypeAnnotation(node, opts) {\n  assert("ObjectTypeAnnotation", node, opts);\n}\n\nfunction assertObjectTypeInternalSlot(node, opts) {\n  assert("ObjectTypeInternalSlot", node, opts);\n}\n\nfunction assertObjectTypeCallProperty(node, opts) {\n  assert("ObjectTypeCallProperty", node, opts);\n}\n\nfunction assertObjectTypeIndexer(node, opts) {\n  assert("ObjectTypeIndexer", node, opts);\n}\n\nfunction assertObjectTypeProperty(node, opts) {\n  assert("ObjectTypeProperty", node, opts);\n}\n\nfunction assertObjectTypeSpreadProperty(node, opts) {\n  assert("ObjectTypeSpreadProperty", node, opts);\n}\n\nfunction assertOpaqueType(node, opts) {\n  assert("OpaqueType", node, opts);\n}\n\nfunction assertQualifiedTypeIdentifier(node, opts) {\n  assert("QualifiedTypeIdentifier", node, opts);\n}\n\nfunction assertStringLiteralTypeAnnotation(node, opts) {\n  assert("StringLiteralTypeAnnotation", node, opts);\n}\n\nfunction assertStringTypeAnnotation(node, opts) {\n  assert("StringTypeAnnotation", node, opts);\n}\n\nfunction assertSymbolTypeAnnotation(node, opts) {\n  assert("SymbolTypeAnnotation", node, opts);\n}\n\nfunction assertThisTypeAnnotation(node, opts) {\n  assert("ThisTypeAnnotation", node, opts);\n}\n\nfunction assertTupleTypeAnnotation(node, opts) {\n  assert("TupleTypeAnnotation", node, opts);\n}\n\nfunction assertTypeofTypeAnnotation(node, opts) {\n  assert("TypeofTypeAnnotation", node, opts);\n}\n\nfunction assertTypeAlias(node, opts) {\n  assert("TypeAlias", node, opts);\n}\n\nfunction assertTypeAnnotation(node, opts) {\n  assert("TypeAnnotation", node, opts);\n}\n\nfunction assertTypeCastExpression(node, opts) {\n  assert("TypeCastExpression", node, opts);\n}\n\nfunction assertTypeParameter(node, opts) {\n  assert("TypeParameter", node, opts);\n}\n\nfunction assertTypeParameterDeclaration(node, opts) {\n  assert("TypeParameterDeclaration", node, opts);\n}\n\nfunction assertTypeParameterInstantiation(node, opts) {\n  assert("TypeParameterInstantiation", node, opts);\n}\n\nfunction assertUnionTypeAnnotation(node, opts) {\n  assert("UnionTypeAnnotation", node, opts);\n}\n\nfunction assertVariance(node, opts) {\n  assert("Variance", node, opts);\n}\n\nfunction assertVoidTypeAnnotation(node, opts) {\n  assert("VoidTypeAnnotation", node, opts);\n}\n\nfunction assertEnumDeclaration(node, opts) {\n  assert("EnumDeclaration", node, opts);\n}\n\nfunction assertEnumBooleanBody(node, opts) {\n  assert("EnumBooleanBody", node, opts);\n}\n\nfunction assertEnumNumberBody(node, opts) {\n  assert("EnumNumberBody", node, opts);\n}\n\nfunction assertEnumStringBody(node, opts) {\n  assert("EnumStringBody", node, opts);\n}\n\nfunction assertEnumSymbolBody(node, opts) {\n  assert("EnumSymbolBody", node, opts);\n}\n\nfunction assertEnumBooleanMember(node, opts) {\n  assert("EnumBooleanMember", node, opts);\n}\n\nfunction assertEnumNumberMember(node, opts) {\n  assert("EnumNumberMember", node, opts);\n}\n\nfunction assertEnumStringMember(node, opts) {\n  assert("EnumStringMember", node, opts);\n}\n\nfunction assertEnumDefaultedMember(node, opts) {\n  assert("EnumDefaultedMember", node, opts);\n}\n\nfunction assertJSXAttribute(node, opts) {\n  assert("JSXAttribute", node, opts);\n}\n\nfunction assertJSXClosingElement(node, opts) {\n  assert("JSXClosingElement", node, opts);\n}\n\nfunction assertJSXElement(node, opts) {\n  assert("JSXElement", node, opts);\n}\n\nfunction assertJSXEmptyExpression(node, opts) {\n  assert("JSXEmptyExpression", node, opts);\n}\n\nfunction assertJSXExpressionContainer(node, opts) {\n  assert("JSXExpressionContainer", node, opts);\n}\n\nfunction assertJSXSpreadChild(node, opts) {\n  assert("JSXSpreadChild", node, opts);\n}\n\nfunction assertJSXIdentifier(node, opts) {\n  assert("JSXIdentifier", node, opts);\n}\n\nfunction assertJSXMemberExpression(node, opts) {\n  assert("JSXMemberExpression", node, opts);\n}\n\nfunction assertJSXNamespacedName(node, opts) {\n  assert("JSXNamespacedName", node, opts);\n}\n\nfunction assertJSXOpeningElement(node, opts) {\n  assert("JSXOpeningElement", node, opts);\n}\n\nfunction assertJSXSpreadAttribute(node, opts) {\n  assert("JSXSpreadAttribute", node, opts);\n}\n\nfunction assertJSXText(node, opts) {\n  assert("JSXText", node, opts);\n}\n\nfunction assertJSXFragment(node, opts) {\n  assert("JSXFragment", node, opts);\n}\n\nfunction assertJSXOpeningFragment(node, opts) {\n  assert("JSXOpeningFragment", node, opts);\n}\n\nfunction assertJSXClosingFragment(node, opts) {\n  assert("JSXClosingFragment", node, opts);\n}\n\nfunction assertNoop(node, opts) {\n  assert("Noop", node, opts);\n}\n\nfunction assertPlaceholder(node, opts) {\n  assert("Placeholder", node, opts);\n}\n\nfunction assertV8IntrinsicIdentifier(node, opts) {\n  assert("V8IntrinsicIdentifier", node, opts);\n}\n\nfunction assertArgumentPlaceholder(node, opts) {\n  assert("ArgumentPlaceholder", node, opts);\n}\n\nfunction assertBindExpression(node, opts) {\n  assert("BindExpression", node, opts);\n}\n\nfunction assertClassProperty(node, opts) {\n  assert("ClassProperty", node, opts);\n}\n\nfunction assertPipelineTopicExpression(node, opts) {\n  assert("PipelineTopicExpression", node, opts);\n}\n\nfunction assertPipelineBareFunction(node, opts) {\n  assert("PipelineBareFunction", node, opts);\n}\n\nfunction assertPipelinePrimaryTopicReference(node, opts) {\n  assert("PipelinePrimaryTopicReference", node, opts);\n}\n\nfunction assertClassPrivateProperty(node, opts) {\n  assert("ClassPrivateProperty", node, opts);\n}\n\nfunction assertClassPrivateMethod(node, opts) {\n  assert("ClassPrivateMethod", node, opts);\n}\n\nfunction assertImportAttribute(node, opts) {\n  assert("ImportAttribute", node, opts);\n}\n\nfunction assertDecorator(node, opts) {\n  assert("Decorator", node, opts);\n}\n\nfunction assertDoExpression(node, opts) {\n  assert("DoExpression", node, opts);\n}\n\nfunction assertExportDefaultSpecifier(node, opts) {\n  assert("ExportDefaultSpecifier", node, opts);\n}\n\nfunction assertPrivateName(node, opts) {\n  assert("PrivateName", node, opts);\n}\n\nfunction assertRecordExpression(node, opts) {\n  assert("RecordExpression", node, opts);\n}\n\nfunction assertTupleExpression(node, opts) {\n  assert("TupleExpression", node, opts);\n}\n\nfunction assertDecimalLiteral(node, opts) {\n  assert("DecimalLiteral", node, opts);\n}\n\nfunction assertStaticBlock(node, opts) {\n  assert("StaticBlock", node, opts);\n}\n\nfunction assertTSParameterProperty(node, opts) {\n  assert("TSParameterProperty", node, opts);\n}\n\nfunction assertTSDeclareFunction(node, opts) {\n  assert("TSDeclareFunction", node, opts);\n}\n\nfunction assertTSDeclareMethod(node, opts) {\n  assert("TSDeclareMethod", node, opts);\n}\n\nfunction assertTSQualifiedName(node, opts) {\n  assert("TSQualifiedName", node, opts);\n}\n\nfunction assertTSCallSignatureDeclaration(node, opts) {\n  assert("TSCallSignatureDeclaration", node, opts);\n}\n\nfunction assertTSConstructSignatureDeclaration(node, opts) {\n  assert("TSConstructSignatureDeclaration", node, opts);\n}\n\nfunction assertTSPropertySignature(node, opts) {\n  assert("TSPropertySignature", node, opts);\n}\n\nfunction assertTSMethodSignature(node, opts) {\n  assert("TSMethodSignature", node, opts);\n}\n\nfunction assertTSIndexSignature(node, opts) {\n  assert("TSIndexSignature", node, opts);\n}\n\nfunction assertTSAnyKeyword(node, opts) {\n  assert("TSAnyKeyword", node, opts);\n}\n\nfunction assertTSBooleanKeyword(node, opts) {\n  assert("TSBooleanKeyword", node, opts);\n}\n\nfunction assertTSBigIntKeyword(node, opts) {\n  assert("TSBigIntKeyword", node, opts);\n}\n\nfunction assertTSIntrinsicKeyword(node, opts) {\n  assert("TSIntrinsicKeyword", node, opts);\n}\n\nfunction assertTSNeverKeyword(node, opts) {\n  assert("TSNeverKeyword", node, opts);\n}\n\nfunction assertTSNullKeyword(node, opts) {\n  assert("TSNullKeyword", node, opts);\n}\n\nfunction assertTSNumberKeyword(node, opts) {\n  assert("TSNumberKeyword", node, opts);\n}\n\nfunction assertTSObjectKeyword(node, opts) {\n  assert("TSObjectKeyword", node, opts);\n}\n\nfunction assertTSStringKeyword(node, opts) {\n  assert("TSStringKeyword", node, opts);\n}\n\nfunction assertTSSymbolKeyword(node, opts) {\n  assert("TSSymbolKeyword", node, opts);\n}\n\nfunction assertTSUndefinedKeyword(node, opts) {\n  assert("TSUndefinedKeyword", node, opts);\n}\n\nfunction assertTSUnknownKeyword(node, opts) {\n  assert("TSUnknownKeyword", node, opts);\n}\n\nfunction assertTSVoidKeyword(node, opts) {\n  assert("TSVoidKeyword", node, opts);\n}\n\nfunction assertTSThisType(node, opts) {\n  assert("TSThisType", node, opts);\n}\n\nfunction assertTSFunctionType(node, opts) {\n  assert("TSFunctionType", node, opts);\n}\n\nfunction assertTSConstructorType(node, opts) {\n  assert("TSConstructorType", node, opts);\n}\n\nfunction assertTSTypeReference(node, opts) {\n  assert("TSTypeReference", node, opts);\n}\n\nfunction assertTSTypePredicate(node, opts) {\n  assert("TSTypePredicate", node, opts);\n}\n\nfunction assertTSTypeQuery(node, opts) {\n  assert("TSTypeQuery", node, opts);\n}\n\nfunction assertTSTypeLiteral(node, opts) {\n  assert("TSTypeLiteral", node, opts);\n}\n\nfunction assertTSArrayType(node, opts) {\n  assert("TSArrayType", node, opts);\n}\n\nfunction assertTSTupleType(node, opts) {\n  assert("TSTupleType", node, opts);\n}\n\nfunction assertTSOptionalType(node, opts) {\n  assert("TSOptionalType", node, opts);\n}\n\nfunction assertTSRestType(node, opts) {\n  assert("TSRestType", node, opts);\n}\n\nfunction assertTSNamedTupleMember(node, opts) {\n  assert("TSNamedTupleMember", node, opts);\n}\n\nfunction assertTSUnionType(node, opts) {\n  assert("TSUnionType", node, opts);\n}\n\nfunction assertTSIntersectionType(node, opts) {\n  assert("TSIntersectionType", node, opts);\n}\n\nfunction assertTSConditionalType(node, opts) {\n  assert("TSConditionalType", node, opts);\n}\n\nfunction assertTSInferType(node, opts) {\n  assert("TSInferType", node, opts);\n}\n\nfunction assertTSParenthesizedType(node, opts) {\n  assert("TSParenthesizedType", node, opts);\n}\n\nfunction assertTSTypeOperator(node, opts) {\n  assert("TSTypeOperator", node, opts);\n}\n\nfunction assertTSIndexedAccessType(node, opts) {\n  assert("TSIndexedAccessType", node, opts);\n}\n\nfunction assertTSMappedType(node, opts) {\n  assert("TSMappedType", node, opts);\n}\n\nfunction assertTSLiteralType(node, opts) {\n  assert("TSLiteralType", node, opts);\n}\n\nfunction assertTSExpressionWithTypeArguments(node, opts) {\n  assert("TSExpressionWithTypeArguments", node, opts);\n}\n\nfunction assertTSInterfaceDeclaration(node, opts) {\n  assert("TSInterfaceDeclaration", node, opts);\n}\n\nfunction assertTSInterfaceBody(node, opts) {\n  assert("TSInterfaceBody", node, opts);\n}\n\nfunction assertTSTypeAliasDeclaration(node, opts) {\n  assert("TSTypeAliasDeclaration", node, opts);\n}\n\nfunction assertTSAsExpression(node, opts) {\n  assert("TSAsExpression", node, opts);\n}\n\nfunction assertTSTypeAssertion(node, opts) {\n  assert("TSTypeAssertion", node, opts);\n}\n\nfunction assertTSEnumDeclaration(node, opts) {\n  assert("TSEnumDeclaration", node, opts);\n}\n\nfunction assertTSEnumMember(node, opts) {\n  assert("TSEnumMember", node, opts);\n}\n\nfunction assertTSModuleDeclaration(node, opts) {\n  assert("TSModuleDeclaration", node, opts);\n}\n\nfunction assertTSModuleBlock(node, opts) {\n  assert("TSModuleBlock", node, opts);\n}\n\nfunction assertTSImportType(node, opts) {\n  assert("TSImportType", node, opts);\n}\n\nfunction assertTSImportEqualsDeclaration(node, opts) {\n  assert("TSImportEqualsDeclaration", node, opts);\n}\n\nfunction assertTSExternalModuleReference(node, opts) {\n  assert("TSExternalModuleReference", node, opts);\n}\n\nfunction assertTSNonNullExpression(node, opts) {\n  assert("TSNonNullExpression", node, opts);\n}\n\nfunction assertTSExportAssignment(node, opts) {\n  assert("TSExportAssignment", node, opts);\n}\n\nfunction assertTSNamespaceExportDeclaration(node, opts) {\n  assert("TSNamespaceExportDeclaration", node, opts);\n}\n\nfunction assertTSTypeAnnotation(node, opts) {\n  assert("TSTypeAnnotation", node, opts);\n}\n\nfunction assertTSTypeParameterInstantiation(node, opts) {\n  assert("TSTypeParameterInstantiation", node, opts);\n}\n\nfunction assertTSTypeParameterDeclaration(node, opts) {\n  assert("TSTypeParameterDeclaration", node, opts);\n}\n\nfunction assertTSTypeParameter(node, opts) {\n  assert("TSTypeParameter", node, opts);\n}\n\nfunction assertExpression(node, opts) {\n  assert("Expression", node, opts);\n}\n\nfunction assertBinary(node, opts) {\n  assert("Binary", node, opts);\n}\n\nfunction assertScopable(node, opts) {\n  assert("Scopable", node, opts);\n}\n\nfunction assertBlockParent(node, opts) {\n  assert("BlockParent", node, opts);\n}\n\nfunction assertBlock(node, opts) {\n  assert("Block", node, opts);\n}\n\nfunction assertStatement(node, opts) {\n  assert("Statement", node, opts);\n}\n\nfunction assertTerminatorless(node, opts) {\n  assert("Terminatorless", node, opts);\n}\n\nfunction assertCompletionStatement(node, opts) {\n  assert("CompletionStatement", node, opts);\n}\n\nfunction assertConditional(node, opts) {\n  assert("Conditional", node, opts);\n}\n\nfunction assertLoop(node, opts) {\n  assert("Loop", node, opts);\n}\n\nfunction assertWhile(node, opts) {\n  assert("While", node, opts);\n}\n\nfunction assertExpressionWrapper(node, opts) {\n  assert("ExpressionWrapper", node, opts);\n}\n\nfunction assertFor(node, opts) {\n  assert("For", node, opts);\n}\n\nfunction assertForXStatement(node, opts) {\n  assert("ForXStatement", node, opts);\n}\n\nfunction assertFunction(node, opts) {\n  assert("Function", node, opts);\n}\n\nfunction assertFunctionParent(node, opts) {\n  assert("FunctionParent", node, opts);\n}\n\nfunction assertPureish(node, opts) {\n  assert("Pureish", node, opts);\n}\n\nfunction assertDeclaration(node, opts) {\n  assert("Declaration", node, opts);\n}\n\nfunction assertPatternLike(node, opts) {\n  assert("PatternLike", node, opts);\n}\n\nfunction assertLVal(node, opts) {\n  assert("LVal", node, opts);\n}\n\nfunction assertTSEntityName(node, opts) {\n  assert("TSEntityName", node, opts);\n}\n\nfunction assertLiteral(node, opts) {\n  assert("Literal", node, opts);\n}\n\nfunction assertImmutable(node, opts) {\n  assert("Immutable", node, opts);\n}\n\nfunction assertUserWhitespacable(node, opts) {\n  assert("UserWhitespacable", node, opts);\n}\n\nfunction assertMethod(node, opts) {\n  assert("Method", node, opts);\n}\n\nfunction assertObjectMember(node, opts) {\n  assert("ObjectMember", node, opts);\n}\n\nfunction assertProperty(node, opts) {\n  assert("Property", node, opts);\n}\n\nfunction assertUnaryLike(node, opts) {\n  assert("UnaryLike", node, opts);\n}\n\nfunction assertPattern(node, opts) {\n  assert("Pattern", node, opts);\n}\n\nfunction assertClass(node, opts) {\n  assert("Class", node, opts);\n}\n\nfunction assertModuleDeclaration(node, opts) {\n  assert("ModuleDeclaration", node, opts);\n}\n\nfunction assertExportDeclaration(node, opts) {\n  assert("ExportDeclaration", node, opts);\n}\n\nfunction assertModuleSpecifier(node, opts) {\n  assert("ModuleSpecifier", node, opts);\n}\n\nfunction assertFlow(node, opts) {\n  assert("Flow", node, opts);\n}\n\nfunction assertFlowType(node, opts) {\n  assert("FlowType", node, opts);\n}\n\nfunction assertFlowBaseAnnotation(node, opts) {\n  assert("FlowBaseAnnotation", node, opts);\n}\n\nfunction assertFlowDeclaration(node, opts) {\n  assert("FlowDeclaration", node, opts);\n}\n\nfunction assertFlowPredicate(node, opts) {\n  assert("FlowPredicate", node, opts);\n}\n\nfunction assertEnumBody(node, opts) {\n  assert("EnumBody", node, opts);\n}\n\nfunction assertEnumMember(node, opts) {\n  assert("EnumMember", node, opts);\n}\n\nfunction assertJSX(node, opts) {\n  assert("JSX", node, opts);\n}\n\nfunction assertPrivate(node, opts) {\n  assert("Private", node, opts);\n}\n\nfunction assertTSTypeElement(node, opts) {\n  assert("TSTypeElement", node, opts);\n}\n\nfunction assertTSType(node, opts) {\n  assert("TSType", node, opts);\n}\n\nfunction assertTSBaseType(node, opts) {\n  assert("TSBaseType", node, opts);\n}\n\nfunction assertNumberLiteral(node, opts) {\n  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");\n  assert("NumberLiteral", node, opts);\n}\n\nfunction assertRegexLiteral(node, opts) {\n  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");\n  assert("RegexLiteral", node, opts);\n}\n\nfunction assertRestProperty(node, opts) {\n  console.trace("The node type RestProperty has been renamed to RestElement");\n  assert("RestProperty", node, opts);\n}\n\nfunction assertSpreadProperty(node, opts) {\n  console.trace("The node type SpreadProperty has been renamed to SpreadElement");\n  assert("SpreadProperty", node, opts);\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/asserts/generated/index.js?')},91585:()=>{eval("\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/ast-types/generated/index.js?")},84745:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = builder;\n\nvar _clone = _interopRequireDefault(__webpack_require__(66678));\n\nvar _definitions = __webpack_require__(46507);\n\nvar _validate = _interopRequireDefault(__webpack_require__(43804));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction builder(type, ...args) {\n  const keys = _definitions.BUILDER_KEYS[type];\n  const countArgs = args.length;\n\n  if (countArgs > keys.length) {\n    throw new Error(`${type}: Too many arguments passed. Received ${countArgs} but can receive no more than ${keys.length}`);\n  }\n\n  const node = {\n    type\n  };\n  let i = 0;\n  keys.forEach(key => {\n    const field = _definitions.NODE_FIELDS[type][key];\n    let arg;\n    if (i < countArgs) arg = args[i];\n    if (arg === undefined) arg = (0, _clone.default)(field.default);\n    node[key] = arg;\n    i++;\n  });\n\n  for (const key of Object.keys(node)) {\n    (0, _validate.default)(node, key, node[key]);\n  }\n\n  return node;\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/builders/builder.js?')},29983:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = createFlowUnionType;\n\nvar _generated = __webpack_require__(34391);\n\nvar _removeTypeDuplicates = _interopRequireDefault(__webpack_require__(17321));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction createFlowUnionType(types) {\n  const flattened = (0, _removeTypeDuplicates.default)(types);\n\n  if (flattened.length === 1) {\n    return flattened[0];\n  } else {\n    return (0, _generated.unionTypeAnnotation)(flattened);\n  }\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js?')},40949:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = createTypeAnnotationBasedOnTypeof;\n\nvar _generated = __webpack_require__(34391);\n\nfunction createTypeAnnotationBasedOnTypeof(type) {\n  if (type === "string") {\n    return (0, _generated.stringTypeAnnotation)();\n  } else if (type === "number") {\n    return (0, _generated.numberTypeAnnotation)();\n  } else if (type === "undefined") {\n    return (0, _generated.voidTypeAnnotation)();\n  } else if (type === "boolean") {\n    return (0, _generated.booleanTypeAnnotation)();\n  } else if (type === "function") {\n    return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Function"));\n  } else if (type === "object") {\n    return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Object"));\n  } else if (type === "symbol") {\n    return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Symbol"));\n  } else {\n    throw new Error("Invalid typeof value");\n  }\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js?')},34391:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.arrayExpression = arrayExpression;\nexports.assignmentExpression = assignmentExpression;\nexports.binaryExpression = binaryExpression;\nexports.interpreterDirective = interpreterDirective;\nexports.directive = directive;\nexports.directiveLiteral = directiveLiteral;\nexports.blockStatement = blockStatement;\nexports.breakStatement = breakStatement;\nexports.callExpression = callExpression;\nexports.catchClause = catchClause;\nexports.conditionalExpression = conditionalExpression;\nexports.continueStatement = continueStatement;\nexports.debuggerStatement = debuggerStatement;\nexports.doWhileStatement = doWhileStatement;\nexports.emptyStatement = emptyStatement;\nexports.expressionStatement = expressionStatement;\nexports.file = file;\nexports.forInStatement = forInStatement;\nexports.forStatement = forStatement;\nexports.functionDeclaration = functionDeclaration;\nexports.functionExpression = functionExpression;\nexports.identifier = identifier;\nexports.ifStatement = ifStatement;\nexports.labeledStatement = labeledStatement;\nexports.stringLiteral = stringLiteral;\nexports.numericLiteral = numericLiteral;\nexports.nullLiteral = nullLiteral;\nexports.booleanLiteral = booleanLiteral;\nexports.regExpLiteral = regExpLiteral;\nexports.logicalExpression = logicalExpression;\nexports.memberExpression = memberExpression;\nexports.newExpression = newExpression;\nexports.program = program;\nexports.objectExpression = objectExpression;\nexports.objectMethod = objectMethod;\nexports.objectProperty = objectProperty;\nexports.restElement = restElement;\nexports.returnStatement = returnStatement;\nexports.sequenceExpression = sequenceExpression;\nexports.parenthesizedExpression = parenthesizedExpression;\nexports.switchCase = switchCase;\nexports.switchStatement = switchStatement;\nexports.thisExpression = thisExpression;\nexports.throwStatement = throwStatement;\nexports.tryStatement = tryStatement;\nexports.unaryExpression = unaryExpression;\nexports.updateExpression = updateExpression;\nexports.variableDeclaration = variableDeclaration;\nexports.variableDeclarator = variableDeclarator;\nexports.whileStatement = whileStatement;\nexports.withStatement = withStatement;\nexports.assignmentPattern = assignmentPattern;\nexports.arrayPattern = arrayPattern;\nexports.arrowFunctionExpression = arrowFunctionExpression;\nexports.classBody = classBody;\nexports.classExpression = classExpression;\nexports.classDeclaration = classDeclaration;\nexports.exportAllDeclaration = exportAllDeclaration;\nexports.exportDefaultDeclaration = exportDefaultDeclaration;\nexports.exportNamedDeclaration = exportNamedDeclaration;\nexports.exportSpecifier = exportSpecifier;\nexports.forOfStatement = forOfStatement;\nexports.importDeclaration = importDeclaration;\nexports.importDefaultSpecifier = importDefaultSpecifier;\nexports.importNamespaceSpecifier = importNamespaceSpecifier;\nexports.importSpecifier = importSpecifier;\nexports.metaProperty = metaProperty;\nexports.classMethod = classMethod;\nexports.objectPattern = objectPattern;\nexports.spreadElement = spreadElement;\nexports.super = _super;\nexports.taggedTemplateExpression = taggedTemplateExpression;\nexports.templateElement = templateElement;\nexports.templateLiteral = templateLiteral;\nexports.yieldExpression = yieldExpression;\nexports.awaitExpression = awaitExpression;\nexports.import = _import;\nexports.bigIntLiteral = bigIntLiteral;\nexports.exportNamespaceSpecifier = exportNamespaceSpecifier;\nexports.optionalMemberExpression = optionalMemberExpression;\nexports.optionalCallExpression = optionalCallExpression;\nexports.anyTypeAnnotation = anyTypeAnnotation;\nexports.arrayTypeAnnotation = arrayTypeAnnotation;\nexports.booleanTypeAnnotation = booleanTypeAnnotation;\nexports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;\nexports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;\nexports.classImplements = classImplements;\nexports.declareClass = declareClass;\nexports.declareFunction = declareFunction;\nexports.declareInterface = declareInterface;\nexports.declareModule = declareModule;\nexports.declareModuleExports = declareModuleExports;\nexports.declareTypeAlias = declareTypeAlias;\nexports.declareOpaqueType = declareOpaqueType;\nexports.declareVariable = declareVariable;\nexports.declareExportDeclaration = declareExportDeclaration;\nexports.declareExportAllDeclaration = declareExportAllDeclaration;\nexports.declaredPredicate = declaredPredicate;\nexports.existsTypeAnnotation = existsTypeAnnotation;\nexports.functionTypeAnnotation = functionTypeAnnotation;\nexports.functionTypeParam = functionTypeParam;\nexports.genericTypeAnnotation = genericTypeAnnotation;\nexports.inferredPredicate = inferredPredicate;\nexports.interfaceExtends = interfaceExtends;\nexports.interfaceDeclaration = interfaceDeclaration;\nexports.interfaceTypeAnnotation = interfaceTypeAnnotation;\nexports.intersectionTypeAnnotation = intersectionTypeAnnotation;\nexports.mixedTypeAnnotation = mixedTypeAnnotation;\nexports.emptyTypeAnnotation = emptyTypeAnnotation;\nexports.nullableTypeAnnotation = nullableTypeAnnotation;\nexports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;\nexports.numberTypeAnnotation = numberTypeAnnotation;\nexports.objectTypeAnnotation = objectTypeAnnotation;\nexports.objectTypeInternalSlot = objectTypeInternalSlot;\nexports.objectTypeCallProperty = objectTypeCallProperty;\nexports.objectTypeIndexer = objectTypeIndexer;\nexports.objectTypeProperty = objectTypeProperty;\nexports.objectTypeSpreadProperty = objectTypeSpreadProperty;\nexports.opaqueType = opaqueType;\nexports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;\nexports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;\nexports.stringTypeAnnotation = stringTypeAnnotation;\nexports.symbolTypeAnnotation = symbolTypeAnnotation;\nexports.thisTypeAnnotation = thisTypeAnnotation;\nexports.tupleTypeAnnotation = tupleTypeAnnotation;\nexports.typeofTypeAnnotation = typeofTypeAnnotation;\nexports.typeAlias = typeAlias;\nexports.typeAnnotation = typeAnnotation;\nexports.typeCastExpression = typeCastExpression;\nexports.typeParameter = typeParameter;\nexports.typeParameterDeclaration = typeParameterDeclaration;\nexports.typeParameterInstantiation = typeParameterInstantiation;\nexports.unionTypeAnnotation = unionTypeAnnotation;\nexports.variance = variance;\nexports.voidTypeAnnotation = voidTypeAnnotation;\nexports.enumDeclaration = enumDeclaration;\nexports.enumBooleanBody = enumBooleanBody;\nexports.enumNumberBody = enumNumberBody;\nexports.enumStringBody = enumStringBody;\nexports.enumSymbolBody = enumSymbolBody;\nexports.enumBooleanMember = enumBooleanMember;\nexports.enumNumberMember = enumNumberMember;\nexports.enumStringMember = enumStringMember;\nexports.enumDefaultedMember = enumDefaultedMember;\nexports.jSXAttribute = exports.jsxAttribute = jsxAttribute;\nexports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement;\nexports.jSXElement = exports.jsxElement = jsxElement;\nexports.jSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;\nexports.jSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;\nexports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;\nexports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier;\nexports.jSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;\nexports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;\nexports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;\nexports.jSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;\nexports.jSXText = exports.jsxText = jsxText;\nexports.jSXFragment = exports.jsxFragment = jsxFragment;\nexports.jSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;\nexports.jSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;\nexports.noop = noop;\nexports.placeholder = placeholder;\nexports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;\nexports.argumentPlaceholder = argumentPlaceholder;\nexports.bindExpression = bindExpression;\nexports.classProperty = classProperty;\nexports.pipelineTopicExpression = pipelineTopicExpression;\nexports.pipelineBareFunction = pipelineBareFunction;\nexports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;\nexports.classPrivateProperty = classPrivateProperty;\nexports.classPrivateMethod = classPrivateMethod;\nexports.importAttribute = importAttribute;\nexports.decorator = decorator;\nexports.doExpression = doExpression;\nexports.exportDefaultSpecifier = exportDefaultSpecifier;\nexports.privateName = privateName;\nexports.recordExpression = recordExpression;\nexports.tupleExpression = tupleExpression;\nexports.decimalLiteral = decimalLiteral;\nexports.staticBlock = staticBlock;\nexports.tSParameterProperty = exports.tsParameterProperty = tsParameterProperty;\nexports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;\nexports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;\nexports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName;\nexports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;\nexports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;\nexports.tSPropertySignature = exports.tsPropertySignature = tsPropertySignature;\nexports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature;\nexports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature;\nexports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;\nexports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;\nexports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;\nexports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = tsIntrinsicKeyword;\nexports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;\nexports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword;\nexports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;\nexports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;\nexports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword;\nexports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;\nexports.tSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;\nexports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;\nexports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;\nexports.tSThisType = exports.tsThisType = tsThisType;\nexports.tSFunctionType = exports.tsFunctionType = tsFunctionType;\nexports.tSConstructorType = exports.tsConstructorType = tsConstructorType;\nexports.tSTypeReference = exports.tsTypeReference = tsTypeReference;\nexports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate;\nexports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery;\nexports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;\nexports.tSArrayType = exports.tsArrayType = tsArrayType;\nexports.tSTupleType = exports.tsTupleType = tsTupleType;\nexports.tSOptionalType = exports.tsOptionalType = tsOptionalType;\nexports.tSRestType = exports.tsRestType = tsRestType;\nexports.tSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;\nexports.tSUnionType = exports.tsUnionType = tsUnionType;\nexports.tSIntersectionType = exports.tsIntersectionType = tsIntersectionType;\nexports.tSConditionalType = exports.tsConditionalType = tsConditionalType;\nexports.tSInferType = exports.tsInferType = tsInferType;\nexports.tSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;\nexports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator;\nexports.tSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;\nexports.tSMappedType = exports.tsMappedType = tsMappedType;\nexports.tSLiteralType = exports.tsLiteralType = tsLiteralType;\nexports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;\nexports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;\nexports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;\nexports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;\nexports.tSAsExpression = exports.tsAsExpression = tsAsExpression;\nexports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;\nexports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;\nexports.tSEnumMember = exports.tsEnumMember = tsEnumMember;\nexports.tSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;\nexports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock;\nexports.tSImportType = exports.tsImportType = tsImportType;\nexports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;\nexports.tSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;\nexports.tSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;\nexports.tSExportAssignment = exports.tsExportAssignment = tsExportAssignment;\nexports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;\nexports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;\nexports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;\nexports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;\nexports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter;\nexports.numberLiteral = NumberLiteral;\nexports.regexLiteral = RegexLiteral;\nexports.restProperty = RestProperty;\nexports.spreadProperty = SpreadProperty;\n\nvar _builder = _interopRequireDefault(__webpack_require__(84745));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction arrayExpression(elements) {\n  return (0, _builder.default)("ArrayExpression", ...arguments);\n}\n\nfunction assignmentExpression(operator, left, right) {\n  return (0, _builder.default)("AssignmentExpression", ...arguments);\n}\n\nfunction binaryExpression(operator, left, right) {\n  return (0, _builder.default)("BinaryExpression", ...arguments);\n}\n\nfunction interpreterDirective(value) {\n  return (0, _builder.default)("InterpreterDirective", ...arguments);\n}\n\nfunction directive(value) {\n  return (0, _builder.default)("Directive", ...arguments);\n}\n\nfunction directiveLiteral(value) {\n  return (0, _builder.default)("DirectiveLiteral", ...arguments);\n}\n\nfunction blockStatement(body, directives) {\n  return (0, _builder.default)("BlockStatement", ...arguments);\n}\n\nfunction breakStatement(label) {\n  return (0, _builder.default)("BreakStatement", ...arguments);\n}\n\nfunction callExpression(callee, _arguments) {\n  return (0, _builder.default)("CallExpression", ...arguments);\n}\n\nfunction catchClause(param, body) {\n  return (0, _builder.default)("CatchClause", ...arguments);\n}\n\nfunction conditionalExpression(test, consequent, alternate) {\n  return (0, _builder.default)("ConditionalExpression", ...arguments);\n}\n\nfunction continueStatement(label) {\n  return (0, _builder.default)("ContinueStatement", ...arguments);\n}\n\nfunction debuggerStatement() {\n  return (0, _builder.default)("DebuggerStatement", ...arguments);\n}\n\nfunction doWhileStatement(test, body) {\n  return (0, _builder.default)("DoWhileStatement", ...arguments);\n}\n\nfunction emptyStatement() {\n  return (0, _builder.default)("EmptyStatement", ...arguments);\n}\n\nfunction expressionStatement(expression) {\n  return (0, _builder.default)("ExpressionStatement", ...arguments);\n}\n\nfunction file(program, comments, tokens) {\n  return (0, _builder.default)("File", ...arguments);\n}\n\nfunction forInStatement(left, right, body) {\n  return (0, _builder.default)("ForInStatement", ...arguments);\n}\n\nfunction forStatement(init, test, update, body) {\n  return (0, _builder.default)("ForStatement", ...arguments);\n}\n\nfunction functionDeclaration(id, params, body, generator, async) {\n  return (0, _builder.default)("FunctionDeclaration", ...arguments);\n}\n\nfunction functionExpression(id, params, body, generator, async) {\n  return (0, _builder.default)("FunctionExpression", ...arguments);\n}\n\nfunction identifier(name) {\n  return (0, _builder.default)("Identifier", ...arguments);\n}\n\nfunction ifStatement(test, consequent, alternate) {\n  return (0, _builder.default)("IfStatement", ...arguments);\n}\n\nfunction labeledStatement(label, body) {\n  return (0, _builder.default)("LabeledStatement", ...arguments);\n}\n\nfunction stringLiteral(value) {\n  return (0, _builder.default)("StringLiteral", ...arguments);\n}\n\nfunction numericLiteral(value) {\n  return (0, _builder.default)("NumericLiteral", ...arguments);\n}\n\nfunction nullLiteral() {\n  return (0, _builder.default)("NullLiteral", ...arguments);\n}\n\nfunction booleanLiteral(value) {\n  return (0, _builder.default)("BooleanLiteral", ...arguments);\n}\n\nfunction regExpLiteral(pattern, flags) {\n  return (0, _builder.default)("RegExpLiteral", ...arguments);\n}\n\nfunction logicalExpression(operator, left, right) {\n  return (0, _builder.default)("LogicalExpression", ...arguments);\n}\n\nfunction memberExpression(object, property, computed, optional) {\n  return (0, _builder.default)("MemberExpression", ...arguments);\n}\n\nfunction newExpression(callee, _arguments) {\n  return (0, _builder.default)("NewExpression", ...arguments);\n}\n\nfunction program(body, directives, sourceType, interpreter) {\n  return (0, _builder.default)("Program", ...arguments);\n}\n\nfunction objectExpression(properties) {\n  return (0, _builder.default)("ObjectExpression", ...arguments);\n}\n\nfunction objectMethod(kind, key, params, body, computed, generator, async) {\n  return (0, _builder.default)("ObjectMethod", ...arguments);\n}\n\nfunction objectProperty(key, value, computed, shorthand, decorators) {\n  return (0, _builder.default)("ObjectProperty", ...arguments);\n}\n\nfunction restElement(argument) {\n  return (0, _builder.default)("RestElement", ...arguments);\n}\n\nfunction returnStatement(argument) {\n  return (0, _builder.default)("ReturnStatement", ...arguments);\n}\n\nfunction sequenceExpression(expressions) {\n  return (0, _builder.default)("SequenceExpression", ...arguments);\n}\n\nfunction parenthesizedExpression(expression) {\n  return (0, _builder.default)("ParenthesizedExpression", ...arguments);\n}\n\nfunction switchCase(test, consequent) {\n  return (0, _builder.default)("SwitchCase", ...arguments);\n}\n\nfunction switchStatement(discriminant, cases) {\n  return (0, _builder.default)("SwitchStatement", ...arguments);\n}\n\nfunction thisExpression() {\n  return (0, _builder.default)("ThisExpression", ...arguments);\n}\n\nfunction throwStatement(argument) {\n  return (0, _builder.default)("ThrowStatement", ...arguments);\n}\n\nfunction tryStatement(block, handler, finalizer) {\n  return (0, _builder.default)("TryStatement", ...arguments);\n}\n\nfunction unaryExpression(operator, argument, prefix) {\n  return (0, _builder.default)("UnaryExpression", ...arguments);\n}\n\nfunction updateExpression(operator, argument, prefix) {\n  return (0, _builder.default)("UpdateExpression", ...arguments);\n}\n\nfunction variableDeclaration(kind, declarations) {\n  return (0, _builder.default)("VariableDeclaration", ...arguments);\n}\n\nfunction variableDeclarator(id, init) {\n  return (0, _builder.default)("VariableDeclarator", ...arguments);\n}\n\nfunction whileStatement(test, body) {\n  return (0, _builder.default)("WhileStatement", ...arguments);\n}\n\nfunction withStatement(object, body) {\n  return (0, _builder.default)("WithStatement", ...arguments);\n}\n\nfunction assignmentPattern(left, right) {\n  return (0, _builder.default)("AssignmentPattern", ...arguments);\n}\n\nfunction arrayPattern(elements) {\n  return (0, _builder.default)("ArrayPattern", ...arguments);\n}\n\nfunction arrowFunctionExpression(params, body, async) {\n  return (0, _builder.default)("ArrowFunctionExpression", ...arguments);\n}\n\nfunction classBody(body) {\n  return (0, _builder.default)("ClassBody", ...arguments);\n}\n\nfunction classExpression(id, superClass, body, decorators) {\n  return (0, _builder.default)("ClassExpression", ...arguments);\n}\n\nfunction classDeclaration(id, superClass, body, decorators) {\n  return (0, _builder.default)("ClassDeclaration", ...arguments);\n}\n\nfunction exportAllDeclaration(source) {\n  return (0, _builder.default)("ExportAllDeclaration", ...arguments);\n}\n\nfunction exportDefaultDeclaration(declaration) {\n  return (0, _builder.default)("ExportDefaultDeclaration", ...arguments);\n}\n\nfunction exportNamedDeclaration(declaration, specifiers, source) {\n  return (0, _builder.default)("ExportNamedDeclaration", ...arguments);\n}\n\nfunction exportSpecifier(local, exported) {\n  return (0, _builder.default)("ExportSpecifier", ...arguments);\n}\n\nfunction forOfStatement(left, right, body, _await) {\n  return (0, _builder.default)("ForOfStatement", ...arguments);\n}\n\nfunction importDeclaration(specifiers, source) {\n  return (0, _builder.default)("ImportDeclaration", ...arguments);\n}\n\nfunction importDefaultSpecifier(local) {\n  return (0, _builder.default)("ImportDefaultSpecifier", ...arguments);\n}\n\nfunction importNamespaceSpecifier(local) {\n  return (0, _builder.default)("ImportNamespaceSpecifier", ...arguments);\n}\n\nfunction importSpecifier(local, imported) {\n  return (0, _builder.default)("ImportSpecifier", ...arguments);\n}\n\nfunction metaProperty(meta, property) {\n  return (0, _builder.default)("MetaProperty", ...arguments);\n}\n\nfunction classMethod(kind, key, params, body, computed, _static, generator, async) {\n  return (0, _builder.default)("ClassMethod", ...arguments);\n}\n\nfunction objectPattern(properties) {\n  return (0, _builder.default)("ObjectPattern", ...arguments);\n}\n\nfunction spreadElement(argument) {\n  return (0, _builder.default)("SpreadElement", ...arguments);\n}\n\nfunction _super() {\n  return (0, _builder.default)("Super", ...arguments);\n}\n\nfunction taggedTemplateExpression(tag, quasi) {\n  return (0, _builder.default)("TaggedTemplateExpression", ...arguments);\n}\n\nfunction templateElement(value, tail) {\n  return (0, _builder.default)("TemplateElement", ...arguments);\n}\n\nfunction templateLiteral(quasis, expressions) {\n  return (0, _builder.default)("TemplateLiteral", ...arguments);\n}\n\nfunction yieldExpression(argument, delegate) {\n  return (0, _builder.default)("YieldExpression", ...arguments);\n}\n\nfunction awaitExpression(argument) {\n  return (0, _builder.default)("AwaitExpression", ...arguments);\n}\n\nfunction _import() {\n  return (0, _builder.default)("Import", ...arguments);\n}\n\nfunction bigIntLiteral(value) {\n  return (0, _builder.default)("BigIntLiteral", ...arguments);\n}\n\nfunction exportNamespaceSpecifier(exported) {\n  return (0, _builder.default)("ExportNamespaceSpecifier", ...arguments);\n}\n\nfunction optionalMemberExpression(object, property, computed, optional) {\n  return (0, _builder.default)("OptionalMemberExpression", ...arguments);\n}\n\nfunction optionalCallExpression(callee, _arguments, optional) {\n  return (0, _builder.default)("OptionalCallExpression", ...arguments);\n}\n\nfunction anyTypeAnnotation() {\n  return (0, _builder.default)("AnyTypeAnnotation", ...arguments);\n}\n\nfunction arrayTypeAnnotation(elementType) {\n  return (0, _builder.default)("ArrayTypeAnnotation", ...arguments);\n}\n\nfunction booleanTypeAnnotation() {\n  return (0, _builder.default)("BooleanTypeAnnotation", ...arguments);\n}\n\nfunction booleanLiteralTypeAnnotation(value) {\n  return (0, _builder.default)("BooleanLiteralTypeAnnotation", ...arguments);\n}\n\nfunction nullLiteralTypeAnnotation() {\n  return (0, _builder.default)("NullLiteralTypeAnnotation", ...arguments);\n}\n\nfunction classImplements(id, typeParameters) {\n  return (0, _builder.default)("ClassImplements", ...arguments);\n}\n\nfunction declareClass(id, typeParameters, _extends, body) {\n  return (0, _builder.default)("DeclareClass", ...arguments);\n}\n\nfunction declareFunction(id) {\n  return (0, _builder.default)("DeclareFunction", ...arguments);\n}\n\nfunction declareInterface(id, typeParameters, _extends, body) {\n  return (0, _builder.default)("DeclareInterface", ...arguments);\n}\n\nfunction declareModule(id, body, kind) {\n  return (0, _builder.default)("DeclareModule", ...arguments);\n}\n\nfunction declareModuleExports(typeAnnotation) {\n  return (0, _builder.default)("DeclareModuleExports", ...arguments);\n}\n\nfunction declareTypeAlias(id, typeParameters, right) {\n  return (0, _builder.default)("DeclareTypeAlias", ...arguments);\n}\n\nfunction declareOpaqueType(id, typeParameters, supertype) {\n  return (0, _builder.default)("DeclareOpaqueType", ...arguments);\n}\n\nfunction declareVariable(id) {\n  return (0, _builder.default)("DeclareVariable", ...arguments);\n}\n\nfunction declareExportDeclaration(declaration, specifiers, source) {\n  return (0, _builder.default)("DeclareExportDeclaration", ...arguments);\n}\n\nfunction declareExportAllDeclaration(source) {\n  return (0, _builder.default)("DeclareExportAllDeclaration", ...arguments);\n}\n\nfunction declaredPredicate(value) {\n  return (0, _builder.default)("DeclaredPredicate", ...arguments);\n}\n\nfunction existsTypeAnnotation() {\n  return (0, _builder.default)("ExistsTypeAnnotation", ...arguments);\n}\n\nfunction functionTypeAnnotation(typeParameters, params, rest, returnType) {\n  return (0, _builder.default)("FunctionTypeAnnotation", ...arguments);\n}\n\nfunction functionTypeParam(name, typeAnnotation) {\n  return (0, _builder.default)("FunctionTypeParam", ...arguments);\n}\n\nfunction genericTypeAnnotation(id, typeParameters) {\n  return (0, _builder.default)("GenericTypeAnnotation", ...arguments);\n}\n\nfunction inferredPredicate() {\n  return (0, _builder.default)("InferredPredicate", ...arguments);\n}\n\nfunction interfaceExtends(id, typeParameters) {\n  return (0, _builder.default)("InterfaceExtends", ...arguments);\n}\n\nfunction interfaceDeclaration(id, typeParameters, _extends, body) {\n  return (0, _builder.default)("InterfaceDeclaration", ...arguments);\n}\n\nfunction interfaceTypeAnnotation(_extends, body) {\n  return (0, _builder.default)("InterfaceTypeAnnotation", ...arguments);\n}\n\nfunction intersectionTypeAnnotation(types) {\n  return (0, _builder.default)("IntersectionTypeAnnotation", ...arguments);\n}\n\nfunction mixedTypeAnnotation() {\n  return (0, _builder.default)("MixedTypeAnnotation", ...arguments);\n}\n\nfunction emptyTypeAnnotation() {\n  return (0, _builder.default)("EmptyTypeAnnotation", ...arguments);\n}\n\nfunction nullableTypeAnnotation(typeAnnotation) {\n  return (0, _builder.default)("NullableTypeAnnotation", ...arguments);\n}\n\nfunction numberLiteralTypeAnnotation(value) {\n  return (0, _builder.default)("NumberLiteralTypeAnnotation", ...arguments);\n}\n\nfunction numberTypeAnnotation() {\n  return (0, _builder.default)("NumberTypeAnnotation", ...arguments);\n}\n\nfunction objectTypeAnnotation(properties, indexers, callProperties, internalSlots, exact) {\n  return (0, _builder.default)("ObjectTypeAnnotation", ...arguments);\n}\n\nfunction objectTypeInternalSlot(id, value, optional, _static, method) {\n  return (0, _builder.default)("ObjectTypeInternalSlot", ...arguments);\n}\n\nfunction objectTypeCallProperty(value) {\n  return (0, _builder.default)("ObjectTypeCallProperty", ...arguments);\n}\n\nfunction objectTypeIndexer(id, key, value, variance) {\n  return (0, _builder.default)("ObjectTypeIndexer", ...arguments);\n}\n\nfunction objectTypeProperty(key, value, variance) {\n  return (0, _builder.default)("ObjectTypeProperty", ...arguments);\n}\n\nfunction objectTypeSpreadProperty(argument) {\n  return (0, _builder.default)("ObjectTypeSpreadProperty", ...arguments);\n}\n\nfunction opaqueType(id, typeParameters, supertype, impltype) {\n  return (0, _builder.default)("OpaqueType", ...arguments);\n}\n\nfunction qualifiedTypeIdentifier(id, qualification) {\n  return (0, _builder.default)("QualifiedTypeIdentifier", ...arguments);\n}\n\nfunction stringLiteralTypeAnnotation(value) {\n  return (0, _builder.default)("StringLiteralTypeAnnotation", ...arguments);\n}\n\nfunction stringTypeAnnotation() {\n  return (0, _builder.default)("StringTypeAnnotation", ...arguments);\n}\n\nfunction symbolTypeAnnotation() {\n  return (0, _builder.default)("SymbolTypeAnnotation", ...arguments);\n}\n\nfunction thisTypeAnnotation() {\n  return (0, _builder.default)("ThisTypeAnnotation", ...arguments);\n}\n\nfunction tupleTypeAnnotation(types) {\n  return (0, _builder.default)("TupleTypeAnnotation", ...arguments);\n}\n\nfunction typeofTypeAnnotation(argument) {\n  return (0, _builder.default)("TypeofTypeAnnotation", ...arguments);\n}\n\nfunction typeAlias(id, typeParameters, right) {\n  return (0, _builder.default)("TypeAlias", ...arguments);\n}\n\nfunction typeAnnotation(typeAnnotation) {\n  return (0, _builder.default)("TypeAnnotation", ...arguments);\n}\n\nfunction typeCastExpression(expression, typeAnnotation) {\n  return (0, _builder.default)("TypeCastExpression", ...arguments);\n}\n\nfunction typeParameter(bound, _default, variance) {\n  return (0, _builder.default)("TypeParameter", ...arguments);\n}\n\nfunction typeParameterDeclaration(params) {\n  return (0, _builder.default)("TypeParameterDeclaration", ...arguments);\n}\n\nfunction typeParameterInstantiation(params) {\n  return (0, _builder.default)("TypeParameterInstantiation", ...arguments);\n}\n\nfunction unionTypeAnnotation(types) {\n  return (0, _builder.default)("UnionTypeAnnotation", ...arguments);\n}\n\nfunction variance(kind) {\n  return (0, _builder.default)("Variance", ...arguments);\n}\n\nfunction voidTypeAnnotation() {\n  return (0, _builder.default)("VoidTypeAnnotation", ...arguments);\n}\n\nfunction enumDeclaration(id, body) {\n  return (0, _builder.default)("EnumDeclaration", ...arguments);\n}\n\nfunction enumBooleanBody(members) {\n  return (0, _builder.default)("EnumBooleanBody", ...arguments);\n}\n\nfunction enumNumberBody(members) {\n  return (0, _builder.default)("EnumNumberBody", ...arguments);\n}\n\nfunction enumStringBody(members) {\n  return (0, _builder.default)("EnumStringBody", ...arguments);\n}\n\nfunction enumSymbolBody(members) {\n  return (0, _builder.default)("EnumSymbolBody", ...arguments);\n}\n\nfunction enumBooleanMember(id) {\n  return (0, _builder.default)("EnumBooleanMember", ...arguments);\n}\n\nfunction enumNumberMember(id, init) {\n  return (0, _builder.default)("EnumNumberMember", ...arguments);\n}\n\nfunction enumStringMember(id, init) {\n  return (0, _builder.default)("EnumStringMember", ...arguments);\n}\n\nfunction enumDefaultedMember(id) {\n  return (0, _builder.default)("EnumDefaultedMember", ...arguments);\n}\n\nfunction jsxAttribute(name, value) {\n  return (0, _builder.default)("JSXAttribute", ...arguments);\n}\n\nfunction jsxClosingElement(name) {\n  return (0, _builder.default)("JSXClosingElement", ...arguments);\n}\n\nfunction jsxElement(openingElement, closingElement, children, selfClosing) {\n  return (0, _builder.default)("JSXElement", ...arguments);\n}\n\nfunction jsxEmptyExpression() {\n  return (0, _builder.default)("JSXEmptyExpression", ...arguments);\n}\n\nfunction jsxExpressionContainer(expression) {\n  return (0, _builder.default)("JSXExpressionContainer", ...arguments);\n}\n\nfunction jsxSpreadChild(expression) {\n  return (0, _builder.default)("JSXSpreadChild", ...arguments);\n}\n\nfunction jsxIdentifier(name) {\n  return (0, _builder.default)("JSXIdentifier", ...arguments);\n}\n\nfunction jsxMemberExpression(object, property) {\n  return (0, _builder.default)("JSXMemberExpression", ...arguments);\n}\n\nfunction jsxNamespacedName(namespace, name) {\n  return (0, _builder.default)("JSXNamespacedName", ...arguments);\n}\n\nfunction jsxOpeningElement(name, attributes, selfClosing) {\n  return (0, _builder.default)("JSXOpeningElement", ...arguments);\n}\n\nfunction jsxSpreadAttribute(argument) {\n  return (0, _builder.default)("JSXSpreadAttribute", ...arguments);\n}\n\nfunction jsxText(value) {\n  return (0, _builder.default)("JSXText", ...arguments);\n}\n\nfunction jsxFragment(openingFragment, closingFragment, children) {\n  return (0, _builder.default)("JSXFragment", ...arguments);\n}\n\nfunction jsxOpeningFragment() {\n  return (0, _builder.default)("JSXOpeningFragment", ...arguments);\n}\n\nfunction jsxClosingFragment() {\n  return (0, _builder.default)("JSXClosingFragment", ...arguments);\n}\n\nfunction noop() {\n  return (0, _builder.default)("Noop", ...arguments);\n}\n\nfunction placeholder(expectedNode, name) {\n  return (0, _builder.default)("Placeholder", ...arguments);\n}\n\nfunction v8IntrinsicIdentifier(name) {\n  return (0, _builder.default)("V8IntrinsicIdentifier", ...arguments);\n}\n\nfunction argumentPlaceholder() {\n  return (0, _builder.default)("ArgumentPlaceholder", ...arguments);\n}\n\nfunction bindExpression(object, callee) {\n  return (0, _builder.default)("BindExpression", ...arguments);\n}\n\nfunction classProperty(key, value, typeAnnotation, decorators, computed, _static) {\n  return (0, _builder.default)("ClassProperty", ...arguments);\n}\n\nfunction pipelineTopicExpression(expression) {\n  return (0, _builder.default)("PipelineTopicExpression", ...arguments);\n}\n\nfunction pipelineBareFunction(callee) {\n  return (0, _builder.default)("PipelineBareFunction", ...arguments);\n}\n\nfunction pipelinePrimaryTopicReference() {\n  return (0, _builder.default)("PipelinePrimaryTopicReference", ...arguments);\n}\n\nfunction classPrivateProperty(key, value, decorators, _static) {\n  return (0, _builder.default)("ClassPrivateProperty", ...arguments);\n}\n\nfunction classPrivateMethod(kind, key, params, body, _static) {\n  return (0, _builder.default)("ClassPrivateMethod", ...arguments);\n}\n\nfunction importAttribute(key, value) {\n  return (0, _builder.default)("ImportAttribute", ...arguments);\n}\n\nfunction decorator(expression) {\n  return (0, _builder.default)("Decorator", ...arguments);\n}\n\nfunction doExpression(body) {\n  return (0, _builder.default)("DoExpression", ...arguments);\n}\n\nfunction exportDefaultSpecifier(exported) {\n  return (0, _builder.default)("ExportDefaultSpecifier", ...arguments);\n}\n\nfunction privateName(id) {\n  return (0, _builder.default)("PrivateName", ...arguments);\n}\n\nfunction recordExpression(properties) {\n  return (0, _builder.default)("RecordExpression", ...arguments);\n}\n\nfunction tupleExpression(elements) {\n  return (0, _builder.default)("TupleExpression", ...arguments);\n}\n\nfunction decimalLiteral(value) {\n  return (0, _builder.default)("DecimalLiteral", ...arguments);\n}\n\nfunction staticBlock(body) {\n  return (0, _builder.default)("StaticBlock", ...arguments);\n}\n\nfunction tsParameterProperty(parameter) {\n  return (0, _builder.default)("TSParameterProperty", ...arguments);\n}\n\nfunction tsDeclareFunction(id, typeParameters, params, returnType) {\n  return (0, _builder.default)("TSDeclareFunction", ...arguments);\n}\n\nfunction tsDeclareMethod(decorators, key, typeParameters, params, returnType) {\n  return (0, _builder.default)("TSDeclareMethod", ...arguments);\n}\n\nfunction tsQualifiedName(left, right) {\n  return (0, _builder.default)("TSQualifiedName", ...arguments);\n}\n\nfunction tsCallSignatureDeclaration(typeParameters, parameters, typeAnnotation) {\n  return (0, _builder.default)("TSCallSignatureDeclaration", ...arguments);\n}\n\nfunction tsConstructSignatureDeclaration(typeParameters, parameters, typeAnnotation) {\n  return (0, _builder.default)("TSConstructSignatureDeclaration", ...arguments);\n}\n\nfunction tsPropertySignature(key, typeAnnotation, initializer) {\n  return (0, _builder.default)("TSPropertySignature", ...arguments);\n}\n\nfunction tsMethodSignature(key, typeParameters, parameters, typeAnnotation) {\n  return (0, _builder.default)("TSMethodSignature", ...arguments);\n}\n\nfunction tsIndexSignature(parameters, typeAnnotation) {\n  return (0, _builder.default)("TSIndexSignature", ...arguments);\n}\n\nfunction tsAnyKeyword() {\n  return (0, _builder.default)("TSAnyKeyword", ...arguments);\n}\n\nfunction tsBooleanKeyword() {\n  return (0, _builder.default)("TSBooleanKeyword", ...arguments);\n}\n\nfunction tsBigIntKeyword() {\n  return (0, _builder.default)("TSBigIntKeyword", ...arguments);\n}\n\nfunction tsIntrinsicKeyword() {\n  return (0, _builder.default)("TSIntrinsicKeyword", ...arguments);\n}\n\nfunction tsNeverKeyword() {\n  return (0, _builder.default)("TSNeverKeyword", ...arguments);\n}\n\nfunction tsNullKeyword() {\n  return (0, _builder.default)("TSNullKeyword", ...arguments);\n}\n\nfunction tsNumberKeyword() {\n  return (0, _builder.default)("TSNumberKeyword", ...arguments);\n}\n\nfunction tsObjectKeyword() {\n  return (0, _builder.default)("TSObjectKeyword", ...arguments);\n}\n\nfunction tsStringKeyword() {\n  return (0, _builder.default)("TSStringKeyword", ...arguments);\n}\n\nfunction tsSymbolKeyword() {\n  return (0, _builder.default)("TSSymbolKeyword", ...arguments);\n}\n\nfunction tsUndefinedKeyword() {\n  return (0, _builder.default)("TSUndefinedKeyword", ...arguments);\n}\n\nfunction tsUnknownKeyword() {\n  return (0, _builder.default)("TSUnknownKeyword", ...arguments);\n}\n\nfunction tsVoidKeyword() {\n  return (0, _builder.default)("TSVoidKeyword", ...arguments);\n}\n\nfunction tsThisType() {\n  return (0, _builder.default)("TSThisType", ...arguments);\n}\n\nfunction tsFunctionType(typeParameters, parameters, typeAnnotation) {\n  return (0, _builder.default)("TSFunctionType", ...arguments);\n}\n\nfunction tsConstructorType(typeParameters, parameters, typeAnnotation) {\n  return (0, _builder.default)("TSConstructorType", ...arguments);\n}\n\nfunction tsTypeReference(typeName, typeParameters) {\n  return (0, _builder.default)("TSTypeReference", ...arguments);\n}\n\nfunction tsTypePredicate(parameterName, typeAnnotation, asserts) {\n  return (0, _builder.default)("TSTypePredicate", ...arguments);\n}\n\nfunction tsTypeQuery(exprName) {\n  return (0, _builder.default)("TSTypeQuery", ...arguments);\n}\n\nfunction tsTypeLiteral(members) {\n  return (0, _builder.default)("TSTypeLiteral", ...arguments);\n}\n\nfunction tsArrayType(elementType) {\n  return (0, _builder.default)("TSArrayType", ...arguments);\n}\n\nfunction tsTupleType(elementTypes) {\n  return (0, _builder.default)("TSTupleType", ...arguments);\n}\n\nfunction tsOptionalType(typeAnnotation) {\n  return (0, _builder.default)("TSOptionalType", ...arguments);\n}\n\nfunction tsRestType(typeAnnotation) {\n  return (0, _builder.default)("TSRestType", ...arguments);\n}\n\nfunction tsNamedTupleMember(label, elementType, optional) {\n  return (0, _builder.default)("TSNamedTupleMember", ...arguments);\n}\n\nfunction tsUnionType(types) {\n  return (0, _builder.default)("TSUnionType", ...arguments);\n}\n\nfunction tsIntersectionType(types) {\n  return (0, _builder.default)("TSIntersectionType", ...arguments);\n}\n\nfunction tsConditionalType(checkType, extendsType, trueType, falseType) {\n  return (0, _builder.default)("TSConditionalType", ...arguments);\n}\n\nfunction tsInferType(typeParameter) {\n  return (0, _builder.default)("TSInferType", ...arguments);\n}\n\nfunction tsParenthesizedType(typeAnnotation) {\n  return (0, _builder.default)("TSParenthesizedType", ...arguments);\n}\n\nfunction tsTypeOperator(typeAnnotation) {\n  return (0, _builder.default)("TSTypeOperator", ...arguments);\n}\n\nfunction tsIndexedAccessType(objectType, indexType) {\n  return (0, _builder.default)("TSIndexedAccessType", ...arguments);\n}\n\nfunction tsMappedType(typeParameter, typeAnnotation, nameType) {\n  return (0, _builder.default)("TSMappedType", ...arguments);\n}\n\nfunction tsLiteralType(literal) {\n  return (0, _builder.default)("TSLiteralType", ...arguments);\n}\n\nfunction tsExpressionWithTypeArguments(expression, typeParameters) {\n  return (0, _builder.default)("TSExpressionWithTypeArguments", ...arguments);\n}\n\nfunction tsInterfaceDeclaration(id, typeParameters, _extends, body) {\n  return (0, _builder.default)("TSInterfaceDeclaration", ...arguments);\n}\n\nfunction tsInterfaceBody(body) {\n  return (0, _builder.default)("TSInterfaceBody", ...arguments);\n}\n\nfunction tsTypeAliasDeclaration(id, typeParameters, typeAnnotation) {\n  return (0, _builder.default)("TSTypeAliasDeclaration", ...arguments);\n}\n\nfunction tsAsExpression(expression, typeAnnotation) {\n  return (0, _builder.default)("TSAsExpression", ...arguments);\n}\n\nfunction tsTypeAssertion(typeAnnotation, expression) {\n  return (0, _builder.default)("TSTypeAssertion", ...arguments);\n}\n\nfunction tsEnumDeclaration(id, members) {\n  return (0, _builder.default)("TSEnumDeclaration", ...arguments);\n}\n\nfunction tsEnumMember(id, initializer) {\n  return (0, _builder.default)("TSEnumMember", ...arguments);\n}\n\nfunction tsModuleDeclaration(id, body) {\n  return (0, _builder.default)("TSModuleDeclaration", ...arguments);\n}\n\nfunction tsModuleBlock(body) {\n  return (0, _builder.default)("TSModuleBlock", ...arguments);\n}\n\nfunction tsImportType(argument, qualifier, typeParameters) {\n  return (0, _builder.default)("TSImportType", ...arguments);\n}\n\nfunction tsImportEqualsDeclaration(id, moduleReference) {\n  return (0, _builder.default)("TSImportEqualsDeclaration", ...arguments);\n}\n\nfunction tsExternalModuleReference(expression) {\n  return (0, _builder.default)("TSExternalModuleReference", ...arguments);\n}\n\nfunction tsNonNullExpression(expression) {\n  return (0, _builder.default)("TSNonNullExpression", ...arguments);\n}\n\nfunction tsExportAssignment(expression) {\n  return (0, _builder.default)("TSExportAssignment", ...arguments);\n}\n\nfunction tsNamespaceExportDeclaration(id) {\n  return (0, _builder.default)("TSNamespaceExportDeclaration", ...arguments);\n}\n\nfunction tsTypeAnnotation(typeAnnotation) {\n  return (0, _builder.default)("TSTypeAnnotation", ...arguments);\n}\n\nfunction tsTypeParameterInstantiation(params) {\n  return (0, _builder.default)("TSTypeParameterInstantiation", ...arguments);\n}\n\nfunction tsTypeParameterDeclaration(params) {\n  return (0, _builder.default)("TSTypeParameterDeclaration", ...arguments);\n}\n\nfunction tsTypeParameter(constraint, _default, name) {\n  return (0, _builder.default)("TSTypeParameter", ...arguments);\n}\n\nfunction NumberLiteral(...args) {\n  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");\n  return (0, _builder.default)("NumberLiteral", ...args);\n}\n\nfunction RegexLiteral(...args) {\n  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");\n  return (0, _builder.default)("RegexLiteral", ...args);\n}\n\nfunction RestProperty(...args) {\n  console.trace("The node type RestProperty has been renamed to RestElement");\n  return (0, _builder.default)("RestProperty", ...args);\n}\n\nfunction SpreadProperty(...args) {\n  console.trace("The node type SpreadProperty has been renamed to SpreadElement");\n  return (0, _builder.default)("SpreadProperty", ...args);\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/builders/generated/index.js?')},86104:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nObject.defineProperty(exports, "ArrayExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.arrayExpression;\n  }\n}));\nObject.defineProperty(exports, "AssignmentExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.assignmentExpression;\n  }\n}));\nObject.defineProperty(exports, "BinaryExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.binaryExpression;\n  }\n}));\nObject.defineProperty(exports, "InterpreterDirective", ({\n  enumerable: true,\n  get: function () {\n    return _index.interpreterDirective;\n  }\n}));\nObject.defineProperty(exports, "Directive", ({\n  enumerable: true,\n  get: function () {\n    return _index.directive;\n  }\n}));\nObject.defineProperty(exports, "DirectiveLiteral", ({\n  enumerable: true,\n  get: function () {\n    return _index.directiveLiteral;\n  }\n}));\nObject.defineProperty(exports, "BlockStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.blockStatement;\n  }\n}));\nObject.defineProperty(exports, "BreakStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.breakStatement;\n  }\n}));\nObject.defineProperty(exports, "CallExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.callExpression;\n  }\n}));\nObject.defineProperty(exports, "CatchClause", ({\n  enumerable: true,\n  get: function () {\n    return _index.catchClause;\n  }\n}));\nObject.defineProperty(exports, "ConditionalExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.conditionalExpression;\n  }\n}));\nObject.defineProperty(exports, "ContinueStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.continueStatement;\n  }\n}));\nObject.defineProperty(exports, "DebuggerStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.debuggerStatement;\n  }\n}));\nObject.defineProperty(exports, "DoWhileStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.doWhileStatement;\n  }\n}));\nObject.defineProperty(exports, "EmptyStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.emptyStatement;\n  }\n}));\nObject.defineProperty(exports, "ExpressionStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.expressionStatement;\n  }\n}));\nObject.defineProperty(exports, "File", ({\n  enumerable: true,\n  get: function () {\n    return _index.file;\n  }\n}));\nObject.defineProperty(exports, "ForInStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.forInStatement;\n  }\n}));\nObject.defineProperty(exports, "ForStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.forStatement;\n  }\n}));\nObject.defineProperty(exports, "FunctionDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.functionDeclaration;\n  }\n}));\nObject.defineProperty(exports, "FunctionExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.functionExpression;\n  }\n}));\nObject.defineProperty(exports, "Identifier", ({\n  enumerable: true,\n  get: function () {\n    return _index.identifier;\n  }\n}));\nObject.defineProperty(exports, "IfStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.ifStatement;\n  }\n}));\nObject.defineProperty(exports, "LabeledStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.labeledStatement;\n  }\n}));\nObject.defineProperty(exports, "StringLiteral", ({\n  enumerable: true,\n  get: function () {\n    return _index.stringLiteral;\n  }\n}));\nObject.defineProperty(exports, "NumericLiteral", ({\n  enumerable: true,\n  get: function () {\n    return _index.numericLiteral;\n  }\n}));\nObject.defineProperty(exports, "NullLiteral", ({\n  enumerable: true,\n  get: function () {\n    return _index.nullLiteral;\n  }\n}));\nObject.defineProperty(exports, "BooleanLiteral", ({\n  enumerable: true,\n  get: function () {\n    return _index.booleanLiteral;\n  }\n}));\nObject.defineProperty(exports, "RegExpLiteral", ({\n  enumerable: true,\n  get: function () {\n    return _index.regExpLiteral;\n  }\n}));\nObject.defineProperty(exports, "LogicalExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.logicalExpression;\n  }\n}));\nObject.defineProperty(exports, "MemberExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.memberExpression;\n  }\n}));\nObject.defineProperty(exports, "NewExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.newExpression;\n  }\n}));\nObject.defineProperty(exports, "Program", ({\n  enumerable: true,\n  get: function () {\n    return _index.program;\n  }\n}));\nObject.defineProperty(exports, "ObjectExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.objectExpression;\n  }\n}));\nObject.defineProperty(exports, "ObjectMethod", ({\n  enumerable: true,\n  get: function () {\n    return _index.objectMethod;\n  }\n}));\nObject.defineProperty(exports, "ObjectProperty", ({\n  enumerable: true,\n  get: function () {\n    return _index.objectProperty;\n  }\n}));\nObject.defineProperty(exports, "RestElement", ({\n  enumerable: true,\n  get: function () {\n    return _index.restElement;\n  }\n}));\nObject.defineProperty(exports, "ReturnStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.returnStatement;\n  }\n}));\nObject.defineProperty(exports, "SequenceExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.sequenceExpression;\n  }\n}));\nObject.defineProperty(exports, "ParenthesizedExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.parenthesizedExpression;\n  }\n}));\nObject.defineProperty(exports, "SwitchCase", ({\n  enumerable: true,\n  get: function () {\n    return _index.switchCase;\n  }\n}));\nObject.defineProperty(exports, "SwitchStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.switchStatement;\n  }\n}));\nObject.defineProperty(exports, "ThisExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.thisExpression;\n  }\n}));\nObject.defineProperty(exports, "ThrowStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.throwStatement;\n  }\n}));\nObject.defineProperty(exports, "TryStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.tryStatement;\n  }\n}));\nObject.defineProperty(exports, "UnaryExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.unaryExpression;\n  }\n}));\nObject.defineProperty(exports, "UpdateExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.updateExpression;\n  }\n}));\nObject.defineProperty(exports, "VariableDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.variableDeclaration;\n  }\n}));\nObject.defineProperty(exports, "VariableDeclarator", ({\n  enumerable: true,\n  get: function () {\n    return _index.variableDeclarator;\n  }\n}));\nObject.defineProperty(exports, "WhileStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.whileStatement;\n  }\n}));\nObject.defineProperty(exports, "WithStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.withStatement;\n  }\n}));\nObject.defineProperty(exports, "AssignmentPattern", ({\n  enumerable: true,\n  get: function () {\n    return _index.assignmentPattern;\n  }\n}));\nObject.defineProperty(exports, "ArrayPattern", ({\n  enumerable: true,\n  get: function () {\n    return _index.arrayPattern;\n  }\n}));\nObject.defineProperty(exports, "ArrowFunctionExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.arrowFunctionExpression;\n  }\n}));\nObject.defineProperty(exports, "ClassBody", ({\n  enumerable: true,\n  get: function () {\n    return _index.classBody;\n  }\n}));\nObject.defineProperty(exports, "ClassExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.classExpression;\n  }\n}));\nObject.defineProperty(exports, "ClassDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.classDeclaration;\n  }\n}));\nObject.defineProperty(exports, "ExportAllDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.exportAllDeclaration;\n  }\n}));\nObject.defineProperty(exports, "ExportDefaultDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.exportDefaultDeclaration;\n  }\n}));\nObject.defineProperty(exports, "ExportNamedDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.exportNamedDeclaration;\n  }\n}));\nObject.defineProperty(exports, "ExportSpecifier", ({\n  enumerable: true,\n  get: function () {\n    return _index.exportSpecifier;\n  }\n}));\nObject.defineProperty(exports, "ForOfStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.forOfStatement;\n  }\n}));\nObject.defineProperty(exports, "ImportDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.importDeclaration;\n  }\n}));\nObject.defineProperty(exports, "ImportDefaultSpecifier", ({\n  enumerable: true,\n  get: function () {\n    return _index.importDefaultSpecifier;\n  }\n}));\nObject.defineProperty(exports, "ImportNamespaceSpecifier", ({\n  enumerable: true,\n  get: function () {\n    return _index.importNamespaceSpecifier;\n  }\n}));\nObject.defineProperty(exports, "ImportSpecifier", ({\n  enumerable: true,\n  get: function () {\n    return _index.importSpecifier;\n  }\n}));\nObject.defineProperty(exports, "MetaProperty", ({\n  enumerable: true,\n  get: function () {\n    return _index.metaProperty;\n  }\n}));\nObject.defineProperty(exports, "ClassMethod", ({\n  enumerable: true,\n  get: function () {\n    return _index.classMethod;\n  }\n}));\nObject.defineProperty(exports, "ObjectPattern", ({\n  enumerable: true,\n  get: function () {\n    return _index.objectPattern;\n  }\n}));\nObject.defineProperty(exports, "SpreadElement", ({\n  enumerable: true,\n  get: function () {\n    return _index.spreadElement;\n  }\n}));\nObject.defineProperty(exports, "Super", ({\n  enumerable: true,\n  get: function () {\n    return _index.super;\n  }\n}));\nObject.defineProperty(exports, "TaggedTemplateExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.taggedTemplateExpression;\n  }\n}));\nObject.defineProperty(exports, "TemplateElement", ({\n  enumerable: true,\n  get: function () {\n    return _index.templateElement;\n  }\n}));\nObject.defineProperty(exports, "TemplateLiteral", ({\n  enumerable: true,\n  get: function () {\n    return _index.templateLiteral;\n  }\n}));\nObject.defineProperty(exports, "YieldExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.yieldExpression;\n  }\n}));\nObject.defineProperty(exports, "AwaitExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.awaitExpression;\n  }\n}));\nObject.defineProperty(exports, "Import", ({\n  enumerable: true,\n  get: function () {\n    return _index.import;\n  }\n}));\nObject.defineProperty(exports, "BigIntLiteral", ({\n  enumerable: true,\n  get: function () {\n    return _index.bigIntLiteral;\n  }\n}));\nObject.defineProperty(exports, "ExportNamespaceSpecifier", ({\n  enumerable: true,\n  get: function () {\n    return _index.exportNamespaceSpecifier;\n  }\n}));\nObject.defineProperty(exports, "OptionalMemberExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.optionalMemberExpression;\n  }\n}));\nObject.defineProperty(exports, "OptionalCallExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.optionalCallExpression;\n  }\n}));\nObject.defineProperty(exports, "AnyTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.anyTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "ArrayTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.arrayTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "BooleanTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.booleanTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "BooleanLiteralTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.booleanLiteralTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "NullLiteralTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.nullLiteralTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "ClassImplements", ({\n  enumerable: true,\n  get: function () {\n    return _index.classImplements;\n  }\n}));\nObject.defineProperty(exports, "DeclareClass", ({\n  enumerable: true,\n  get: function () {\n    return _index.declareClass;\n  }\n}));\nObject.defineProperty(exports, "DeclareFunction", ({\n  enumerable: true,\n  get: function () {\n    return _index.declareFunction;\n  }\n}));\nObject.defineProperty(exports, "DeclareInterface", ({\n  enumerable: true,\n  get: function () {\n    return _index.declareInterface;\n  }\n}));\nObject.defineProperty(exports, "DeclareModule", ({\n  enumerable: true,\n  get: function () {\n    return _index.declareModule;\n  }\n}));\nObject.defineProperty(exports, "DeclareModuleExports", ({\n  enumerable: true,\n  get: function () {\n    return _index.declareModuleExports;\n  }\n}));\nObject.defineProperty(exports, "DeclareTypeAlias", ({\n  enumerable: true,\n  get: function () {\n    return _index.declareTypeAlias;\n  }\n}));\nObject.defineProperty(exports, "DeclareOpaqueType", ({\n  enumerable: true,\n  get: function () {\n    return _index.declareOpaqueType;\n  }\n}));\nObject.defineProperty(exports, "DeclareVariable", ({\n  enumerable: true,\n  get: function () {\n    return _index.declareVariable;\n  }\n}));\nObject.defineProperty(exports, "DeclareExportDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.declareExportDeclaration;\n  }\n}));\nObject.defineProperty(exports, "DeclareExportAllDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.declareExportAllDeclaration;\n  }\n}));\nObject.defineProperty(exports, "DeclaredPredicate", ({\n  enumerable: true,\n  get: function () {\n    return _index.declaredPredicate;\n  }\n}));\nObject.defineProperty(exports, "ExistsTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.existsTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "FunctionTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.functionTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "FunctionTypeParam", ({\n  enumerable: true,\n  get: function () {\n    return _index.functionTypeParam;\n  }\n}));\nObject.defineProperty(exports, "GenericTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.genericTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "InferredPredicate", ({\n  enumerable: true,\n  get: function () {\n    return _index.inferredPredicate;\n  }\n}));\nObject.defineProperty(exports, "InterfaceExtends", ({\n  enumerable: true,\n  get: function () {\n    return _index.interfaceExtends;\n  }\n}));\nObject.defineProperty(exports, "InterfaceDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.interfaceDeclaration;\n  }\n}));\nObject.defineProperty(exports, "InterfaceTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.interfaceTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "IntersectionTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.intersectionTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "MixedTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.mixedTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "EmptyTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.emptyTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "NullableTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.nullableTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "NumberLiteralTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.numberLiteralTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "NumberTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.numberTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "ObjectTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.objectTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "ObjectTypeInternalSlot", ({\n  enumerable: true,\n  get: function () {\n    return _index.objectTypeInternalSlot;\n  }\n}));\nObject.defineProperty(exports, "ObjectTypeCallProperty", ({\n  enumerable: true,\n  get: function () {\n    return _index.objectTypeCallProperty;\n  }\n}));\nObject.defineProperty(exports, "ObjectTypeIndexer", ({\n  enumerable: true,\n  get: function () {\n    return _index.objectTypeIndexer;\n  }\n}));\nObject.defineProperty(exports, "ObjectTypeProperty", ({\n  enumerable: true,\n  get: function () {\n    return _index.objectTypeProperty;\n  }\n}));\nObject.defineProperty(exports, "ObjectTypeSpreadProperty", ({\n  enumerable: true,\n  get: function () {\n    return _index.objectTypeSpreadProperty;\n  }\n}));\nObject.defineProperty(exports, "OpaqueType", ({\n  enumerable: true,\n  get: function () {\n    return _index.opaqueType;\n  }\n}));\nObject.defineProperty(exports, "QualifiedTypeIdentifier", ({\n  enumerable: true,\n  get: function () {\n    return _index.qualifiedTypeIdentifier;\n  }\n}));\nObject.defineProperty(exports, "StringLiteralTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.stringLiteralTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "StringTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.stringTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "SymbolTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.symbolTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "ThisTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.thisTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "TupleTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.tupleTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "TypeofTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.typeofTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "TypeAlias", ({\n  enumerable: true,\n  get: function () {\n    return _index.typeAlias;\n  }\n}));\nObject.defineProperty(exports, "TypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.typeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "TypeCastExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.typeCastExpression;\n  }\n}));\nObject.defineProperty(exports, "TypeParameter", ({\n  enumerable: true,\n  get: function () {\n    return _index.typeParameter;\n  }\n}));\nObject.defineProperty(exports, "TypeParameterDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.typeParameterDeclaration;\n  }\n}));\nObject.defineProperty(exports, "TypeParameterInstantiation", ({\n  enumerable: true,\n  get: function () {\n    return _index.typeParameterInstantiation;\n  }\n}));\nObject.defineProperty(exports, "UnionTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.unionTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "Variance", ({\n  enumerable: true,\n  get: function () {\n    return _index.variance;\n  }\n}));\nObject.defineProperty(exports, "VoidTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.voidTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "EnumDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.enumDeclaration;\n  }\n}));\nObject.defineProperty(exports, "EnumBooleanBody", ({\n  enumerable: true,\n  get: function () {\n    return _index.enumBooleanBody;\n  }\n}));\nObject.defineProperty(exports, "EnumNumberBody", ({\n  enumerable: true,\n  get: function () {\n    return _index.enumNumberBody;\n  }\n}));\nObject.defineProperty(exports, "EnumStringBody", ({\n  enumerable: true,\n  get: function () {\n    return _index.enumStringBody;\n  }\n}));\nObject.defineProperty(exports, "EnumSymbolBody", ({\n  enumerable: true,\n  get: function () {\n    return _index.enumSymbolBody;\n  }\n}));\nObject.defineProperty(exports, "EnumBooleanMember", ({\n  enumerable: true,\n  get: function () {\n    return _index.enumBooleanMember;\n  }\n}));\nObject.defineProperty(exports, "EnumNumberMember", ({\n  enumerable: true,\n  get: function () {\n    return _index.enumNumberMember;\n  }\n}));\nObject.defineProperty(exports, "EnumStringMember", ({\n  enumerable: true,\n  get: function () {\n    return _index.enumStringMember;\n  }\n}));\nObject.defineProperty(exports, "EnumDefaultedMember", ({\n  enumerable: true,\n  get: function () {\n    return _index.enumDefaultedMember;\n  }\n}));\nObject.defineProperty(exports, "JSXAttribute", ({\n  enumerable: true,\n  get: function () {\n    return _index.jsxAttribute;\n  }\n}));\nObject.defineProperty(exports, "JSXClosingElement", ({\n  enumerable: true,\n  get: function () {\n    return _index.jsxClosingElement;\n  }\n}));\nObject.defineProperty(exports, "JSXElement", ({\n  enumerable: true,\n  get: function () {\n    return _index.jsxElement;\n  }\n}));\nObject.defineProperty(exports, "JSXEmptyExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.jsxEmptyExpression;\n  }\n}));\nObject.defineProperty(exports, "JSXExpressionContainer", ({\n  enumerable: true,\n  get: function () {\n    return _index.jsxExpressionContainer;\n  }\n}));\nObject.defineProperty(exports, "JSXSpreadChild", ({\n  enumerable: true,\n  get: function () {\n    return _index.jsxSpreadChild;\n  }\n}));\nObject.defineProperty(exports, "JSXIdentifier", ({\n  enumerable: true,\n  get: function () {\n    return _index.jsxIdentifier;\n  }\n}));\nObject.defineProperty(exports, "JSXMemberExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.jsxMemberExpression;\n  }\n}));\nObject.defineProperty(exports, "JSXNamespacedName", ({\n  enumerable: true,\n  get: function () {\n    return _index.jsxNamespacedName;\n  }\n}));\nObject.defineProperty(exports, "JSXOpeningElement", ({\n  enumerable: true,\n  get: function () {\n    return _index.jsxOpeningElement;\n  }\n}));\nObject.defineProperty(exports, "JSXSpreadAttribute", ({\n  enumerable: true,\n  get: function () {\n    return _index.jsxSpreadAttribute;\n  }\n}));\nObject.defineProperty(exports, "JSXText", ({\n  enumerable: true,\n  get: function () {\n    return _index.jsxText;\n  }\n}));\nObject.defineProperty(exports, "JSXFragment", ({\n  enumerable: true,\n  get: function () {\n    return _index.jsxFragment;\n  }\n}));\nObject.defineProperty(exports, "JSXOpeningFragment", ({\n  enumerable: true,\n  get: function () {\n    return _index.jsxOpeningFragment;\n  }\n}));\nObject.defineProperty(exports, "JSXClosingFragment", ({\n  enumerable: true,\n  get: function () {\n    return _index.jsxClosingFragment;\n  }\n}));\nObject.defineProperty(exports, "Noop", ({\n  enumerable: true,\n  get: function () {\n    return _index.noop;\n  }\n}));\nObject.defineProperty(exports, "Placeholder", ({\n  enumerable: true,\n  get: function () {\n    return _index.placeholder;\n  }\n}));\nObject.defineProperty(exports, "V8IntrinsicIdentifier", ({\n  enumerable: true,\n  get: function () {\n    return _index.v8IntrinsicIdentifier;\n  }\n}));\nObject.defineProperty(exports, "ArgumentPlaceholder", ({\n  enumerable: true,\n  get: function () {\n    return _index.argumentPlaceholder;\n  }\n}));\nObject.defineProperty(exports, "BindExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.bindExpression;\n  }\n}));\nObject.defineProperty(exports, "ClassProperty", ({\n  enumerable: true,\n  get: function () {\n    return _index.classProperty;\n  }\n}));\nObject.defineProperty(exports, "PipelineTopicExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.pipelineTopicExpression;\n  }\n}));\nObject.defineProperty(exports, "PipelineBareFunction", ({\n  enumerable: true,\n  get: function () {\n    return _index.pipelineBareFunction;\n  }\n}));\nObject.defineProperty(exports, "PipelinePrimaryTopicReference", ({\n  enumerable: true,\n  get: function () {\n    return _index.pipelinePrimaryTopicReference;\n  }\n}));\nObject.defineProperty(exports, "ClassPrivateProperty", ({\n  enumerable: true,\n  get: function () {\n    return _index.classPrivateProperty;\n  }\n}));\nObject.defineProperty(exports, "ClassPrivateMethod", ({\n  enumerable: true,\n  get: function () {\n    return _index.classPrivateMethod;\n  }\n}));\nObject.defineProperty(exports, "ImportAttribute", ({\n  enumerable: true,\n  get: function () {\n    return _index.importAttribute;\n  }\n}));\nObject.defineProperty(exports, "Decorator", ({\n  enumerable: true,\n  get: function () {\n    return _index.decorator;\n  }\n}));\nObject.defineProperty(exports, "DoExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.doExpression;\n  }\n}));\nObject.defineProperty(exports, "ExportDefaultSpecifier", ({\n  enumerable: true,\n  get: function () {\n    return _index.exportDefaultSpecifier;\n  }\n}));\nObject.defineProperty(exports, "PrivateName", ({\n  enumerable: true,\n  get: function () {\n    return _index.privateName;\n  }\n}));\nObject.defineProperty(exports, "RecordExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.recordExpression;\n  }\n}));\nObject.defineProperty(exports, "TupleExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.tupleExpression;\n  }\n}));\nObject.defineProperty(exports, "DecimalLiteral", ({\n  enumerable: true,\n  get: function () {\n    return _index.decimalLiteral;\n  }\n}));\nObject.defineProperty(exports, "StaticBlock", ({\n  enumerable: true,\n  get: function () {\n    return _index.staticBlock;\n  }\n}));\nObject.defineProperty(exports, "TSParameterProperty", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsParameterProperty;\n  }\n}));\nObject.defineProperty(exports, "TSDeclareFunction", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsDeclareFunction;\n  }\n}));\nObject.defineProperty(exports, "TSDeclareMethod", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsDeclareMethod;\n  }\n}));\nObject.defineProperty(exports, "TSQualifiedName", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsQualifiedName;\n  }\n}));\nObject.defineProperty(exports, "TSCallSignatureDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsCallSignatureDeclaration;\n  }\n}));\nObject.defineProperty(exports, "TSConstructSignatureDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsConstructSignatureDeclaration;\n  }\n}));\nObject.defineProperty(exports, "TSPropertySignature", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsPropertySignature;\n  }\n}));\nObject.defineProperty(exports, "TSMethodSignature", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsMethodSignature;\n  }\n}));\nObject.defineProperty(exports, "TSIndexSignature", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsIndexSignature;\n  }\n}));\nObject.defineProperty(exports, "TSAnyKeyword", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsAnyKeyword;\n  }\n}));\nObject.defineProperty(exports, "TSBooleanKeyword", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsBooleanKeyword;\n  }\n}));\nObject.defineProperty(exports, "TSBigIntKeyword", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsBigIntKeyword;\n  }\n}));\nObject.defineProperty(exports, "TSIntrinsicKeyword", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsIntrinsicKeyword;\n  }\n}));\nObject.defineProperty(exports, "TSNeverKeyword", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsNeverKeyword;\n  }\n}));\nObject.defineProperty(exports, "TSNullKeyword", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsNullKeyword;\n  }\n}));\nObject.defineProperty(exports, "TSNumberKeyword", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsNumberKeyword;\n  }\n}));\nObject.defineProperty(exports, "TSObjectKeyword", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsObjectKeyword;\n  }\n}));\nObject.defineProperty(exports, "TSStringKeyword", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsStringKeyword;\n  }\n}));\nObject.defineProperty(exports, "TSSymbolKeyword", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsSymbolKeyword;\n  }\n}));\nObject.defineProperty(exports, "TSUndefinedKeyword", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsUndefinedKeyword;\n  }\n}));\nObject.defineProperty(exports, "TSUnknownKeyword", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsUnknownKeyword;\n  }\n}));\nObject.defineProperty(exports, "TSVoidKeyword", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsVoidKeyword;\n  }\n}));\nObject.defineProperty(exports, "TSThisType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsThisType;\n  }\n}));\nObject.defineProperty(exports, "TSFunctionType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsFunctionType;\n  }\n}));\nObject.defineProperty(exports, "TSConstructorType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsConstructorType;\n  }\n}));\nObject.defineProperty(exports, "TSTypeReference", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsTypeReference;\n  }\n}));\nObject.defineProperty(exports, "TSTypePredicate", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsTypePredicate;\n  }\n}));\nObject.defineProperty(exports, "TSTypeQuery", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsTypeQuery;\n  }\n}));\nObject.defineProperty(exports, "TSTypeLiteral", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsTypeLiteral;\n  }\n}));\nObject.defineProperty(exports, "TSArrayType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsArrayType;\n  }\n}));\nObject.defineProperty(exports, "TSTupleType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsTupleType;\n  }\n}));\nObject.defineProperty(exports, "TSOptionalType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsOptionalType;\n  }\n}));\nObject.defineProperty(exports, "TSRestType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsRestType;\n  }\n}));\nObject.defineProperty(exports, "TSNamedTupleMember", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsNamedTupleMember;\n  }\n}));\nObject.defineProperty(exports, "TSUnionType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsUnionType;\n  }\n}));\nObject.defineProperty(exports, "TSIntersectionType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsIntersectionType;\n  }\n}));\nObject.defineProperty(exports, "TSConditionalType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsConditionalType;\n  }\n}));\nObject.defineProperty(exports, "TSInferType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsInferType;\n  }\n}));\nObject.defineProperty(exports, "TSParenthesizedType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsParenthesizedType;\n  }\n}));\nObject.defineProperty(exports, "TSTypeOperator", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsTypeOperator;\n  }\n}));\nObject.defineProperty(exports, "TSIndexedAccessType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsIndexedAccessType;\n  }\n}));\nObject.defineProperty(exports, "TSMappedType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsMappedType;\n  }\n}));\nObject.defineProperty(exports, "TSLiteralType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsLiteralType;\n  }\n}));\nObject.defineProperty(exports, "TSExpressionWithTypeArguments", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsExpressionWithTypeArguments;\n  }\n}));\nObject.defineProperty(exports, "TSInterfaceDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsInterfaceDeclaration;\n  }\n}));\nObject.defineProperty(exports, "TSInterfaceBody", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsInterfaceBody;\n  }\n}));\nObject.defineProperty(exports, "TSTypeAliasDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsTypeAliasDeclaration;\n  }\n}));\nObject.defineProperty(exports, "TSAsExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsAsExpression;\n  }\n}));\nObject.defineProperty(exports, "TSTypeAssertion", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsTypeAssertion;\n  }\n}));\nObject.defineProperty(exports, "TSEnumDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsEnumDeclaration;\n  }\n}));\nObject.defineProperty(exports, "TSEnumMember", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsEnumMember;\n  }\n}));\nObject.defineProperty(exports, "TSModuleDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsModuleDeclaration;\n  }\n}));\nObject.defineProperty(exports, "TSModuleBlock", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsModuleBlock;\n  }\n}));\nObject.defineProperty(exports, "TSImportType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsImportType;\n  }\n}));\nObject.defineProperty(exports, "TSImportEqualsDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsImportEqualsDeclaration;\n  }\n}));\nObject.defineProperty(exports, "TSExternalModuleReference", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsExternalModuleReference;\n  }\n}));\nObject.defineProperty(exports, "TSNonNullExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsNonNullExpression;\n  }\n}));\nObject.defineProperty(exports, "TSExportAssignment", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsExportAssignment;\n  }\n}));\nObject.defineProperty(exports, "TSNamespaceExportDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsNamespaceExportDeclaration;\n  }\n}));\nObject.defineProperty(exports, "TSTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "TSTypeParameterInstantiation", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsTypeParameterInstantiation;\n  }\n}));\nObject.defineProperty(exports, "TSTypeParameterDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsTypeParameterDeclaration;\n  }\n}));\nObject.defineProperty(exports, "TSTypeParameter", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsTypeParameter;\n  }\n}));\nObject.defineProperty(exports, "NumberLiteral", ({\n  enumerable: true,\n  get: function () {\n    return _index.numberLiteral;\n  }\n}));\nObject.defineProperty(exports, "RegexLiteral", ({\n  enumerable: true,\n  get: function () {\n    return _index.regexLiteral;\n  }\n}));\nObject.defineProperty(exports, "RestProperty", ({\n  enumerable: true,\n  get: function () {\n    return _index.restProperty;\n  }\n}));\nObject.defineProperty(exports, "SpreadProperty", ({\n  enumerable: true,\n  get: function () {\n    return _index.spreadProperty;\n  }\n}));\n\nvar _index = __webpack_require__(34391);\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/builders/generated/uppercase.js?')},88478:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = buildChildren;\n\nvar _generated = __webpack_require__(94746);\n\nvar _cleanJSXElementLiteralChild = _interopRequireDefault(__webpack_require__(15835));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction buildChildren(node) {\n  const elements = [];\n\n  for (let i = 0; i < node.children.length; i++) {\n    let child = node.children[i];\n\n    if ((0, _generated.isJSXText)(child)) {\n      (0, _cleanJSXElementLiteralChild.default)(child, elements);\n      continue;\n    }\n\n    if ((0, _generated.isJSXExpressionContainer)(child)) child = child.expression;\n    if ((0, _generated.isJSXEmptyExpression)(child)) continue;\n    elements.push(child);\n  }\n\n  return elements;\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/builders/react/buildChildren.js?')},4571:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = createTSUnionType;\n\nvar _generated = __webpack_require__(34391);\n\nvar _removeTypeDuplicates = _interopRequireDefault(__webpack_require__(71954));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction createTSUnionType(typeAnnotations) {\n  const types = typeAnnotations.map(type => type.typeAnnotation);\n  const flattened = (0, _removeTypeDuplicates.default)(types);\n\n  if (flattened.length === 1) {\n    return flattened[0];\n  } else {\n    return (0, _generated.tsUnionType)(flattened);\n  }\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js?')},92363:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = clone;\n\nvar _cloneNode = _interopRequireDefault(__webpack_require__(46209));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction clone(node) {\n  return (0, _cloneNode.default)(node, false);\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/clone/clone.js?')},96953:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = cloneDeep;\n\nvar _cloneNode = _interopRequireDefault(__webpack_require__(46209));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction cloneDeep(node) {\n  return (0, _cloneNode.default)(node);\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/clone/cloneDeep.js?')},90863:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = cloneDeepWithoutLoc;\n\nvar _cloneNode = _interopRequireDefault(__webpack_require__(46209));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction cloneDeepWithoutLoc(node) {\n  return (0, _cloneNode.default)(node, true, true);\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js?')},46209:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = cloneNode;\n\nvar _definitions = __webpack_require__(46507);\n\nvar _generated = __webpack_require__(94746);\n\nconst has = Function.call.bind(Object.prototype.hasOwnProperty);\n\nfunction cloneIfNode(obj, deep, withoutLoc) {\n  if (obj && typeof obj.type === "string") {\n    return cloneNode(obj, deep, withoutLoc);\n  }\n\n  return obj;\n}\n\nfunction cloneIfNodeOrArray(obj, deep, withoutLoc) {\n  if (Array.isArray(obj)) {\n    return obj.map(node => cloneIfNode(node, deep, withoutLoc));\n  }\n\n  return cloneIfNode(obj, deep, withoutLoc);\n}\n\nfunction cloneNode(node, deep = true, withoutLoc = false) {\n  if (!node) return node;\n  const {\n    type\n  } = node;\n  const newNode = {\n    type: node.type\n  };\n\n  if ((0, _generated.isIdentifier)(node)) {\n    newNode.name = node.name;\n\n    if (has(node, "optional") && typeof node.optional === "boolean") {\n      newNode.optional = node.optional;\n    }\n\n    if (has(node, "typeAnnotation")) {\n      newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc) : node.typeAnnotation;\n    }\n  } else if (!has(_definitions.NODE_FIELDS, type)) {\n    throw new Error(`Unknown node type: "${type}"`);\n  } else {\n    for (const field of Object.keys(_definitions.NODE_FIELDS[type])) {\n      if (has(node, field)) {\n        if (deep) {\n          newNode[field] = (0, _generated.isFile)(node) && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc) : cloneIfNodeOrArray(node[field], true, withoutLoc);\n        } else {\n          newNode[field] = node[field];\n        }\n      }\n    }\n  }\n\n  if (has(node, "loc")) {\n    if (withoutLoc) {\n      newNode.loc = null;\n    } else {\n      newNode.loc = node.loc;\n    }\n  }\n\n  if (has(node, "leadingComments")) {\n    newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc);\n  }\n\n  if (has(node, "innerComments")) {\n    newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc);\n  }\n\n  if (has(node, "trailingComments")) {\n    newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc);\n  }\n\n  if (has(node, "extra")) {\n    newNode.extra = Object.assign({}, node.extra);\n  }\n\n  return newNode;\n}\n\nfunction cloneCommentsWithoutLoc(comments) {\n  return comments.map(({\n    type,\n    value\n  }) => ({\n    type,\n    value,\n    loc: null\n  }));\n}\n\nfunction maybeCloneComments(comments, deep, withoutLoc) {\n  return deep && withoutLoc ? cloneCommentsWithoutLoc(comments) : comments;\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/clone/cloneNode.js?')},30748:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = cloneWithoutLoc;\n\nvar _cloneNode = _interopRequireDefault(__webpack_require__(46209));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction cloneWithoutLoc(node) {\n  return (0, _cloneNode.default)(node, false, true);\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/clone/cloneWithoutLoc.js?')},99529:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = addComment;\n\nvar _addComments = _interopRequireDefault(__webpack_require__(96182));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction addComment(node, type, content, line) {\n  return (0, _addComments.default)(node, type, [{\n    type: line ? "CommentLine" : "CommentBlock",\n    value: content\n  }]);\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/comments/addComment.js?')},96182:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = addComments;\n\nfunction addComments(node, type, comments) {\n  if (!comments || !node) return node;\n  const key = `${type}Comments`;\n\n  if (node[key]) {\n    if (type === "leading") {\n      node[key] = comments.concat(node[key]);\n    } else {\n      node[key] = node[key].concat(comments);\n    }\n  } else {\n    node[key] = comments;\n  }\n\n  return node;\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/comments/addComments.js?')},6455:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = inheritInnerComments;\n\nvar _inherit = _interopRequireDefault(__webpack_require__(8834));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction inheritInnerComments(child, parent) {\n  (0, _inherit.default)("innerComments", child, parent);\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/comments/inheritInnerComments.js?')},91835:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = inheritLeadingComments;\n\nvar _inherit = _interopRequireDefault(__webpack_require__(8834));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction inheritLeadingComments(child, parent) {\n  (0, _inherit.default)("leadingComments", child, parent);\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/comments/inheritLeadingComments.js?')},59653:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = inheritTrailingComments;\n\nvar _inherit = _interopRequireDefault(__webpack_require__(8834));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction inheritTrailingComments(child, parent) {\n  (0, _inherit.default)("trailingComments", child, parent);\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/comments/inheritTrailingComments.js?')},29564:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = inheritsComments;\n\nvar _inheritTrailingComments = _interopRequireDefault(__webpack_require__(59653));\n\nvar _inheritLeadingComments = _interopRequireDefault(__webpack_require__(91835));\n\nvar _inheritInnerComments = _interopRequireDefault(__webpack_require__(6455));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction inheritsComments(child, parent) {\n  (0, _inheritTrailingComments.default)(child, parent);\n  (0, _inheritLeadingComments.default)(child, parent);\n  (0, _inheritInnerComments.default)(child, parent);\n  return child;\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/comments/inheritsComments.js?')},91200:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = removeComments;\n\nvar _constants = __webpack_require__(36325);\n\nfunction removeComments(node) {\n  _constants.COMMENT_KEYS.forEach(key => {\n    node[key] = null;\n  });\n\n  return node;\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/comments/removeComments.js?')},18267:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.TSBASETYPE_TYPES = exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.PRIVATE_TYPES = exports.JSX_TYPES = exports.ENUMMEMBER_TYPES = exports.ENUMBODY_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.FLOWTYPE_TYPES = exports.FLOW_TYPES = exports.MODULESPECIFIER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.MODULEDECLARATION_TYPES = exports.CLASS_TYPES = exports.PATTERN_TYPES = exports.UNARYLIKE_TYPES = exports.PROPERTY_TYPES = exports.OBJECTMEMBER_TYPES = exports.METHOD_TYPES = exports.USERWHITESPACABLE_TYPES = exports.IMMUTABLE_TYPES = exports.LITERAL_TYPES = exports.TSENTITYNAME_TYPES = exports.LVAL_TYPES = exports.PATTERNLIKE_TYPES = exports.DECLARATION_TYPES = exports.PUREISH_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FUNCTION_TYPES = exports.FORXSTATEMENT_TYPES = exports.FOR_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.WHILE_TYPES = exports.LOOP_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.SCOPABLE_TYPES = exports.BINARY_TYPES = exports.EXPRESSION_TYPES = void 0;\n\nvar _definitions = __webpack_require__(46507);\n\nconst EXPRESSION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Expression"];\nexports.EXPRESSION_TYPES = EXPRESSION_TYPES;\nconst BINARY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Binary"];\nexports.BINARY_TYPES = BINARY_TYPES;\nconst SCOPABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Scopable"];\nexports.SCOPABLE_TYPES = SCOPABLE_TYPES;\nconst BLOCKPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["BlockParent"];\nexports.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;\nconst BLOCK_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Block"];\nexports.BLOCK_TYPES = BLOCK_TYPES;\nconst STATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Statement"];\nexports.STATEMENT_TYPES = STATEMENT_TYPES;\nconst TERMINATORLESS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Terminatorless"];\nexports.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;\nconst COMPLETIONSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["CompletionStatement"];\nexports.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;\nconst CONDITIONAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Conditional"];\nexports.CONDITIONAL_TYPES = CONDITIONAL_TYPES;\nconst LOOP_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Loop"];\nexports.LOOP_TYPES = LOOP_TYPES;\nconst WHILE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["While"];\nexports.WHILE_TYPES = WHILE_TYPES;\nconst EXPRESSIONWRAPPER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];\nexports.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;\nconst FOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS["For"];\nexports.FOR_TYPES = FOR_TYPES;\nconst FORXSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ForXStatement"];\nexports.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;\nconst FUNCTION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Function"];\nexports.FUNCTION_TYPES = FUNCTION_TYPES;\nconst FUNCTIONPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FunctionParent"];\nexports.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;\nconst PUREISH_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pureish"];\nexports.PUREISH_TYPES = PUREISH_TYPES;\nconst DECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Declaration"];\nexports.DECLARATION_TYPES = DECLARATION_TYPES;\nconst PATTERNLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["PatternLike"];\nexports.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;\nconst LVAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["LVal"];\nexports.LVAL_TYPES = LVAL_TYPES;\nconst TSENTITYNAME_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSEntityName"];\nexports.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;\nconst LITERAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Literal"];\nexports.LITERAL_TYPES = LITERAL_TYPES;\nconst IMMUTABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Immutable"];\nexports.IMMUTABLE_TYPES = IMMUTABLE_TYPES;\nconst USERWHITESPACABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UserWhitespacable"];\nexports.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;\nconst METHOD_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Method"];\nexports.METHOD_TYPES = METHOD_TYPES;\nconst OBJECTMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ObjectMember"];\nexports.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;\nconst PROPERTY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Property"];\nexports.PROPERTY_TYPES = PROPERTY_TYPES;\nconst UNARYLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UnaryLike"];\nexports.UNARYLIKE_TYPES = UNARYLIKE_TYPES;\nconst PATTERN_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pattern"];\nexports.PATTERN_TYPES = PATTERN_TYPES;\nconst CLASS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Class"];\nexports.CLASS_TYPES = CLASS_TYPES;\nconst MODULEDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleDeclaration"];\nexports.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;\nconst EXPORTDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExportDeclaration"];\nexports.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;\nconst MODULESPECIFIER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];\nexports.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;\nconst FLOW_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Flow"];\nexports.FLOW_TYPES = FLOW_TYPES;\nconst FLOWTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowType"];\nexports.FLOWTYPE_TYPES = FLOWTYPE_TYPES;\nconst FLOWBASEANNOTATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];\nexports.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;\nconst FLOWDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowDeclaration"];\nexports.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;\nconst FLOWPREDICATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowPredicate"];\nexports.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;\nconst ENUMBODY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["EnumBody"];\nexports.ENUMBODY_TYPES = ENUMBODY_TYPES;\nconst ENUMMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["EnumMember"];\nexports.ENUMMEMBER_TYPES = ENUMMEMBER_TYPES;\nconst JSX_TYPES = _definitions.FLIPPED_ALIAS_KEYS["JSX"];\nexports.JSX_TYPES = JSX_TYPES;\nconst PRIVATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Private"];\nexports.PRIVATE_TYPES = PRIVATE_TYPES;\nconst TSTYPEELEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSTypeElement"];\nexports.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;\nconst TSTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSType"];\nexports.TSTYPE_TYPES = TSTYPE_TYPES;\nconst TSBASETYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSBaseType"];\nexports.TSBASETYPE_TYPES = TSBASETYPE_TYPES;\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/constants/generated/index.js?')},36325:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.NOT_LOCAL_BINDING = exports.BLOCK_SCOPED_SYMBOL = exports.INHERIT_KEYS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = exports.ASSIGNMENT_OPERATORS = exports.BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.UPDATE_OPERATORS = exports.LOGICAL_OPERATORS = exports.COMMENT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = void 0;\nconst STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];\nexports.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS;\nconst FLATTENABLE_KEYS = ["body", "expressions"];\nexports.FLATTENABLE_KEYS = FLATTENABLE_KEYS;\nconst FOR_INIT_KEYS = ["left", "init"];\nexports.FOR_INIT_KEYS = FOR_INIT_KEYS;\nconst COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];\nexports.COMMENT_KEYS = COMMENT_KEYS;\nconst LOGICAL_OPERATORS = ["||", "&&", "??"];\nexports.LOGICAL_OPERATORS = LOGICAL_OPERATORS;\nconst UPDATE_OPERATORS = ["++", "--"];\nexports.UPDATE_OPERATORS = UPDATE_OPERATORS;\nconst BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];\nexports.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;\nconst EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];\nexports.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;\nconst COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, "in", "instanceof"];\nexports.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;\nconst BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS];\nexports.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;\nconst NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];\nexports.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;\nconst BINARY_OPERATORS = ["+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS];\nexports.BINARY_OPERATORS = BINARY_OPERATORS;\nconst ASSIGNMENT_OPERATORS = ["=", "+=", ...NUMBER_BINARY_OPERATORS.map(op => op + "="), ...LOGICAL_OPERATORS.map(op => op + "=")];\nexports.ASSIGNMENT_OPERATORS = ASSIGNMENT_OPERATORS;\nconst BOOLEAN_UNARY_OPERATORS = ["delete", "!"];\nexports.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;\nconst NUMBER_UNARY_OPERATORS = ["+", "-", "~"];\nexports.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;\nconst STRING_UNARY_OPERATORS = ["typeof"];\nexports.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;\nconst UNARY_OPERATORS = ["void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];\nexports.UNARY_OPERATORS = UNARY_OPERATORS;\nconst INHERIT_KEYS = {\n  optional: ["typeAnnotation", "typeParameters", "returnType"],\n  force: ["start", "loc", "end"]\n};\nexports.INHERIT_KEYS = INHERIT_KEYS;\nconst BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");\nexports.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;\nconst NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");\nexports.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/constants/index.js?')},44315:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = ensureBlock;\n\nvar _toBlock = _interopRequireDefault(__webpack_require__(19276));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ensureBlock(node, key = "body") {\n  return node[key] = (0, _toBlock.default)(node[key], node);\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/converters/ensureBlock.js?')},20696:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = gatherSequenceExpressions;\n\nvar _getBindingIdentifiers = _interopRequireDefault(__webpack_require__(1477));\n\nvar _generated = __webpack_require__(94746);\n\nvar _generated2 = __webpack_require__(34391);\n\nvar _cloneNode = _interopRequireDefault(__webpack_require__(46209));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction gatherSequenceExpressions(nodes, scope, declars) {\n  const exprs = [];\n  let ensureLastUndefined = true;\n\n  for (const node of nodes) {\n    if (!(0, _generated.isEmptyStatement)(node)) {\n      ensureLastUndefined = false;\n    }\n\n    if ((0, _generated.isExpression)(node)) {\n      exprs.push(node);\n    } else if ((0, _generated.isExpressionStatement)(node)) {\n      exprs.push(node.expression);\n    } else if ((0, _generated.isVariableDeclaration)(node)) {\n      if (node.kind !== "var") return;\n\n      for (const declar of node.declarations) {\n        const bindings = (0, _getBindingIdentifiers.default)(declar);\n\n        for (const key of Object.keys(bindings)) {\n          declars.push({\n            kind: node.kind,\n            id: (0, _cloneNode.default)(bindings[key])\n          });\n        }\n\n        if (declar.init) {\n          exprs.push((0, _generated2.assignmentExpression)("=", declar.id, declar.init));\n        }\n      }\n\n      ensureLastUndefined = true;\n    } else if ((0, _generated.isIfStatement)(node)) {\n      const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode();\n      const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();\n      if (!consequent || !alternate) return;\n      exprs.push((0, _generated2.conditionalExpression)(node.test, consequent, alternate));\n    } else if ((0, _generated.isBlockStatement)(node)) {\n      const body = gatherSequenceExpressions(node.body, scope, declars);\n      if (!body) return;\n      exprs.push(body);\n    } else if ((0, _generated.isEmptyStatement)(node)) {\n      if (nodes.indexOf(node) === 0) {\n        ensureLastUndefined = true;\n      }\n    } else {\n      return;\n    }\n  }\n\n  if (ensureLastUndefined) {\n    exprs.push(scope.buildUndefinedNode());\n  }\n\n  if (exprs.length === 1) {\n    return exprs[0];\n  } else {\n    return (0, _generated2.sequenceExpression)(exprs);\n  }\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js?')},28316:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = toBindingIdentifierName;\n\nvar _toIdentifier = _interopRequireDefault(__webpack_require__(71309));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction toBindingIdentifierName(name) {\n  name = (0, _toIdentifier.default)(name);\n  if (name === "eval" || name === "arguments") name = "_" + name;\n  return name;\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/converters/toBindingIdentifierName.js?')},19276:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = toBlock;\n\nvar _generated = __webpack_require__(94746);\n\nvar _generated2 = __webpack_require__(34391);\n\nfunction toBlock(node, parent) {\n  if ((0, _generated.isBlockStatement)(node)) {\n    return node;\n  }\n\n  let blockNodes = [];\n\n  if ((0, _generated.isEmptyStatement)(node)) {\n    blockNodes = [];\n  } else {\n    if (!(0, _generated.isStatement)(node)) {\n      if ((0, _generated.isFunction)(parent)) {\n        node = (0, _generated2.returnStatement)(node);\n      } else {\n        node = (0, _generated2.expressionStatement)(node);\n      }\n    }\n\n    blockNodes = [node];\n  }\n\n  return (0, _generated2.blockStatement)(blockNodes);\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/converters/toBlock.js?')},59434:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = toComputedKey;\n\nvar _generated = __webpack_require__(94746);\n\nvar _generated2 = __webpack_require__(34391);\n\nfunction toComputedKey(node, key = node.key || node.property) {\n  if (!node.computed && (0, _generated.isIdentifier)(key)) key = (0, _generated2.stringLiteral)(key.name);\n  return key;\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/converters/toComputedKey.js?')},33348:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar _generated = __webpack_require__(94746);\n\nvar _default = toExpression;\nexports.default = _default;\n\nfunction toExpression(node) {\n  if ((0, _generated.isExpressionStatement)(node)) {\n    node = node.expression;\n  }\n\n  if ((0, _generated.isExpression)(node)) {\n    return node;\n  }\n\n  if ((0, _generated.isClass)(node)) {\n    node.type = "ClassExpression";\n  } else if ((0, _generated.isFunction)(node)) {\n    node.type = "FunctionExpression";\n  }\n\n  if (!(0, _generated.isExpression)(node)) {\n    throw new Error(`cannot turn ${node.type} to an expression`);\n  }\n\n  return node;\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/converters/toExpression.js?')},71309:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = toIdentifier;\n\nvar _isValidIdentifier = _interopRequireDefault(__webpack_require__(93045));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction toIdentifier(name) {\n  name = name + "";\n  name = name.replace(/[^a-zA-Z0-9$_]/g, "-");\n  name = name.replace(/^[-0-9]+/, "");\n  name = name.replace(/[-\\s]+(.)?/g, function (match, c) {\n    return c ? c.toUpperCase() : "";\n  });\n\n  if (!(0, _isValidIdentifier.default)(name)) {\n    name = `_${name}`;\n  }\n\n  return name || "_";\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/converters/toIdentifier.js?')},510:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = toKeyAlias;\n\nvar _generated = __webpack_require__(94746);\n\nvar _cloneNode = _interopRequireDefault(__webpack_require__(46209));\n\nvar _removePropertiesDeep = _interopRequireDefault(__webpack_require__(94936));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction toKeyAlias(node, key = node.key) {\n  let alias;\n\n  if (node.kind === "method") {\n    return toKeyAlias.increment() + "";\n  } else if ((0, _generated.isIdentifier)(key)) {\n    alias = key.name;\n  } else if ((0, _generated.isStringLiteral)(key)) {\n    alias = JSON.stringify(key.value);\n  } else {\n    alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));\n  }\n\n  if (node.computed) {\n    alias = `[${alias}]`;\n  }\n\n  if (node.static) {\n    alias = `static:${alias}`;\n  }\n\n  return alias;\n}\n\ntoKeyAlias.uid = 0;\n\ntoKeyAlias.increment = function () {\n  if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {\n    return toKeyAlias.uid = 0;\n  } else {\n    return toKeyAlias.uid++;\n  }\n};\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/converters/toKeyAlias.js?')},41435:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = toSequenceExpression;\n\nvar _gatherSequenceExpressions = _interopRequireDefault(__webpack_require__(20696));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction toSequenceExpression(nodes, scope) {\n  if (!(nodes == null ? void 0 : nodes.length)) return;\n  const declars = [];\n  const result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);\n  if (!result) return;\n\n  for (const declar of declars) {\n    scope.push(declar);\n  }\n\n  return result;\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/converters/toSequenceExpression.js?')},22307:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar _generated = __webpack_require__(94746);\n\nvar _generated2 = __webpack_require__(34391);\n\nvar _default = toStatement;\nexports.default = _default;\n\nfunction toStatement(node, ignore) {\n  if ((0, _generated.isStatement)(node)) {\n    return node;\n  }\n\n  let mustHaveId = false;\n  let newType;\n\n  if ((0, _generated.isClass)(node)) {\n    mustHaveId = true;\n    newType = "ClassDeclaration";\n  } else if ((0, _generated.isFunction)(node)) {\n    mustHaveId = true;\n    newType = "FunctionDeclaration";\n  } else if ((0, _generated.isAssignmentExpression)(node)) {\n    return (0, _generated2.expressionStatement)(node);\n  }\n\n  if (mustHaveId && !node.id) {\n    newType = false;\n  }\n\n  if (!newType) {\n    if (ignore) {\n      return false;\n    } else {\n      throw new Error(`cannot turn ${node.type} to a statement`);\n    }\n  }\n\n  node.type = newType;\n  return node;\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/converters/toStatement.js?')},46794:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar _isPlainObject = _interopRequireDefault(__webpack_require__(68630));\n\nvar _isRegExp = _interopRequireDefault(__webpack_require__(96347));\n\nvar _isValidIdentifier = _interopRequireDefault(__webpack_require__(93045));\n\nvar _generated = __webpack_require__(34391);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _default = valueToNode;\nexports.default = _default;\n\nfunction valueToNode(value) {\n  if (value === undefined) {\n    return (0, _generated.identifier)("undefined");\n  }\n\n  if (value === true || value === false) {\n    return (0, _generated.booleanLiteral)(value);\n  }\n\n  if (value === null) {\n    return (0, _generated.nullLiteral)();\n  }\n\n  if (typeof value === "string") {\n    return (0, _generated.stringLiteral)(value);\n  }\n\n  if (typeof value === "number") {\n    let result;\n\n    if (Number.isFinite(value)) {\n      result = (0, _generated.numericLiteral)(Math.abs(value));\n    } else {\n      let numerator;\n\n      if (Number.isNaN(value)) {\n        numerator = (0, _generated.numericLiteral)(0);\n      } else {\n        numerator = (0, _generated.numericLiteral)(1);\n      }\n\n      result = (0, _generated.binaryExpression)("/", numerator, (0, _generated.numericLiteral)(0));\n    }\n\n    if (value < 0 || Object.is(value, -0)) {\n      result = (0, _generated.unaryExpression)("-", result);\n    }\n\n    return result;\n  }\n\n  if ((0, _isRegExp.default)(value)) {\n    const pattern = value.source;\n    const flags = value.toString().match(/\\/([a-z]+|)$/)[1];\n    return (0, _generated.regExpLiteral)(pattern, flags);\n  }\n\n  if (Array.isArray(value)) {\n    return (0, _generated.arrayExpression)(value.map(valueToNode));\n  }\n\n  if ((0, _isPlainObject.default)(value)) {\n    const props = [];\n\n    for (const key of Object.keys(value)) {\n      let nodeKey;\n\n      if ((0, _isValidIdentifier.default)(key)) {\n        nodeKey = (0, _generated.identifier)(key);\n      } else {\n        nodeKey = (0, _generated.stringLiteral)(key);\n      }\n\n      props.push((0, _generated.objectProperty)(nodeKey, valueToNode(value[key])));\n    }\n\n    return (0, _generated.objectExpression)(props);\n  }\n\n  throw new Error("don\'t know how to turn this value into a node");\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/converters/valueToNode.js?')},34457:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('/* provided dependency */ var process = __webpack_require__(34155);\n\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.classMethodOrDeclareMethodCommon = exports.classMethodOrPropertyCommon = exports.patternLikeCommon = exports.functionDeclarationCommon = exports.functionTypeAnnotationCommon = exports.functionCommon = void 0;\n\nvar _is = _interopRequireDefault(__webpack_require__(67275));\n\nvar _isValidIdentifier = _interopRequireDefault(__webpack_require__(93045));\n\nvar _helperValidatorIdentifier = __webpack_require__(40720);\n\nvar _constants = __webpack_require__(36325);\n\nvar _utils = _interopRequireWildcard(__webpack_require__(54913));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n(0, _utils.default)("ArrayExpression", {\n  fields: {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),\n      default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined\n    }\n  },\n  visitor: ["elements"],\n  aliases: ["Expression"]\n});\n(0, _utils.default)("AssignmentExpression", {\n  fields: {\n    operator: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertValueType)("string");\n        }\n\n        const identifier = (0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS);\n        const pattern = (0, _utils.assertOneOf)("=");\n        return function (node, key, val) {\n          const validator = (0, _is.default)("Pattern", node.left) ? pattern : identifier;\n          validator(node, key, val);\n        };\n      }()\n    },\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  },\n  builder: ["operator", "left", "right"],\n  visitor: ["left", "right"],\n  aliases: ["Expression"]\n});\n(0, _utils.default)("BinaryExpression", {\n  builder: ["operator", "left", "right"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)\n    },\n    left: {\n      validate: function () {\n        const expression = (0, _utils.assertNodeType)("Expression");\n        const inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");\n\n        const validator = function (node, key, val) {\n          const validator = node.operator === "in" ? inOp : expression;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = ["Expression", "PrivateName"];\n        return validator;\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  },\n  visitor: ["left", "right"],\n  aliases: ["Binary", "Expression"]\n});\n(0, _utils.default)("InterpreterDirective", {\n  builder: ["value"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)("string")\n    }\n  }\n});\n(0, _utils.default)("Directive", {\n  visitor: ["value"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertNodeType)("DirectiveLiteral")\n    }\n  }\n});\n(0, _utils.default)("DirectiveLiteral", {\n  builder: ["value"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)("string")\n    }\n  }\n});\n(0, _utils.default)("BlockStatement", {\n  builder: ["body", "directives"],\n  visitor: ["directives", "body"],\n  fields: {\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))\n    }\n  },\n  aliases: ["Scopable", "BlockParent", "Block", "Statement"]\n});\n(0, _utils.default)("BreakStatement", {\n  visitor: ["label"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)("Identifier"),\n      optional: true\n    }\n  },\n  aliases: ["Statement", "Terminatorless", "CompletionStatement"]\n});\n(0, _utils.default)("CallExpression", {\n  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],\n  builder: ["callee", "arguments"],\n  aliases: ["Expression"],\n  fields: Object.assign({\n    callee: {\n      validate: (0, _utils.assertNodeType)("Expression", "V8IntrinsicIdentifier")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {}, {\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)("CatchClause", {\n  visitor: ["param", "body"],\n  fields: {\n    param: {\n      validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)("BlockStatement")\n    }\n  },\n  aliases: ["Scopable", "BlockParent"]\n});\n(0, _utils.default)("ConditionalExpression", {\n  visitor: ["test", "consequent", "alternate"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    alternate: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  },\n  aliases: ["Expression", "Conditional"]\n});\n(0, _utils.default)("ContinueStatement", {\n  visitor: ["label"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)("Identifier"),\n      optional: true\n    }\n  },\n  aliases: ["Statement", "Terminatorless", "CompletionStatement"]\n});\n(0, _utils.default)("DebuggerStatement", {\n  aliases: ["Statement"]\n});\n(0, _utils.default)("DoWhileStatement", {\n  visitor: ["test", "body"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)("Statement")\n    }\n  },\n  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]\n});\n(0, _utils.default)("EmptyStatement", {\n  aliases: ["Statement"]\n});\n(0, _utils.default)("ExpressionStatement", {\n  visitor: ["expression"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  },\n  aliases: ["Statement", "ExpressionWrapper"]\n});\n(0, _utils.default)("File", {\n  builder: ["program", "comments", "tokens"],\n  visitor: ["program"],\n  fields: {\n    program: {\n      validate: (0, _utils.assertNodeType)("Program")\n    },\n    comments: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {}, {\n        each: {\n          oneOfNodeTypes: ["CommentBlock", "CommentLine"]\n        }\n      }) : (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")),\n      optional: true\n    },\n    tokens: {\n      validate: (0, _utils.assertEach)(Object.assign(() => {}, {\n        type: "any"\n      })),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)("ForInStatement", {\n  visitor: ["left", "right", "body"],\n  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],\n  fields: {\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "LVal") : (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)("Statement")\n    }\n  }\n});\n(0, _utils.default)("ForStatement", {\n  visitor: ["init", "test", "update", "body"],\n  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],\n  fields: {\n    init: {\n      validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),\n      optional: true\n    },\n    test: {\n      validate: (0, _utils.assertNodeType)("Expression"),\n      optional: true\n    },\n    update: {\n      validate: (0, _utils.assertNodeType)("Expression"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)("Statement")\n    }\n  }\n});\nconst functionCommon = {\n  params: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))\n  },\n  generator: {\n    default: false\n  },\n  async: {\n    default: false\n  }\n};\nexports.functionCommon = functionCommon;\nconst functionTypeAnnotationCommon = {\n  returnType: {\n    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),\n    optional: true\n  },\n  typeParameters: {\n    validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),\n    optional: true\n  }\n};\nexports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;\nconst functionDeclarationCommon = Object.assign({}, functionCommon, {\n  declare: {\n    validate: (0, _utils.assertValueType)("boolean"),\n    optional: true\n  },\n  id: {\n    validate: (0, _utils.assertNodeType)("Identifier"),\n    optional: true\n  }\n});\nexports.functionDeclarationCommon = functionDeclarationCommon;\n(0, _utils.default)("FunctionDeclaration", {\n  builder: ["id", "params", "body", "generator", "async"],\n  visitor: ["id", "params", "body", "returnType", "typeParameters"],\n  fields: Object.assign({}, functionDeclarationCommon, functionTypeAnnotationCommon, {\n    body: {\n      validate: (0, _utils.assertNodeType)("BlockStatement")\n    }\n  }),\n  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],\n  validate: function () {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return () => {};\n    const identifier = (0, _utils.assertNodeType)("Identifier");\n    return function (parent, key, node) {\n      if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {\n        identifier(node, "id", node.id);\n      }\n    };\n  }()\n});\n(0, _utils.default)("FunctionExpression", {\n  inherits: "FunctionDeclaration",\n  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    id: {\n      validate: (0, _utils.assertNodeType)("Identifier"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)("BlockStatement")\n    }\n  })\n});\nconst patternLikeCommon = {\n  typeAnnotation: {\n    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator")))\n  }\n};\nexports.patternLikeCommon = patternLikeCommon;\n(0, _utils.default)("Identifier", {\n  builder: ["name"],\n  visitor: ["typeAnnotation", "decorators"],\n  aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],\n  fields: Object.assign({}, patternLikeCommon, {\n    name: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!(0, _isValidIdentifier.default)(val, false)) {\n          throw new TypeError(`"${val}" is not a valid identifier name`);\n        }\n      }, {\n        type: "string"\n      }))\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      optional: true\n    }\n  }),\n\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /\\.(\\w+)$/.exec(key);\n    if (!match) return;\n    const [, parentKey] = match;\n    const nonComp = {\n      computed: false\n    };\n\n    if (parentKey === "property") {\n      if ((0, _is.default)("MemberExpression", parent, nonComp)) return;\n      if ((0, _is.default)("OptionalMemberExpression", parent, nonComp)) return;\n    } else if (parentKey === "key") {\n      if ((0, _is.default)("Property", parent, nonComp)) return;\n      if ((0, _is.default)("Method", parent, nonComp)) return;\n    } else if (parentKey === "exported") {\n      if ((0, _is.default)("ExportSpecifier", parent)) return;\n    } else if (parentKey === "imported") {\n      if ((0, _is.default)("ImportSpecifier", parent, {\n        imported: node\n      })) return;\n    } else if (parentKey === "meta") {\n      if ((0, _is.default)("MetaProperty", parent, {\n        meta: node\n      })) return;\n    }\n\n    if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== "this") {\n      throw new TypeError(`"${node.name}" is not a valid identifier`);\n    }\n  }\n\n});\n(0, _utils.default)("IfStatement", {\n  visitor: ["test", "consequent", "alternate"],\n  aliases: ["Statement", "Conditional"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)("Statement")\n    },\n    alternate: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)("Statement")\n    }\n  }\n});\n(0, _utils.default)("LabeledStatement", {\n  visitor: ["label", "body"],\n  aliases: ["Statement"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)("Identifier")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)("Statement")\n    }\n  }\n});\n(0, _utils.default)("StringLiteral", {\n  builder: ["value"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)("string")\n    }\n  },\n  aliases: ["Expression", "Pureish", "Literal", "Immutable"]\n});\n(0, _utils.default)("NumericLiteral", {\n  builder: ["value"],\n  deprecatedAlias: "NumberLiteral",\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)("number")\n    }\n  },\n  aliases: ["Expression", "Pureish", "Literal", "Immutable"]\n});\n(0, _utils.default)("NullLiteral", {\n  aliases: ["Expression", "Pureish", "Literal", "Immutable"]\n});\n(0, _utils.default)("BooleanLiteral", {\n  builder: ["value"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)("boolean")\n    }\n  },\n  aliases: ["Expression", "Pureish", "Literal", "Immutable"]\n});\n(0, _utils.default)("RegExpLiteral", {\n  builder: ["pattern", "flags"],\n  deprecatedAlias: "RegexLiteral",\n  aliases: ["Expression", "Pureish", "Literal"],\n  fields: {\n    pattern: {\n      validate: (0, _utils.assertValueType)("string")\n    },\n    flags: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        const invalid = /[^gimsuy]/.exec(val);\n\n        if (invalid) {\n          throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`);\n        }\n      }, {\n        type: "string"\n      })),\n      default: ""\n    }\n  }\n});\n(0, _utils.default)("LogicalExpression", {\n  builder: ["operator", "left", "right"],\n  visitor: ["left", "right"],\n  aliases: ["Binary", "Expression"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)\n    },\n    left: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  }\n});\n(0, _utils.default)("MemberExpression", {\n  builder: ["object", "property", "computed", "optional"],\n  visitor: ["object", "property"],\n  aliases: ["Expression", "LVal"],\n  fields: Object.assign({\n    object: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");\n        const computed = (0, _utils.assertNodeType)("Expression");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"];\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {})\n});\n(0, _utils.default)("NewExpression", {\n  inherits: "CallExpression"\n});\n(0, _utils.default)("Program", {\n  visitor: ["directives", "body"],\n  builder: ["body", "directives", "sourceType", "interpreter"],\n  fields: {\n    sourceFile: {\n      validate: (0, _utils.assertValueType)("string")\n    },\n    sourceType: {\n      validate: (0, _utils.assertOneOf)("script", "module"),\n      default: "script"\n    },\n    interpreter: {\n      validate: (0, _utils.assertNodeType)("InterpreterDirective"),\n      default: null,\n      optional: true\n    },\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))\n    }\n  },\n  aliases: ["Scopable", "BlockParent", "Block"]\n});\n(0, _utils.default)("ObjectExpression", {\n  visitor: ["properties"],\n  aliases: ["Expression"],\n  fields: {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))\n    }\n  }\n});\n(0, _utils.default)("ObjectMethod", {\n  builder: ["kind", "key", "params", "body", "computed", "generator", "async"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    kind: Object.assign({\n      validate: (0, _utils.assertOneOf)("method", "get", "set")\n    }, !process.env.BABEL_TYPES_8_BREAKING ? {\n      default: "method"\n    } : {}),\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");\n        const computed = (0, _utils.assertNodeType)("Expression");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral"];\n        return validator;\n      }()\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)("BlockStatement")\n    }\n  }),\n  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],\n  aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]\n});\n(0, _utils.default)("ObjectProperty", {\n  builder: ["key", "value", "computed", "shorthand", ...(!process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : [])],\n  fields: {\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");\n        const computed = (0, _utils.assertNodeType)("Expression");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral"];\n        return validator;\n      }()\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)("Expression", "PatternLike")\n    },\n    shorthand: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.computed) {\n          throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");\n        }\n      }, {\n        type: "boolean"\n      }), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && !(0, _is.default)("Identifier", node.key)) {\n          throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");\n        }\n      }),\n      default: false\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),\n      optional: true\n    }\n  },\n  visitor: ["key", "value", "decorators"],\n  aliases: ["UserWhitespacable", "Property", "ObjectMember"],\n  validate: function () {\n    const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern");\n    const expression = (0, _utils.assertNodeType)("Expression");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n      const validator = (0, _is.default)("ObjectPattern", parent) ? pattern : expression;\n      validator(node, "value", node.value);\n    };\n  }()\n});\n(0, _utils.default)("RestElement", {\n  visitor: ["argument", "typeAnnotation"],\n  builder: ["argument"],\n  aliases: ["LVal", "PatternLike"],\n  deprecatedAlias: "RestProperty",\n  fields: Object.assign({}, patternLikeCommon, {\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "Pattern", "MemberExpression")\n    }\n  }),\n\n  validate(parent, key) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /(\\w+)\\[(\\d+)\\]/.exec(key);\n    if (!match) throw new Error("Internal Babel error: malformed key.");\n    const [, listKey, index] = match;\n\n    if (parent[listKey].length > index + 1) {\n      throw new TypeError(`RestElement must be last element of ${listKey}`);\n    }\n  }\n\n});\n(0, _utils.default)("ReturnStatement", {\n  visitor: ["argument"],\n  aliases: ["Statement", "Terminatorless", "CompletionStatement"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)("Expression"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)("SequenceExpression", {\n  visitor: ["expressions"],\n  fields: {\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")))\n    }\n  },\n  aliases: ["Expression"]\n});\n(0, _utils.default)("ParenthesizedExpression", {\n  visitor: ["expression"],\n  aliases: ["Expression", "ExpressionWrapper"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  }\n});\n(0, _utils.default)("SwitchCase", {\n  visitor: ["test", "consequent"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)("Expression"),\n      optional: true\n    },\n    consequent: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))\n    }\n  }\n});\n(0, _utils.default)("SwitchStatement", {\n  visitor: ["discriminant", "cases"],\n  aliases: ["Statement", "BlockParent", "Scopable"],\n  fields: {\n    discriminant: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    cases: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("SwitchCase")))\n    }\n  }\n});\n(0, _utils.default)("ThisExpression", {\n  aliases: ["Expression"]\n});\n(0, _utils.default)("ThrowStatement", {\n  visitor: ["argument"],\n  aliases: ["Statement", "Terminatorless", "CompletionStatement"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  }\n});\n(0, _utils.default)("TryStatement", {\n  visitor: ["block", "handler", "finalizer"],\n  aliases: ["Statement"],\n  fields: {\n    block: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function (node) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!node.handler && !node.finalizer) {\n          throw new TypeError("TryStatement expects either a handler or finalizer, or both");\n        }\n      }, {\n        oneOfNodeTypes: ["BlockStatement"]\n      }))\n    },\n    handler: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)("CatchClause")\n    },\n    finalizer: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)("BlockStatement")\n    }\n  }\n});\n(0, _utils.default)("UnaryExpression", {\n  builder: ["operator", "argument", "prefix"],\n  fields: {\n    prefix: {\n      default: true\n    },\n    argument: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)\n    }\n  },\n  visitor: ["argument"],\n  aliases: ["UnaryLike", "Expression"]\n});\n(0, _utils.default)("UpdateExpression", {\n  builder: ["operator", "argument", "prefix"],\n  fields: {\n    prefix: {\n      default: false\n    },\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Expression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)\n    }\n  },\n  visitor: ["argument"],\n  aliases: ["Expression"]\n});\n(0, _utils.default)("VariableDeclaration", {\n  builder: ["kind", "declarations"],\n  visitor: ["declarations"],\n  aliases: ["Statement", "Declaration"],\n  fields: {\n    declare: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      optional: true\n    },\n    kind: {\n      validate: (0, _utils.assertOneOf)("var", "let", "const")\n    },\n    declarations: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("VariableDeclarator")))\n    }\n  },\n\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    if (!(0, _is.default)("ForXStatement", parent, {\n      left: node\n    })) return;\n\n    if (node.declarations.length !== 1) {\n      throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);\n    }\n  }\n\n});\n(0, _utils.default)("VariableDeclarator", {\n  visitor: ["id", "init"],\n  fields: {\n    id: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)("LVal");\n        }\n\n        const normal = (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern");\n        const without = (0, _utils.assertNodeType)("Identifier");\n        return function (node, key, val) {\n          const validator = node.init ? normal : without;\n          validator(node, key, val);\n        };\n      }()\n    },\n    definite: {\n      optional: true,\n      validate: (0, _utils.assertValueType)("boolean")\n    },\n    init: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  }\n});\n(0, _utils.default)("WhileStatement", {\n  visitor: ["test", "body"],\n  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)("Statement")\n    }\n  }\n});\n(0, _utils.default)("WithStatement", {\n  visitor: ["object", "body"],\n  aliases: ["Statement"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)("Statement")\n    }\n  }\n});\n(0, _utils.default)("AssignmentPattern", {\n  visitor: ["left", "right", "decorators"],\n  builder: ["left", "right"],\n  aliases: ["Pattern", "PatternLike", "LVal"],\n  fields: Object.assign({}, patternLikeCommon, {\n    left: {\n      validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)("ArrayPattern", {\n  visitor: ["elements", "typeAnnotation"],\n  builder: ["elements"],\n  aliases: ["Pattern", "PatternLike", "LVal"],\n  fields: Object.assign({}, patternLikeCommon, {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike")))\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)("ArrowFunctionExpression", {\n  builder: ["params", "body", "async"],\n  visitor: ["params", "body", "returnType", "typeParameters"],\n  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    expression: {\n      validate: (0, _utils.assertValueType)("boolean")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")\n    }\n  })\n});\n(0, _utils.default)("ClassBody", {\n  visitor: ["body"],\n  fields: {\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "TSDeclareMethod", "TSIndexSignature")))\n    }\n  }\n});\n(0, _utils.default)("ClassExpression", {\n  builder: ["id", "superClass", "body", "decorators"],\n  visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],\n  aliases: ["Scopable", "Class", "Expression"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)("Identifier"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)("ClassBody")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)("InterfaceExtends"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)("ClassDeclaration", {\n  inherits: "ClassExpression",\n  aliases: ["Scopable", "Class", "Statement", "Declaration"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)("Identifier")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)("ClassBody")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)("InterfaceExtends"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      optional: true\n    },\n    abstract: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      optional: true\n    }\n  },\n  validate: function () {\n    const identifier = (0, _utils.assertNodeType)("Identifier");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n      if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {\n        identifier(node, "id", node.id);\n      }\n    };\n  }()\n});\n(0, _utils.default)("ExportAllDeclaration", {\n  visitor: ["source"],\n  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],\n  fields: {\n    source: {\n      validate: (0, _utils.assertNodeType)("StringLiteral")\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value")),\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertNodeType)("ImportAttribute"))\n    }\n  }\n});\n(0, _utils.default)("ExportDefaultDeclaration", {\n  visitor: ["declaration"],\n  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],\n  fields: {\n    declaration: {\n      validate: (0, _utils.assertNodeType)("FunctionDeclaration", "TSDeclareFunction", "ClassDeclaration", "Expression")\n    }\n  }\n});\n(0, _utils.default)("ExportNamedDeclaration", {\n  visitor: ["declaration", "specifiers", "source"],\n  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],\n  fields: {\n    declaration: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.specifiers.length) {\n          throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");\n        }\n      }, {\n        oneOfNodeTypes: ["Declaration"]\n      }), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.source) {\n          throw new TypeError("Cannot export a declaration from a source");\n        }\n      })\n    },\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertNodeType)("ImportAttribute"))\n    },\n    specifiers: {\n      default: [],\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)(function () {\n        const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");\n        const sourceless = (0, _utils.assertNodeType)("ExportSpecifier");\n        if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;\n        return function (node, key, val) {\n          const validator = node.source ? sourced : sourceless;\n          validator(node, key, val);\n        };\n      }()))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)("StringLiteral"),\n      optional: true\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))\n  }\n});\n(0, _utils.default)("ExportSpecifier", {\n  visitor: ["local", "exported"],\n  aliases: ["ModuleSpecifier"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)("Identifier")\n    },\n    exported: {\n      validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")\n    }\n  }\n});\n(0, _utils.default)("ForOfStatement", {\n  visitor: ["left", "right", "body"],\n  builder: ["left", "right", "body", "await"],\n  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],\n  fields: {\n    left: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");\n        }\n\n        const declaration = (0, _utils.assertNodeType)("VariableDeclaration");\n        const lval = (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern");\n        return function (node, key, val) {\n          if ((0, _is.default)("VariableDeclaration", val)) {\n            declaration(node, key, val);\n          } else {\n            lval(node, key, val);\n          }\n        };\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)("Statement")\n    },\n    await: {\n      default: false\n    }\n  }\n});\n(0, _utils.default)("ImportDeclaration", {\n  visitor: ["specifiers", "source"],\n  aliases: ["Statement", "Declaration", "ModuleDeclaration"],\n  fields: {\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertNodeType)("ImportAttribute"))\n    },\n    specifiers: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)("StringLiteral")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)("type", "typeof", "value"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)("ImportDefaultSpecifier", {\n  visitor: ["local"],\n  aliases: ["ModuleSpecifier"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)("Identifier")\n    }\n  }\n});\n(0, _utils.default)("ImportNamespaceSpecifier", {\n  visitor: ["local"],\n  aliases: ["ModuleSpecifier"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)("Identifier")\n    }\n  }\n});\n(0, _utils.default)("ImportSpecifier", {\n  visitor: ["local", "imported"],\n  aliases: ["ModuleSpecifier"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)("Identifier")\n    },\n    imported: {\n      validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)("type", "typeof"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)("MetaProperty", {\n  visitor: ["meta", "property"],\n  aliases: ["Expression"],\n  fields: {\n    meta: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        let property;\n\n        switch (val.name) {\n          case "function":\n            property = "sent";\n            break;\n\n          case "new":\n            property = "target";\n            break;\n\n          case "import":\n            property = "meta";\n            break;\n        }\n\n        if (!(0, _is.default)("Identifier", node.property, {\n          name: property\n        })) {\n          throw new TypeError("Unrecognised MetaProperty");\n        }\n      }, {\n        oneOfNodeTypes: ["Identifier"]\n      }))\n    },\n    property: {\n      validate: (0, _utils.assertNodeType)("Identifier")\n    }\n  }\n});\nconst classMethodOrPropertyCommon = {\n  abstract: {\n    validate: (0, _utils.assertValueType)("boolean"),\n    optional: true\n  },\n  accessibility: {\n    validate: (0, _utils.assertOneOf)("public", "private", "protected"),\n    optional: true\n  },\n  static: {\n    default: false\n  },\n  computed: {\n    default: false\n  },\n  optional: {\n    validate: (0, _utils.assertValueType)("boolean"),\n    optional: true\n  },\n  key: {\n    validate: (0, _utils.chain)(function () {\n      const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");\n      const computed = (0, _utils.assertNodeType)("Expression");\n      return function (node, key, val) {\n        const validator = node.computed ? computed : normal;\n        validator(node, key, val);\n      };\n    }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "Expression"))\n  }\n};\nexports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;\nconst classMethodOrDeclareMethodCommon = Object.assign({}, functionCommon, classMethodOrPropertyCommon, {\n  kind: {\n    validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),\n    default: "method"\n  },\n  access: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),\n    optional: true\n  }\n});\nexports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;\n(0, _utils.default)("ClassMethod", {\n  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],\n  builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],\n  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {\n    body: {\n      validate: (0, _utils.assertNodeType)("BlockStatement")\n    }\n  })\n});\n(0, _utils.default)("ObjectPattern", {\n  visitor: ["properties", "typeAnnotation", "decorators"],\n  builder: ["properties"],\n  aliases: ["Pattern", "PatternLike", "LVal"],\n  fields: Object.assign({}, patternLikeCommon, {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("RestElement", "ObjectProperty")))\n    }\n  })\n});\n(0, _utils.default)("SpreadElement", {\n  visitor: ["argument"],\n  aliases: ["UnaryLike"],\n  deprecatedAlias: "SpreadProperty",\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  }\n});\n(0, _utils.default)("Super", {\n  aliases: ["Expression"]\n});\n(0, _utils.default)("TaggedTemplateExpression", {\n  visitor: ["tag", "quasi"],\n  aliases: ["Expression"],\n  fields: {\n    tag: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    quasi: {\n      validate: (0, _utils.assertNodeType)("TemplateLiteral")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)("TemplateElement", {\n  builder: ["value", "tail"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertShape)({\n        raw: {\n          validate: (0, _utils.assertValueType)("string")\n        },\n        cooked: {\n          validate: (0, _utils.assertValueType)("string"),\n          optional: true\n        }\n      })\n    },\n    tail: {\n      default: false\n    }\n  }\n});\n(0, _utils.default)("TemplateLiteral", {\n  visitor: ["quasis", "expressions"],\n  aliases: ["Expression", "Literal"],\n  fields: {\n    quasis: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TemplateElement")))\n    },\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "TSType")), function (node, key, val) {\n        if (node.quasis.length !== val.length + 1) {\n          throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);\n        }\n      })\n    }\n  }\n});\n(0, _utils.default)("YieldExpression", {\n  builder: ["argument", "delegate"],\n  visitor: ["argument"],\n  aliases: ["Expression", "Terminatorless"],\n  fields: {\n    delegate: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && !node.argument) {\n          throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");\n        }\n      }, {\n        type: "boolean"\n      })),\n      default: false\n    },\n    argument: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  }\n});\n(0, _utils.default)("AwaitExpression", {\n  builder: ["argument"],\n  visitor: ["argument"],\n  aliases: ["Expression", "Terminatorless"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  }\n});\n(0, _utils.default)("Import", {\n  aliases: ["Expression"]\n});\n(0, _utils.default)("BigIntLiteral", {\n  builder: ["value"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)("string")\n    }\n  },\n  aliases: ["Expression", "Pureish", "Literal", "Immutable"]\n});\n(0, _utils.default)("ExportNamespaceSpecifier", {\n  visitor: ["exported"],\n  aliases: ["ModuleSpecifier"],\n  fields: {\n    exported: {\n      validate: (0, _utils.assertNodeType)("Identifier")\n    }\n  }\n});\n(0, _utils.default)("OptionalMemberExpression", {\n  builder: ["object", "property", "computed", "optional"],\n  visitor: ["object", "property"],\n  aliases: ["Expression"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)("Identifier");\n        const computed = (0, _utils.assertNodeType)("Expression");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = ["Expression", "Identifier"];\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())\n    }\n  }\n});\n(0, _utils.default)("OptionalCallExpression", {\n  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],\n  builder: ["callee", "arguments", "optional"],\n  aliases: ["Expression"],\n  fields: {\n    callee: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())\n    },\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),\n      optional: true\n    }\n  }\n});\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/definitions/core.js?')},71456:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('/* provided dependency */ var process = __webpack_require__(34155);\n\n\nvar _utils = _interopRequireWildcard(__webpack_require__(54913));\n\nvar _core = __webpack_require__(34457);\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n(0, _utils.default)("ArgumentPlaceholder", {});\n(0, _utils.default)("BindExpression", {\n  visitor: ["object", "callee"],\n  aliases: ["Expression"],\n  fields: !process.env.BABEL_TYPES_8_BREAKING ? {\n    object: {\n      validate: Object.assign(() => {}, {\n        oneOfNodeTypes: ["Expression"]\n      })\n    },\n    callee: {\n      validate: Object.assign(() => {}, {\n        oneOfNodeTypes: ["Expression"]\n      })\n    }\n  } : {\n    object: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    callee: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  }\n});\n(0, _utils.default)("ClassProperty", {\n  visitor: ["key", "value", "typeAnnotation", "decorators"],\n  builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],\n  aliases: ["Property"],\n  fields: Object.assign({}, _core.classMethodOrPropertyCommon, {\n    value: {\n      validate: (0, _utils.assertNodeType)("Expression"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)("PipelineTopicExpression", {\n  builder: ["expression"],\n  visitor: ["expression"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  }\n});\n(0, _utils.default)("PipelineBareFunction", {\n  builder: ["callee"],\n  visitor: ["callee"],\n  fields: {\n    callee: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  }\n});\n(0, _utils.default)("PipelinePrimaryTopicReference", {\n  aliases: ["Expression"]\n});\n(0, _utils.default)("ClassPrivateProperty", {\n  visitor: ["key", "value", "decorators"],\n  builder: ["key", "value", "decorators", "static"],\n  aliases: ["Property", "Private"],\n  fields: {\n    key: {\n      validate: (0, _utils.assertNodeType)("PrivateName")\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)("Expression"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)("ClassPrivateMethod", {\n  builder: ["kind", "key", "params", "body", "static"],\n  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],\n  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],\n  fields: Object.assign({}, _core.classMethodOrDeclareMethodCommon, _core.functionTypeAnnotationCommon, {\n    key: {\n      validate: (0, _utils.assertNodeType)("PrivateName")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)("BlockStatement")\n    }\n  })\n});\n(0, _utils.default)("ImportAttribute", {\n  visitor: ["key", "value"],\n  fields: {\n    key: {\n      validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)("StringLiteral")\n    }\n  }\n});\n(0, _utils.default)("Decorator", {\n  visitor: ["expression"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  }\n});\n(0, _utils.default)("DoExpression", {\n  visitor: ["body"],\n  aliases: ["Expression"],\n  fields: {\n    body: {\n      validate: (0, _utils.assertNodeType)("BlockStatement")\n    }\n  }\n});\n(0, _utils.default)("ExportDefaultSpecifier", {\n  visitor: ["exported"],\n  aliases: ["ModuleSpecifier"],\n  fields: {\n    exported: {\n      validate: (0, _utils.assertNodeType)("Identifier")\n    }\n  }\n});\n(0, _utils.default)("PrivateName", {\n  visitor: ["id"],\n  aliases: ["Private"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)("Identifier")\n    }\n  }\n});\n(0, _utils.default)("RecordExpression", {\n  visitor: ["properties"],\n  aliases: ["Expression"],\n  fields: {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectProperty", "SpreadElement")))\n    }\n  }\n});\n(0, _utils.default)("TupleExpression", {\n  fields: {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement"))),\n      default: []\n    }\n  },\n  visitor: ["elements"],\n  aliases: ["Expression"]\n});\n(0, _utils.default)("DecimalLiteral", {\n  builder: ["value"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)("string")\n    }\n  },\n  aliases: ["Expression", "Pureish", "Literal", "Immutable"]\n});\n(0, _utils.default)("StaticBlock", {\n  visitor: ["body"],\n  fields: {\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))\n    }\n  },\n  aliases: ["Scopable", "BlockParent"]\n});\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/definitions/experimental.js?')},85391:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('\n\nvar _utils = _interopRequireWildcard(__webpack_require__(54913));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst defineInterfaceishType = (name, typeParameterType = "TypeParameterDeclaration") => {\n  (0, _utils.default)(name, {\n    builder: ["id", "typeParameters", "extends", "body"],\n    visitor: ["id", "typeParameters", "extends", "mixins", "implements", "body"],\n    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],\n    fields: {\n      id: (0, _utils.validateType)("Identifier"),\n      typeParameters: (0, _utils.validateOptionalType)(typeParameterType),\n      extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),\n      mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),\n      implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements")),\n      body: (0, _utils.validateType)("ObjectTypeAnnotation")\n    }\n  });\n};\n\n(0, _utils.default)("AnyTypeAnnotation", {\n  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]\n});\n(0, _utils.default)("ArrayTypeAnnotation", {\n  visitor: ["elementType"],\n  aliases: ["Flow", "FlowType"],\n  fields: {\n    elementType: (0, _utils.validateType)("FlowType")\n  }\n});\n(0, _utils.default)("BooleanTypeAnnotation", {\n  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]\n});\n(0, _utils.default)("BooleanLiteralTypeAnnotation", {\n  builder: ["value"],\n  aliases: ["Flow", "FlowType"],\n  fields: {\n    value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))\n  }\n});\n(0, _utils.default)("NullLiteralTypeAnnotation", {\n  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]\n});\n(0, _utils.default)("ClassImplements", {\n  visitor: ["id", "typeParameters"],\n  aliases: ["Flow"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier"),\n    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")\n  }\n});\ndefineInterfaceishType("DeclareClass");\n(0, _utils.default)("DeclareFunction", {\n  visitor: ["id"],\n  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier"),\n    predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")\n  }\n});\ndefineInterfaceishType("DeclareInterface");\n(0, _utils.default)("DeclareModule", {\n  builder: ["id", "body", "kind"],\n  visitor: ["id", "body"],\n  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],\n  fields: {\n    id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),\n    body: (0, _utils.validateType)("BlockStatement"),\n    kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))\n  }\n});\n(0, _utils.default)("DeclareModuleExports", {\n  visitor: ["typeAnnotation"],\n  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)("TypeAnnotation")\n  }\n});\n(0, _utils.default)("DeclareTypeAlias", {\n  visitor: ["id", "typeParameters", "right"],\n  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier"),\n    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),\n    right: (0, _utils.validateType)("FlowType")\n  }\n});\n(0, _utils.default)("DeclareOpaqueType", {\n  visitor: ["id", "typeParameters", "supertype"],\n  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier"),\n    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),\n    supertype: (0, _utils.validateOptionalType)("FlowType")\n  }\n});\n(0, _utils.default)("DeclareVariable", {\n  visitor: ["id"],\n  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier")\n  }\n});\n(0, _utils.default)("DeclareExportDeclaration", {\n  visitor: ["declaration", "specifiers", "source"],\n  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],\n  fields: {\n    declaration: (0, _utils.validateOptionalType)("Flow"),\n    specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),\n    source: (0, _utils.validateOptionalType)("StringLiteral"),\n    default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))\n  }\n});\n(0, _utils.default)("DeclareExportAllDeclaration", {\n  visitor: ["source"],\n  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],\n  fields: {\n    source: (0, _utils.validateType)("StringLiteral"),\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))\n  }\n});\n(0, _utils.default)("DeclaredPredicate", {\n  visitor: ["value"],\n  aliases: ["Flow", "FlowPredicate"],\n  fields: {\n    value: (0, _utils.validateType)("Flow")\n  }\n});\n(0, _utils.default)("ExistsTypeAnnotation", {\n  aliases: ["Flow", "FlowType"]\n});\n(0, _utils.default)("FunctionTypeAnnotation", {\n  visitor: ["typeParameters", "params", "rest", "returnType"],\n  aliases: ["Flow", "FlowType"],\n  fields: {\n    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),\n    params: (0, _utils.validate)((0, _utils.arrayOfType)("FunctionTypeParam")),\n    rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),\n    returnType: (0, _utils.validateType)("FlowType")\n  }\n});\n(0, _utils.default)("FunctionTypeParam", {\n  visitor: ["name", "typeAnnotation"],\n  aliases: ["Flow"],\n  fields: {\n    name: (0, _utils.validateOptionalType)("Identifier"),\n    typeAnnotation: (0, _utils.validateType)("FlowType"),\n    optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))\n  }\n});\n(0, _utils.default)("GenericTypeAnnotation", {\n  visitor: ["id", "typeParameters"],\n  aliases: ["Flow", "FlowType"],\n  fields: {\n    id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),\n    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")\n  }\n});\n(0, _utils.default)("InferredPredicate", {\n  aliases: ["Flow", "FlowPredicate"]\n});\n(0, _utils.default)("InterfaceExtends", {\n  visitor: ["id", "typeParameters"],\n  aliases: ["Flow"],\n  fields: {\n    id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),\n    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")\n  }\n});\ndefineInterfaceishType("InterfaceDeclaration");\n(0, _utils.default)("InterfaceTypeAnnotation", {\n  visitor: ["extends", "body"],\n  aliases: ["Flow", "FlowType"],\n  fields: {\n    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),\n    body: (0, _utils.validateType)("ObjectTypeAnnotation")\n  }\n});\n(0, _utils.default)("IntersectionTypeAnnotation", {\n  visitor: ["types"],\n  aliases: ["Flow", "FlowType"],\n  fields: {\n    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))\n  }\n});\n(0, _utils.default)("MixedTypeAnnotation", {\n  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]\n});\n(0, _utils.default)("EmptyTypeAnnotation", {\n  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]\n});\n(0, _utils.default)("NullableTypeAnnotation", {\n  visitor: ["typeAnnotation"],\n  aliases: ["Flow", "FlowType"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)("FlowType")\n  }\n});\n(0, _utils.default)("NumberLiteralTypeAnnotation", {\n  builder: ["value"],\n  aliases: ["Flow", "FlowType"],\n  fields: {\n    value: (0, _utils.validate)((0, _utils.assertValueType)("number"))\n  }\n});\n(0, _utils.default)("NumberTypeAnnotation", {\n  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]\n});\n(0, _utils.default)("ObjectTypeAnnotation", {\n  visitor: ["properties", "indexers", "callProperties", "internalSlots"],\n  aliases: ["Flow", "FlowType"],\n  builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],\n  fields: {\n    properties: (0, _utils.validate)((0, _utils.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),\n    indexers: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeIndexer")),\n    callProperties: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeCallProperty")),\n    internalSlots: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeInternalSlot")),\n    exact: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      default: false\n    },\n    inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))\n  }\n});\n(0, _utils.default)("ObjectTypeInternalSlot", {\n  visitor: ["id", "value", "optional", "static", "method"],\n  aliases: ["Flow", "UserWhitespacable"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier"),\n    value: (0, _utils.validateType)("FlowType"),\n    optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),\n    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),\n    method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))\n  }\n});\n(0, _utils.default)("ObjectTypeCallProperty", {\n  visitor: ["value"],\n  aliases: ["Flow", "UserWhitespacable"],\n  fields: {\n    value: (0, _utils.validateType)("FlowType"),\n    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))\n  }\n});\n(0, _utils.default)("ObjectTypeIndexer", {\n  visitor: ["id", "key", "value", "variance"],\n  aliases: ["Flow", "UserWhitespacable"],\n  fields: {\n    id: (0, _utils.validateOptionalType)("Identifier"),\n    key: (0, _utils.validateType)("FlowType"),\n    value: (0, _utils.validateType)("FlowType"),\n    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),\n    variance: (0, _utils.validateOptionalType)("Variance")\n  }\n});\n(0, _utils.default)("ObjectTypeProperty", {\n  visitor: ["key", "value", "variance"],\n  aliases: ["Flow", "UserWhitespacable"],\n  fields: {\n    key: (0, _utils.validateType)(["Identifier", "StringLiteral"]),\n    value: (0, _utils.validateType)("FlowType"),\n    kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),\n    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),\n    proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),\n    optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),\n    variance: (0, _utils.validateOptionalType)("Variance"),\n    method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))\n  }\n});\n(0, _utils.default)("ObjectTypeSpreadProperty", {\n  visitor: ["argument"],\n  aliases: ["Flow", "UserWhitespacable"],\n  fields: {\n    argument: (0, _utils.validateType)("FlowType")\n  }\n});\n(0, _utils.default)("OpaqueType", {\n  visitor: ["id", "typeParameters", "supertype", "impltype"],\n  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier"),\n    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),\n    supertype: (0, _utils.validateOptionalType)("FlowType"),\n    impltype: (0, _utils.validateType)("FlowType")\n  }\n});\n(0, _utils.default)("QualifiedTypeIdentifier", {\n  visitor: ["id", "qualification"],\n  aliases: ["Flow"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier"),\n    qualification: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"])\n  }\n});\n(0, _utils.default)("StringLiteralTypeAnnotation", {\n  builder: ["value"],\n  aliases: ["Flow", "FlowType"],\n  fields: {\n    value: (0, _utils.validate)((0, _utils.assertValueType)("string"))\n  }\n});\n(0, _utils.default)("StringTypeAnnotation", {\n  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]\n});\n(0, _utils.default)("SymbolTypeAnnotation", {\n  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]\n});\n(0, _utils.default)("ThisTypeAnnotation", {\n  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]\n});\n(0, _utils.default)("TupleTypeAnnotation", {\n  visitor: ["types"],\n  aliases: ["Flow", "FlowType"],\n  fields: {\n    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))\n  }\n});\n(0, _utils.default)("TypeofTypeAnnotation", {\n  visitor: ["argument"],\n  aliases: ["Flow", "FlowType"],\n  fields: {\n    argument: (0, _utils.validateType)("FlowType")\n  }\n});\n(0, _utils.default)("TypeAlias", {\n  visitor: ["id", "typeParameters", "right"],\n  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier"),\n    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),\n    right: (0, _utils.validateType)("FlowType")\n  }\n});\n(0, _utils.default)("TypeAnnotation", {\n  aliases: ["Flow"],\n  visitor: ["typeAnnotation"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)("FlowType")\n  }\n});\n(0, _utils.default)("TypeCastExpression", {\n  visitor: ["expression", "typeAnnotation"],\n  aliases: ["Flow", "ExpressionWrapper", "Expression"],\n  fields: {\n    expression: (0, _utils.validateType)("Expression"),\n    typeAnnotation: (0, _utils.validateType)("TypeAnnotation")\n  }\n});\n(0, _utils.default)("TypeParameter", {\n  aliases: ["Flow"],\n  visitor: ["bound", "default", "variance"],\n  fields: {\n    name: (0, _utils.validate)((0, _utils.assertValueType)("string")),\n    bound: (0, _utils.validateOptionalType)("TypeAnnotation"),\n    default: (0, _utils.validateOptionalType)("FlowType"),\n    variance: (0, _utils.validateOptionalType)("Variance")\n  }\n});\n(0, _utils.default)("TypeParameterDeclaration", {\n  aliases: ["Flow"],\n  visitor: ["params"],\n  fields: {\n    params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))\n  }\n});\n(0, _utils.default)("TypeParameterInstantiation", {\n  aliases: ["Flow"],\n  visitor: ["params"],\n  fields: {\n    params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))\n  }\n});\n(0, _utils.default)("UnionTypeAnnotation", {\n  visitor: ["types"],\n  aliases: ["Flow", "FlowType"],\n  fields: {\n    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))\n  }\n});\n(0, _utils.default)("Variance", {\n  aliases: ["Flow"],\n  builder: ["kind"],\n  fields: {\n    kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))\n  }\n});\n(0, _utils.default)("VoidTypeAnnotation", {\n  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]\n});\n(0, _utils.default)("EnumDeclaration", {\n  aliases: ["Statement", "Declaration"],\n  visitor: ["id", "body"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier"),\n    body: (0, _utils.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])\n  }\n});\n(0, _utils.default)("EnumBooleanBody", {\n  aliases: ["EnumBody"],\n  visitor: ["members"],\n  fields: {\n    explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),\n    members: (0, _utils.validateArrayOfType)("EnumBooleanMember")\n  }\n});\n(0, _utils.default)("EnumNumberBody", {\n  aliases: ["EnumBody"],\n  visitor: ["members"],\n  fields: {\n    explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),\n    members: (0, _utils.validateArrayOfType)("EnumNumberMember")\n  }\n});\n(0, _utils.default)("EnumStringBody", {\n  aliases: ["EnumBody"],\n  visitor: ["members"],\n  fields: {\n    explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),\n    members: (0, _utils.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"])\n  }\n});\n(0, _utils.default)("EnumSymbolBody", {\n  aliases: ["EnumBody"],\n  visitor: ["members"],\n  fields: {\n    members: (0, _utils.validateArrayOfType)("EnumDefaultedMember")\n  }\n});\n(0, _utils.default)("EnumBooleanMember", {\n  aliases: ["EnumMember"],\n  visitor: ["id"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier"),\n    init: (0, _utils.validateType)("BooleanLiteral")\n  }\n});\n(0, _utils.default)("EnumNumberMember", {\n  aliases: ["EnumMember"],\n  visitor: ["id", "init"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier"),\n    init: (0, _utils.validateType)("NumericLiteral")\n  }\n});\n(0, _utils.default)("EnumStringMember", {\n  aliases: ["EnumMember"],\n  visitor: ["id", "init"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier"),\n    init: (0, _utils.validateType)("StringLiteral")\n  }\n});\n(0, _utils.default)("EnumDefaultedMember", {\n  aliases: ["EnumMember"],\n  visitor: ["id"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier")\n  }\n});\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/definitions/flow.js?')},46507:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nObject.defineProperty(exports, "VISITOR_KEYS", ({\n  enumerable: true,\n  get: function () {\n    return _utils.VISITOR_KEYS;\n  }\n}));\nObject.defineProperty(exports, "ALIAS_KEYS", ({\n  enumerable: true,\n  get: function () {\n    return _utils.ALIAS_KEYS;\n  }\n}));\nObject.defineProperty(exports, "FLIPPED_ALIAS_KEYS", ({\n  enumerable: true,\n  get: function () {\n    return _utils.FLIPPED_ALIAS_KEYS;\n  }\n}));\nObject.defineProperty(exports, "NODE_FIELDS", ({\n  enumerable: true,\n  get: function () {\n    return _utils.NODE_FIELDS;\n  }\n}));\nObject.defineProperty(exports, "BUILDER_KEYS", ({\n  enumerable: true,\n  get: function () {\n    return _utils.BUILDER_KEYS;\n  }\n}));\nObject.defineProperty(exports, "DEPRECATED_KEYS", ({\n  enumerable: true,\n  get: function () {\n    return _utils.DEPRECATED_KEYS;\n  }\n}));\nObject.defineProperty(exports, "NODE_PARENT_VALIDATIONS", ({\n  enumerable: true,\n  get: function () {\n    return _utils.NODE_PARENT_VALIDATIONS;\n  }\n}));\nObject.defineProperty(exports, "PLACEHOLDERS", ({\n  enumerable: true,\n  get: function () {\n    return _placeholders.PLACEHOLDERS;\n  }\n}));\nObject.defineProperty(exports, "PLACEHOLDERS_ALIAS", ({\n  enumerable: true,\n  get: function () {\n    return _placeholders.PLACEHOLDERS_ALIAS;\n  }\n}));\nObject.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", ({\n  enumerable: true,\n  get: function () {\n    return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;\n  }\n}));\nexports.TYPES = void 0;\n\nvar _toFastProperties = _interopRequireDefault(__webpack_require__(53164));\n\n__webpack_require__(34457);\n\n__webpack_require__(85391);\n\n__webpack_require__(38565);\n\n__webpack_require__(55030);\n\n__webpack_require__(71456);\n\n__webpack_require__(20045);\n\nvar _utils = __webpack_require__(54913);\n\nvar _placeholders = __webpack_require__(29488);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n(0, _toFastProperties.default)(_utils.VISITOR_KEYS);\n(0, _toFastProperties.default)(_utils.ALIAS_KEYS);\n(0, _toFastProperties.default)(_utils.FLIPPED_ALIAS_KEYS);\n(0, _toFastProperties.default)(_utils.NODE_FIELDS);\n(0, _toFastProperties.default)(_utils.BUILDER_KEYS);\n(0, _toFastProperties.default)(_utils.DEPRECATED_KEYS);\n(0, _toFastProperties.default)(_placeholders.PLACEHOLDERS_ALIAS);\n(0, _toFastProperties.default)(_placeholders.PLACEHOLDERS_FLIPPED_ALIAS);\nconst TYPES = Object.keys(_utils.VISITOR_KEYS).concat(Object.keys(_utils.FLIPPED_ALIAS_KEYS)).concat(Object.keys(_utils.DEPRECATED_KEYS));\nexports.TYPES = TYPES;\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/definitions/index.js?')},38565:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('\n\nvar _utils = _interopRequireWildcard(__webpack_require__(54913));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n(0, _utils.default)("JSXAttribute", {\n  visitor: ["name", "value"],\n  aliases: ["JSX", "Immutable"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")\n    },\n    value: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")\n    }\n  }\n});\n(0, _utils.default)("JSXClosingElement", {\n  visitor: ["name"],\n  aliases: ["JSX", "Immutable"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")\n    }\n  }\n});\n(0, _utils.default)("JSXElement", {\n  builder: ["openingElement", "closingElement", "children", "selfClosing"],\n  visitor: ["openingElement", "children", "closingElement"],\n  aliases: ["JSX", "Immutable", "Expression"],\n  fields: {\n    openingElement: {\n      validate: (0, _utils.assertNodeType)("JSXOpeningElement")\n    },\n    closingElement: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)("JSXClosingElement")\n    },\n    children: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))\n    },\n    selfClosing: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)("JSXEmptyExpression", {\n  aliases: ["JSX"]\n});\n(0, _utils.default)("JSXExpressionContainer", {\n  visitor: ["expression"],\n  aliases: ["JSX", "Immutable"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")\n    }\n  }\n});\n(0, _utils.default)("JSXSpreadChild", {\n  visitor: ["expression"],\n  aliases: ["JSX", "Immutable"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  }\n});\n(0, _utils.default)("JSXIdentifier", {\n  builder: ["name"],\n  aliases: ["JSX"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertValueType)("string")\n    }\n  }\n});\n(0, _utils.default)("JSXMemberExpression", {\n  visitor: ["object", "property"],\n  aliases: ["JSX"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")\n    },\n    property: {\n      validate: (0, _utils.assertNodeType)("JSXIdentifier")\n    }\n  }\n});\n(0, _utils.default)("JSXNamespacedName", {\n  visitor: ["namespace", "name"],\n  aliases: ["JSX"],\n  fields: {\n    namespace: {\n      validate: (0, _utils.assertNodeType)("JSXIdentifier")\n    },\n    name: {\n      validate: (0, _utils.assertNodeType)("JSXIdentifier")\n    }\n  }\n});\n(0, _utils.default)("JSXOpeningElement", {\n  builder: ["name", "attributes", "selfClosing"],\n  visitor: ["name", "attributes"],\n  aliases: ["JSX", "Immutable"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")\n    },\n    selfClosing: {\n      default: false\n    },\n    attributes: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)("JSXSpreadAttribute", {\n  visitor: ["argument"],\n  aliases: ["JSX"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  }\n});\n(0, _utils.default)("JSXText", {\n  aliases: ["JSX", "Immutable"],\n  builder: ["value"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)("string")\n    }\n  }\n});\n(0, _utils.default)("JSXFragment", {\n  builder: ["openingFragment", "closingFragment", "children"],\n  visitor: ["openingFragment", "children", "closingFragment"],\n  aliases: ["JSX", "Immutable", "Expression"],\n  fields: {\n    openingFragment: {\n      validate: (0, _utils.assertNodeType)("JSXOpeningFragment")\n    },\n    closingFragment: {\n      validate: (0, _utils.assertNodeType)("JSXClosingFragment")\n    },\n    children: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))\n    }\n  }\n});\n(0, _utils.default)("JSXOpeningFragment", {\n  aliases: ["JSX", "Immutable"]\n});\n(0, _utils.default)("JSXClosingFragment", {\n  aliases: ["JSX", "Immutable"]\n});\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/definitions/jsx.js?')},55030:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('\n\nvar _utils = _interopRequireWildcard(__webpack_require__(54913));\n\nvar _placeholders = __webpack_require__(29488);\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n(0, _utils.default)("Noop", {\n  visitor: []\n});\n(0, _utils.default)("Placeholder", {\n  visitor: [],\n  builder: ["expectedNode", "name"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertNodeType)("Identifier")\n    },\n    expectedNode: {\n      validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)\n    }\n  }\n});\n(0, _utils.default)("V8IntrinsicIdentifier", {\n  builder: ["name"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertValueType)("string")\n    }\n  }\n});\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/definitions/misc.js?')},29488:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS = void 0;\n\nvar _utils = __webpack_require__(54913);\n\nconst PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];\nexports.PLACEHOLDERS = PLACEHOLDERS;\nconst PLACEHOLDERS_ALIAS = {\n  Declaration: ["Statement"],\n  Pattern: ["PatternLike", "LVal"]\n};\nexports.PLACEHOLDERS_ALIAS = PLACEHOLDERS_ALIAS;\n\nfor (const type of PLACEHOLDERS) {\n  const alias = _utils.ALIAS_KEYS[type];\n  if (alias == null ? void 0 : alias.length) PLACEHOLDERS_ALIAS[type] = alias;\n}\n\nconst PLACEHOLDERS_FLIPPED_ALIAS = {};\nexports.PLACEHOLDERS_FLIPPED_ALIAS = PLACEHOLDERS_FLIPPED_ALIAS;\nObject.keys(PLACEHOLDERS_ALIAS).forEach(type => {\n  PLACEHOLDERS_ALIAS[type].forEach(alias => {\n    if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {\n      PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];\n    }\n\n    PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);\n  });\n});\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/definitions/placeholders.js?')},20045:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('\n\nvar _utils = _interopRequireWildcard(__webpack_require__(54913));\n\nvar _core = __webpack_require__(34457);\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst bool = (0, _utils.assertValueType)("boolean");\nconst tSFunctionTypeAnnotationCommon = {\n  returnType: {\n    validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),\n    optional: true\n  },\n  typeParameters: {\n    validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),\n    optional: true\n  }\n};\n(0, _utils.default)("TSParameterProperty", {\n  aliases: ["LVal"],\n  visitor: ["parameter"],\n  fields: {\n    accessibility: {\n      validate: (0, _utils.assertOneOf)("public", "private", "protected"),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      optional: true\n    },\n    parameter: {\n      validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")\n    }\n  }\n});\n(0, _utils.default)("TSDeclareFunction", {\n  aliases: ["Statement", "Declaration"],\n  visitor: ["id", "typeParameters", "params", "returnType"],\n  fields: Object.assign({}, _core.functionDeclarationCommon, tSFunctionTypeAnnotationCommon)\n});\n(0, _utils.default)("TSDeclareMethod", {\n  visitor: ["decorators", "key", "typeParameters", "params", "returnType"],\n  fields: Object.assign({}, _core.classMethodOrDeclareMethodCommon, tSFunctionTypeAnnotationCommon)\n});\n(0, _utils.default)("TSQualifiedName", {\n  aliases: ["TSEntityName"],\n  visitor: ["left", "right"],\n  fields: {\n    left: (0, _utils.validateType)("TSEntityName"),\n    right: (0, _utils.validateType)("Identifier")\n  }\n});\nconst signatureDeclarationCommon = {\n  typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),\n  parameters: (0, _utils.validateArrayOfType)(["Identifier", "RestElement"]),\n  typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")\n};\nconst callConstructSignatureDeclaration = {\n  aliases: ["TSTypeElement"],\n  visitor: ["typeParameters", "parameters", "typeAnnotation"],\n  fields: signatureDeclarationCommon\n};\n(0, _utils.default)("TSCallSignatureDeclaration", callConstructSignatureDeclaration);\n(0, _utils.default)("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);\nconst namedTypeElementCommon = {\n  key: (0, _utils.validateType)("Expression"),\n  computed: (0, _utils.validate)(bool),\n  optional: (0, _utils.validateOptional)(bool)\n};\n(0, _utils.default)("TSPropertySignature", {\n  aliases: ["TSTypeElement"],\n  visitor: ["key", "typeAnnotation", "initializer"],\n  fields: Object.assign({}, namedTypeElementCommon, {\n    readonly: (0, _utils.validateOptional)(bool),\n    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),\n    initializer: (0, _utils.validateOptionalType)("Expression")\n  })\n});\n(0, _utils.default)("TSMethodSignature", {\n  aliases: ["TSTypeElement"],\n  visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],\n  fields: Object.assign({}, signatureDeclarationCommon, namedTypeElementCommon)\n});\n(0, _utils.default)("TSIndexSignature", {\n  aliases: ["TSTypeElement"],\n  visitor: ["parameters", "typeAnnotation"],\n  fields: {\n    readonly: (0, _utils.validateOptional)(bool),\n    parameters: (0, _utils.validateArrayOfType)("Identifier"),\n    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")\n  }\n});\nconst tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];\n\nfor (const type of tsKeywordTypes) {\n  (0, _utils.default)(type, {\n    aliases: ["TSType", "TSBaseType"],\n    visitor: [],\n    fields: {}\n  });\n}\n\n(0, _utils.default)("TSThisType", {\n  aliases: ["TSType", "TSBaseType"],\n  visitor: [],\n  fields: {}\n});\nconst fnOrCtr = {\n  aliases: ["TSType"],\n  visitor: ["typeParameters", "parameters", "typeAnnotation"],\n  fields: signatureDeclarationCommon\n};\n(0, _utils.default)("TSFunctionType", fnOrCtr);\n(0, _utils.default)("TSConstructorType", fnOrCtr);\n(0, _utils.default)("TSTypeReference", {\n  aliases: ["TSType"],\n  visitor: ["typeName", "typeParameters"],\n  fields: {\n    typeName: (0, _utils.validateType)("TSEntityName"),\n    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")\n  }\n});\n(0, _utils.default)("TSTypePredicate", {\n  aliases: ["TSType"],\n  visitor: ["parameterName", "typeAnnotation"],\n  builder: ["parameterName", "typeAnnotation", "asserts"],\n  fields: {\n    parameterName: (0, _utils.validateType)(["Identifier", "TSThisType"]),\n    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),\n    asserts: (0, _utils.validateOptional)(bool)\n  }\n});\n(0, _utils.default)("TSTypeQuery", {\n  aliases: ["TSType"],\n  visitor: ["exprName"],\n  fields: {\n    exprName: (0, _utils.validateType)(["TSEntityName", "TSImportType"])\n  }\n});\n(0, _utils.default)("TSTypeLiteral", {\n  aliases: ["TSType"],\n  visitor: ["members"],\n  fields: {\n    members: (0, _utils.validateArrayOfType)("TSTypeElement")\n  }\n});\n(0, _utils.default)("TSArrayType", {\n  aliases: ["TSType"],\n  visitor: ["elementType"],\n  fields: {\n    elementType: (0, _utils.validateType)("TSType")\n  }\n});\n(0, _utils.default)("TSTupleType", {\n  aliases: ["TSType"],\n  visitor: ["elementTypes"],\n  fields: {\n    elementTypes: (0, _utils.validateArrayOfType)(["TSType", "TSNamedTupleMember"])\n  }\n});\n(0, _utils.default)("TSOptionalType", {\n  aliases: ["TSType"],\n  visitor: ["typeAnnotation"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)("TSType")\n  }\n});\n(0, _utils.default)("TSRestType", {\n  aliases: ["TSType"],\n  visitor: ["typeAnnotation"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)("TSType")\n  }\n});\n(0, _utils.default)("TSNamedTupleMember", {\n  visitor: ["label", "elementType"],\n  builder: ["label", "elementType", "optional"],\n  fields: {\n    label: (0, _utils.validateType)("Identifier"),\n    optional: {\n      validate: bool,\n      default: false\n    },\n    elementType: (0, _utils.validateType)("TSType")\n  }\n});\nconst unionOrIntersection = {\n  aliases: ["TSType"],\n  visitor: ["types"],\n  fields: {\n    types: (0, _utils.validateArrayOfType)("TSType")\n  }\n};\n(0, _utils.default)("TSUnionType", unionOrIntersection);\n(0, _utils.default)("TSIntersectionType", unionOrIntersection);\n(0, _utils.default)("TSConditionalType", {\n  aliases: ["TSType"],\n  visitor: ["checkType", "extendsType", "trueType", "falseType"],\n  fields: {\n    checkType: (0, _utils.validateType)("TSType"),\n    extendsType: (0, _utils.validateType)("TSType"),\n    trueType: (0, _utils.validateType)("TSType"),\n    falseType: (0, _utils.validateType)("TSType")\n  }\n});\n(0, _utils.default)("TSInferType", {\n  aliases: ["TSType"],\n  visitor: ["typeParameter"],\n  fields: {\n    typeParameter: (0, _utils.validateType)("TSTypeParameter")\n  }\n});\n(0, _utils.default)("TSParenthesizedType", {\n  aliases: ["TSType"],\n  visitor: ["typeAnnotation"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)("TSType")\n  }\n});\n(0, _utils.default)("TSTypeOperator", {\n  aliases: ["TSType"],\n  visitor: ["typeAnnotation"],\n  fields: {\n    operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),\n    typeAnnotation: (0, _utils.validateType)("TSType")\n  }\n});\n(0, _utils.default)("TSIndexedAccessType", {\n  aliases: ["TSType"],\n  visitor: ["objectType", "indexType"],\n  fields: {\n    objectType: (0, _utils.validateType)("TSType"),\n    indexType: (0, _utils.validateType)("TSType")\n  }\n});\n(0, _utils.default)("TSMappedType", {\n  aliases: ["TSType"],\n  visitor: ["typeParameter", "typeAnnotation", "nameType"],\n  fields: {\n    readonly: (0, _utils.validateOptional)(bool),\n    typeParameter: (0, _utils.validateType)("TSTypeParameter"),\n    optional: (0, _utils.validateOptional)(bool),\n    typeAnnotation: (0, _utils.validateOptionalType)("TSType"),\n    nameType: (0, _utils.validateOptionalType)("TSType")\n  }\n});\n(0, _utils.default)("TSLiteralType", {\n  aliases: ["TSType", "TSBaseType"],\n  visitor: ["literal"],\n  fields: {\n    literal: (0, _utils.validateType)(["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral"])\n  }\n});\n(0, _utils.default)("TSExpressionWithTypeArguments", {\n  aliases: ["TSType"],\n  visitor: ["expression", "typeParameters"],\n  fields: {\n    expression: (0, _utils.validateType)("TSEntityName"),\n    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")\n  }\n});\n(0, _utils.default)("TSInterfaceDeclaration", {\n  aliases: ["Statement", "Declaration"],\n  visitor: ["id", "typeParameters", "extends", "body"],\n  fields: {\n    declare: (0, _utils.validateOptional)(bool),\n    id: (0, _utils.validateType)("Identifier"),\n    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),\n    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),\n    body: (0, _utils.validateType)("TSInterfaceBody")\n  }\n});\n(0, _utils.default)("TSInterfaceBody", {\n  visitor: ["body"],\n  fields: {\n    body: (0, _utils.validateArrayOfType)("TSTypeElement")\n  }\n});\n(0, _utils.default)("TSTypeAliasDeclaration", {\n  aliases: ["Statement", "Declaration"],\n  visitor: ["id", "typeParameters", "typeAnnotation"],\n  fields: {\n    declare: (0, _utils.validateOptional)(bool),\n    id: (0, _utils.validateType)("Identifier"),\n    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),\n    typeAnnotation: (0, _utils.validateType)("TSType")\n  }\n});\n(0, _utils.default)("TSAsExpression", {\n  aliases: ["Expression"],\n  visitor: ["expression", "typeAnnotation"],\n  fields: {\n    expression: (0, _utils.validateType)("Expression"),\n    typeAnnotation: (0, _utils.validateType)("TSType")\n  }\n});\n(0, _utils.default)("TSTypeAssertion", {\n  aliases: ["Expression"],\n  visitor: ["typeAnnotation", "expression"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)("TSType"),\n    expression: (0, _utils.validateType)("Expression")\n  }\n});\n(0, _utils.default)("TSEnumDeclaration", {\n  aliases: ["Statement", "Declaration"],\n  visitor: ["id", "members"],\n  fields: {\n    declare: (0, _utils.validateOptional)(bool),\n    const: (0, _utils.validateOptional)(bool),\n    id: (0, _utils.validateType)("Identifier"),\n    members: (0, _utils.validateArrayOfType)("TSEnumMember"),\n    initializer: (0, _utils.validateOptionalType)("Expression")\n  }\n});\n(0, _utils.default)("TSEnumMember", {\n  visitor: ["id", "initializer"],\n  fields: {\n    id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),\n    initializer: (0, _utils.validateOptionalType)("Expression")\n  }\n});\n(0, _utils.default)("TSModuleDeclaration", {\n  aliases: ["Statement", "Declaration"],\n  visitor: ["id", "body"],\n  fields: {\n    declare: (0, _utils.validateOptional)(bool),\n    global: (0, _utils.validateOptional)(bool),\n    id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),\n    body: (0, _utils.validateType)(["TSModuleBlock", "TSModuleDeclaration"])\n  }\n});\n(0, _utils.default)("TSModuleBlock", {\n  aliases: ["Scopable", "Block", "BlockParent"],\n  visitor: ["body"],\n  fields: {\n    body: (0, _utils.validateArrayOfType)("Statement")\n  }\n});\n(0, _utils.default)("TSImportType", {\n  aliases: ["TSType"],\n  visitor: ["argument", "qualifier", "typeParameters"],\n  fields: {\n    argument: (0, _utils.validateType)("StringLiteral"),\n    qualifier: (0, _utils.validateOptionalType)("TSEntityName"),\n    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")\n  }\n});\n(0, _utils.default)("TSImportEqualsDeclaration", {\n  aliases: ["Statement"],\n  visitor: ["id", "moduleReference"],\n  fields: {\n    isExport: (0, _utils.validate)(bool),\n    id: (0, _utils.validateType)("Identifier"),\n    moduleReference: (0, _utils.validateType)(["TSEntityName", "TSExternalModuleReference"])\n  }\n});\n(0, _utils.default)("TSExternalModuleReference", {\n  visitor: ["expression"],\n  fields: {\n    expression: (0, _utils.validateType)("StringLiteral")\n  }\n});\n(0, _utils.default)("TSNonNullExpression", {\n  aliases: ["Expression"],\n  visitor: ["expression"],\n  fields: {\n    expression: (0, _utils.validateType)("Expression")\n  }\n});\n(0, _utils.default)("TSExportAssignment", {\n  aliases: ["Statement"],\n  visitor: ["expression"],\n  fields: {\n    expression: (0, _utils.validateType)("Expression")\n  }\n});\n(0, _utils.default)("TSNamespaceExportDeclaration", {\n  aliases: ["Statement"],\n  visitor: ["id"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier")\n  }\n});\n(0, _utils.default)("TSTypeAnnotation", {\n  visitor: ["typeAnnotation"],\n  fields: {\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)("TSType")\n    }\n  }\n});\n(0, _utils.default)("TSTypeParameterInstantiation", {\n  visitor: ["params"],\n  fields: {\n    params: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")))\n    }\n  }\n});\n(0, _utils.default)("TSTypeParameterDeclaration", {\n  visitor: ["params"],\n  fields: {\n    params: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSTypeParameter")))\n    }\n  }\n});\n(0, _utils.default)("TSTypeParameter", {\n  builder: ["constraint", "default", "name"],\n  visitor: ["constraint", "default"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertValueType)("string")\n    },\n    constraint: {\n      validate: (0, _utils.assertNodeType)("TSType"),\n      optional: true\n    },\n    default: {\n      validate: (0, _utils.assertNodeType)("TSType"),\n      optional: true\n    }\n  }\n});\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/definitions/typescript.js?')},54913:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('/* provided dependency */ var process = __webpack_require__(34155);\n\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.validate = validate;\nexports.typeIs = typeIs;\nexports.validateType = validateType;\nexports.validateOptional = validateOptional;\nexports.validateOptionalType = validateOptionalType;\nexports.arrayOf = arrayOf;\nexports.arrayOfType = arrayOfType;\nexports.validateArrayOfType = validateArrayOfType;\nexports.assertEach = assertEach;\nexports.assertOneOf = assertOneOf;\nexports.assertNodeType = assertNodeType;\nexports.assertNodeOrValueType = assertNodeOrValueType;\nexports.assertValueType = assertValueType;\nexports.assertShape = assertShape;\nexports.assertOptionalChainStart = assertOptionalChainStart;\nexports.chain = chain;\nexports.default = defineType;\nexports.NODE_PARENT_VALIDATIONS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.ALIAS_KEYS = exports.VISITOR_KEYS = void 0;\n\nvar _is = _interopRequireDefault(__webpack_require__(67275));\n\nvar _validate = __webpack_require__(43804);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst VISITOR_KEYS = {};\nexports.VISITOR_KEYS = VISITOR_KEYS;\nconst ALIAS_KEYS = {};\nexports.ALIAS_KEYS = ALIAS_KEYS;\nconst FLIPPED_ALIAS_KEYS = {};\nexports.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;\nconst NODE_FIELDS = {};\nexports.NODE_FIELDS = NODE_FIELDS;\nconst BUILDER_KEYS = {};\nexports.BUILDER_KEYS = BUILDER_KEYS;\nconst DEPRECATED_KEYS = {};\nexports.DEPRECATED_KEYS = DEPRECATED_KEYS;\nconst NODE_PARENT_VALIDATIONS = {};\nexports.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;\n\nfunction getType(val) {\n  if (Array.isArray(val)) {\n    return "array";\n  } else if (val === null) {\n    return "null";\n  } else {\n    return typeof val;\n  }\n}\n\nfunction validate(validate) {\n  return {\n    validate\n  };\n}\n\nfunction typeIs(typeName) {\n  return typeof typeName === "string" ? assertNodeType(typeName) : assertNodeType(...typeName);\n}\n\nfunction validateType(typeName) {\n  return validate(typeIs(typeName));\n}\n\nfunction validateOptional(validate) {\n  return {\n    validate,\n    optional: true\n  };\n}\n\nfunction validateOptionalType(typeName) {\n  return {\n    validate: typeIs(typeName),\n    optional: true\n  };\n}\n\nfunction arrayOf(elementType) {\n  return chain(assertValueType("array"), assertEach(elementType));\n}\n\nfunction arrayOfType(typeName) {\n  return arrayOf(typeIs(typeName));\n}\n\nfunction validateArrayOfType(typeName) {\n  return validate(arrayOfType(typeName));\n}\n\nfunction assertEach(callback) {\n  function validator(node, key, val) {\n    if (!Array.isArray(val)) return;\n\n    for (let i = 0; i < val.length; i++) {\n      const subkey = `${key}[${i}]`;\n      const v = val[i];\n      callback(node, subkey, v);\n      if (process.env.BABEL_TYPES_8_BREAKING) (0, _validate.validateChild)(node, subkey, v);\n    }\n  }\n\n  validator.each = callback;\n  return validator;\n}\n\nfunction assertOneOf(...values) {\n  function validate(node, key, val) {\n    if (values.indexOf(val) < 0) {\n      throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);\n    }\n  }\n\n  validate.oneOf = values;\n  return validate;\n}\n\nfunction assertNodeType(...types) {\n  function validate(node, key, val) {\n    for (const type of types) {\n      if ((0, _is.default)(type, val)) {\n        (0, _validate.validateChild)(node, key, val);\n        return;\n      }\n    }\n\n    throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);\n  }\n\n  validate.oneOfNodeTypes = types;\n  return validate;\n}\n\nfunction assertNodeOrValueType(...types) {\n  function validate(node, key, val) {\n    for (const type of types) {\n      if (getType(val) === type || (0, _is.default)(type, val)) {\n        (0, _validate.validateChild)(node, key, val);\n        return;\n      }\n    }\n\n    throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);\n  }\n\n  validate.oneOfNodeOrValueTypes = types;\n  return validate;\n}\n\nfunction assertValueType(type) {\n  function validate(node, key, val) {\n    const valid = getType(val) === type;\n\n    if (!valid) {\n      throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);\n    }\n  }\n\n  validate.type = type;\n  return validate;\n}\n\nfunction assertShape(shape) {\n  function validate(node, key, val) {\n    const errors = [];\n\n    for (const property of Object.keys(shape)) {\n      try {\n        (0, _validate.validateField)(node, property, val[property], shape[property]);\n      } catch (error) {\n        if (error instanceof TypeError) {\n          errors.push(error.message);\n          continue;\n        }\n\n        throw error;\n      }\n    }\n\n    if (errors.length) {\n      throw new TypeError(`Property ${key} of ${node.type} expected to have the following:\\n${errors.join("\\n")}`);\n    }\n  }\n\n  validate.shapeOf = shape;\n  return validate;\n}\n\nfunction assertOptionalChainStart() {\n  function validate(node) {\n    var _current;\n\n    let current = node;\n\n    while (node) {\n      const {\n        type\n      } = current;\n\n      if (type === "OptionalCallExpression") {\n        if (current.optional) return;\n        current = current.callee;\n        continue;\n      }\n\n      if (type === "OptionalMemberExpression") {\n        if (current.optional) return;\n        current = current.object;\n        continue;\n      }\n\n      break;\n    }\n\n    throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);\n  }\n\n  return validate;\n}\n\nfunction chain(...fns) {\n  const validate = function (...args) {\n    for (const fn of fns) {\n      fn(...args);\n    }\n  };\n\n  validate.chainOf = fns;\n  return validate;\n}\n\nconst validTypeOpts = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"];\nconst validFieldKeys = ["default", "optional", "validate"];\n\nfunction defineType(type, opts = {}) {\n  const inherits = opts.inherits && store[opts.inherits] || {};\n  let fields = opts.fields;\n\n  if (!fields) {\n    fields = {};\n\n    if (inherits.fields) {\n      const keys = Object.getOwnPropertyNames(inherits.fields);\n\n      for (const key of keys) {\n        const field = inherits.fields[key];\n        fields[key] = {\n          default: field.default,\n          optional: field.optional,\n          validate: field.validate\n        };\n      }\n    }\n  }\n\n  const visitor = opts.visitor || inherits.visitor || [];\n  const aliases = opts.aliases || inherits.aliases || [];\n  const builder = opts.builder || inherits.builder || opts.visitor || [];\n\n  for (const k of Object.keys(opts)) {\n    if (validTypeOpts.indexOf(k) === -1) {\n      throw new Error(`Unknown type option "${k}" on ${type}`);\n    }\n  }\n\n  if (opts.deprecatedAlias) {\n    DEPRECATED_KEYS[opts.deprecatedAlias] = type;\n  }\n\n  for (const key of visitor.concat(builder)) {\n    fields[key] = fields[key] || {};\n  }\n\n  for (const key of Object.keys(fields)) {\n    const field = fields[key];\n\n    if (field.default !== undefined && builder.indexOf(key) === -1) {\n      field.optional = true;\n    }\n\n    if (field.default === undefined) {\n      field.default = null;\n    } else if (!field.validate && field.default != null) {\n      field.validate = assertValueType(getType(field.default));\n    }\n\n    for (const k of Object.keys(field)) {\n      if (validFieldKeys.indexOf(k) === -1) {\n        throw new Error(`Unknown field key "${k}" on ${type}.${key}`);\n      }\n    }\n  }\n\n  VISITOR_KEYS[type] = opts.visitor = visitor;\n  BUILDER_KEYS[type] = opts.builder = builder;\n  NODE_FIELDS[type] = opts.fields = fields;\n  ALIAS_KEYS[type] = opts.aliases = aliases;\n  aliases.forEach(alias => {\n    FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];\n    FLIPPED_ALIAS_KEYS[alias].push(type);\n  });\n\n  if (opts.validate) {\n    NODE_PARENT_VALIDATIONS[type] = opts.validate;\n  }\n\n  store[type] = opts;\n}\n\nconst store = {};\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/definitions/utils.js?')},38218:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nvar _exportNames = {\n  react: true,\n  assertNode: true,\n  createTypeAnnotationBasedOnTypeof: true,\n  createUnionTypeAnnotation: true,\n  createFlowUnionType: true,\n  createTSUnionType: true,\n  cloneNode: true,\n  clone: true,\n  cloneDeep: true,\n  cloneDeepWithoutLoc: true,\n  cloneWithoutLoc: true,\n  addComment: true,\n  addComments: true,\n  inheritInnerComments: true,\n  inheritLeadingComments: true,\n  inheritsComments: true,\n  inheritTrailingComments: true,\n  removeComments: true,\n  ensureBlock: true,\n  toBindingIdentifierName: true,\n  toBlock: true,\n  toComputedKey: true,\n  toExpression: true,\n  toIdentifier: true,\n  toKeyAlias: true,\n  toSequenceExpression: true,\n  toStatement: true,\n  valueToNode: true,\n  appendToMemberExpression: true,\n  inherits: true,\n  prependToMemberExpression: true,\n  removeProperties: true,\n  removePropertiesDeep: true,\n  removeTypeDuplicates: true,\n  getBindingIdentifiers: true,\n  getOuterBindingIdentifiers: true,\n  traverse: true,\n  traverseFast: true,\n  shallowEqual: true,\n  is: true,\n  isBinding: true,\n  isBlockScoped: true,\n  isImmutable: true,\n  isLet: true,\n  isNode: true,\n  isNodesEquivalent: true,\n  isPlaceholderType: true,\n  isReferenced: true,\n  isScope: true,\n  isSpecifierDefault: true,\n  isType: true,\n  isValidES3Identifier: true,\n  isValidIdentifier: true,\n  isVar: true,\n  matchesPattern: true,\n  validate: true,\n  buildMatchMemberExpression: true\n};\nObject.defineProperty(exports, "assertNode", ({\n  enumerable: true,\n  get: function () {\n    return _assertNode.default;\n  }\n}));\nObject.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", ({\n  enumerable: true,\n  get: function () {\n    return _createTypeAnnotationBasedOnTypeof.default;\n  }\n}));\nObject.defineProperty(exports, "createUnionTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _createFlowUnionType.default;\n  }\n}));\nObject.defineProperty(exports, "createFlowUnionType", ({\n  enumerable: true,\n  get: function () {\n    return _createFlowUnionType.default;\n  }\n}));\nObject.defineProperty(exports, "createTSUnionType", ({\n  enumerable: true,\n  get: function () {\n    return _createTSUnionType.default;\n  }\n}));\nObject.defineProperty(exports, "cloneNode", ({\n  enumerable: true,\n  get: function () {\n    return _cloneNode.default;\n  }\n}));\nObject.defineProperty(exports, "clone", ({\n  enumerable: true,\n  get: function () {\n    return _clone.default;\n  }\n}));\nObject.defineProperty(exports, "cloneDeep", ({\n  enumerable: true,\n  get: function () {\n    return _cloneDeep.default;\n  }\n}));\nObject.defineProperty(exports, "cloneDeepWithoutLoc", ({\n  enumerable: true,\n  get: function () {\n    return _cloneDeepWithoutLoc.default;\n  }\n}));\nObject.defineProperty(exports, "cloneWithoutLoc", ({\n  enumerable: true,\n  get: function () {\n    return _cloneWithoutLoc.default;\n  }\n}));\nObject.defineProperty(exports, "addComment", ({\n  enumerable: true,\n  get: function () {\n    return _addComment.default;\n  }\n}));\nObject.defineProperty(exports, "addComments", ({\n  enumerable: true,\n  get: function () {\n    return _addComments.default;\n  }\n}));\nObject.defineProperty(exports, "inheritInnerComments", ({\n  enumerable: true,\n  get: function () {\n    return _inheritInnerComments.default;\n  }\n}));\nObject.defineProperty(exports, "inheritLeadingComments", ({\n  enumerable: true,\n  get: function () {\n    return _inheritLeadingComments.default;\n  }\n}));\nObject.defineProperty(exports, "inheritsComments", ({\n  enumerable: true,\n  get: function () {\n    return _inheritsComments.default;\n  }\n}));\nObject.defineProperty(exports, "inheritTrailingComments", ({\n  enumerable: true,\n  get: function () {\n    return _inheritTrailingComments.default;\n  }\n}));\nObject.defineProperty(exports, "removeComments", ({\n  enumerable: true,\n  get: function () {\n    return _removeComments.default;\n  }\n}));\nObject.defineProperty(exports, "ensureBlock", ({\n  enumerable: true,\n  get: function () {\n    return _ensureBlock.default;\n  }\n}));\nObject.defineProperty(exports, "toBindingIdentifierName", ({\n  enumerable: true,\n  get: function () {\n    return _toBindingIdentifierName.default;\n  }\n}));\nObject.defineProperty(exports, "toBlock", ({\n  enumerable: true,\n  get: function () {\n    return _toBlock.default;\n  }\n}));\nObject.defineProperty(exports, "toComputedKey", ({\n  enumerable: true,\n  get: function () {\n    return _toComputedKey.default;\n  }\n}));\nObject.defineProperty(exports, "toExpression", ({\n  enumerable: true,\n  get: function () {\n    return _toExpression.default;\n  }\n}));\nObject.defineProperty(exports, "toIdentifier", ({\n  enumerable: true,\n  get: function () {\n    return _toIdentifier.default;\n  }\n}));\nObject.defineProperty(exports, "toKeyAlias", ({\n  enumerable: true,\n  get: function () {\n    return _toKeyAlias.default;\n  }\n}));\nObject.defineProperty(exports, "toSequenceExpression", ({\n  enumerable: true,\n  get: function () {\n    return _toSequenceExpression.default;\n  }\n}));\nObject.defineProperty(exports, "toStatement", ({\n  enumerable: true,\n  get: function () {\n    return _toStatement.default;\n  }\n}));\nObject.defineProperty(exports, "valueToNode", ({\n  enumerable: true,\n  get: function () {\n    return _valueToNode.default;\n  }\n}));\nObject.defineProperty(exports, "appendToMemberExpression", ({\n  enumerable: true,\n  get: function () {\n    return _appendToMemberExpression.default;\n  }\n}));\nObject.defineProperty(exports, "inherits", ({\n  enumerable: true,\n  get: function () {\n    return _inherits.default;\n  }\n}));\nObject.defineProperty(exports, "prependToMemberExpression", ({\n  enumerable: true,\n  get: function () {\n    return _prependToMemberExpression.default;\n  }\n}));\nObject.defineProperty(exports, "removeProperties", ({\n  enumerable: true,\n  get: function () {\n    return _removeProperties.default;\n  }\n}));\nObject.defineProperty(exports, "removePropertiesDeep", ({\n  enumerable: true,\n  get: function () {\n    return _removePropertiesDeep.default;\n  }\n}));\nObject.defineProperty(exports, "removeTypeDuplicates", ({\n  enumerable: true,\n  get: function () {\n    return _removeTypeDuplicates.default;\n  }\n}));\nObject.defineProperty(exports, "getBindingIdentifiers", ({\n  enumerable: true,\n  get: function () {\n    return _getBindingIdentifiers.default;\n  }\n}));\nObject.defineProperty(exports, "getOuterBindingIdentifiers", ({\n  enumerable: true,\n  get: function () {\n    return _getOuterBindingIdentifiers.default;\n  }\n}));\nObject.defineProperty(exports, "traverse", ({\n  enumerable: true,\n  get: function () {\n    return _traverse.default;\n  }\n}));\nObject.defineProperty(exports, "traverseFast", ({\n  enumerable: true,\n  get: function () {\n    return _traverseFast.default;\n  }\n}));\nObject.defineProperty(exports, "shallowEqual", ({\n  enumerable: true,\n  get: function () {\n    return _shallowEqual.default;\n  }\n}));\nObject.defineProperty(exports, "is", ({\n  enumerable: true,\n  get: function () {\n    return _is.default;\n  }\n}));\nObject.defineProperty(exports, "isBinding", ({\n  enumerable: true,\n  get: function () {\n    return _isBinding.default;\n  }\n}));\nObject.defineProperty(exports, "isBlockScoped", ({\n  enumerable: true,\n  get: function () {\n    return _isBlockScoped.default;\n  }\n}));\nObject.defineProperty(exports, "isImmutable", ({\n  enumerable: true,\n  get: function () {\n    return _isImmutable.default;\n  }\n}));\nObject.defineProperty(exports, "isLet", ({\n  enumerable: true,\n  get: function () {\n    return _isLet.default;\n  }\n}));\nObject.defineProperty(exports, "isNode", ({\n  enumerable: true,\n  get: function () {\n    return _isNode.default;\n  }\n}));\nObject.defineProperty(exports, "isNodesEquivalent", ({\n  enumerable: true,\n  get: function () {\n    return _isNodesEquivalent.default;\n  }\n}));\nObject.defineProperty(exports, "isPlaceholderType", ({\n  enumerable: true,\n  get: function () {\n    return _isPlaceholderType.default;\n  }\n}));\nObject.defineProperty(exports, "isReferenced", ({\n  enumerable: true,\n  get: function () {\n    return _isReferenced.default;\n  }\n}));\nObject.defineProperty(exports, "isScope", ({\n  enumerable: true,\n  get: function () {\n    return _isScope.default;\n  }\n}));\nObject.defineProperty(exports, "isSpecifierDefault", ({\n  enumerable: true,\n  get: function () {\n    return _isSpecifierDefault.default;\n  }\n}));\nObject.defineProperty(exports, "isType", ({\n  enumerable: true,\n  get: function () {\n    return _isType.default;\n  }\n}));\nObject.defineProperty(exports, "isValidES3Identifier", ({\n  enumerable: true,\n  get: function () {\n    return _isValidES3Identifier.default;\n  }\n}));\nObject.defineProperty(exports, "isValidIdentifier", ({\n  enumerable: true,\n  get: function () {\n    return _isValidIdentifier.default;\n  }\n}));\nObject.defineProperty(exports, "isVar", ({\n  enumerable: true,\n  get: function () {\n    return _isVar.default;\n  }\n}));\nObject.defineProperty(exports, "matchesPattern", ({\n  enumerable: true,\n  get: function () {\n    return _matchesPattern.default;\n  }\n}));\nObject.defineProperty(exports, "validate", ({\n  enumerable: true,\n  get: function () {\n    return _validate.default;\n  }\n}));\nObject.defineProperty(exports, "buildMatchMemberExpression", ({\n  enumerable: true,\n  get: function () {\n    return _buildMatchMemberExpression.default;\n  }\n}));\nexports.react = void 0;\n\nvar _isReactComponent = _interopRequireDefault(__webpack_require__(86035));\n\nvar _isCompatTag = _interopRequireDefault(__webpack_require__(13193));\n\nvar _buildChildren = _interopRequireDefault(__webpack_require__(88478));\n\nvar _assertNode = _interopRequireDefault(__webpack_require__(60245));\n\nvar _generated = __webpack_require__(27133);\n\nObject.keys(_generated).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _generated[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _generated[key];\n    }\n  });\n});\n\nvar _createTypeAnnotationBasedOnTypeof = _interopRequireDefault(__webpack_require__(40949));\n\nvar _createFlowUnionType = _interopRequireDefault(__webpack_require__(29983));\n\nvar _createTSUnionType = _interopRequireDefault(__webpack_require__(4571));\n\nvar _generated2 = __webpack_require__(34391);\n\nObject.keys(_generated2).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _generated2[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _generated2[key];\n    }\n  });\n});\n\nvar _uppercase = __webpack_require__(86104);\n\nObject.keys(_uppercase).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _uppercase[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _uppercase[key];\n    }\n  });\n});\n\nvar _cloneNode = _interopRequireDefault(__webpack_require__(46209));\n\nvar _clone = _interopRequireDefault(__webpack_require__(92363));\n\nvar _cloneDeep = _interopRequireDefault(__webpack_require__(96953));\n\nvar _cloneDeepWithoutLoc = _interopRequireDefault(__webpack_require__(90863));\n\nvar _cloneWithoutLoc = _interopRequireDefault(__webpack_require__(30748));\n\nvar _addComment = _interopRequireDefault(__webpack_require__(99529));\n\nvar _addComments = _interopRequireDefault(__webpack_require__(96182));\n\nvar _inheritInnerComments = _interopRequireDefault(__webpack_require__(6455));\n\nvar _inheritLeadingComments = _interopRequireDefault(__webpack_require__(91835));\n\nvar _inheritsComments = _interopRequireDefault(__webpack_require__(29564));\n\nvar _inheritTrailingComments = _interopRequireDefault(__webpack_require__(59653));\n\nvar _removeComments = _interopRequireDefault(__webpack_require__(91200));\n\nvar _generated3 = __webpack_require__(18267);\n\nObject.keys(_generated3).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _generated3[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _generated3[key];\n    }\n  });\n});\n\nvar _constants = __webpack_require__(36325);\n\nObject.keys(_constants).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _constants[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _constants[key];\n    }\n  });\n});\n\nvar _ensureBlock = _interopRequireDefault(__webpack_require__(44315));\n\nvar _toBindingIdentifierName = _interopRequireDefault(__webpack_require__(28316));\n\nvar _toBlock = _interopRequireDefault(__webpack_require__(19276));\n\nvar _toComputedKey = _interopRequireDefault(__webpack_require__(59434));\n\nvar _toExpression = _interopRequireDefault(__webpack_require__(33348));\n\nvar _toIdentifier = _interopRequireDefault(__webpack_require__(71309));\n\nvar _toKeyAlias = _interopRequireDefault(__webpack_require__(510));\n\nvar _toSequenceExpression = _interopRequireDefault(__webpack_require__(41435));\n\nvar _toStatement = _interopRequireDefault(__webpack_require__(22307));\n\nvar _valueToNode = _interopRequireDefault(__webpack_require__(46794));\n\nvar _definitions = __webpack_require__(46507);\n\nObject.keys(_definitions).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _definitions[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _definitions[key];\n    }\n  });\n});\n\nvar _appendToMemberExpression = _interopRequireDefault(__webpack_require__(47899));\n\nvar _inherits = _interopRequireDefault(__webpack_require__(13633));\n\nvar _prependToMemberExpression = _interopRequireDefault(__webpack_require__(73094));\n\nvar _removeProperties = _interopRequireDefault(__webpack_require__(92714));\n\nvar _removePropertiesDeep = _interopRequireDefault(__webpack_require__(94936));\n\nvar _removeTypeDuplicates = _interopRequireDefault(__webpack_require__(17321));\n\nvar _getBindingIdentifiers = _interopRequireDefault(__webpack_require__(1477));\n\nvar _getOuterBindingIdentifiers = _interopRequireDefault(__webpack_require__(92812));\n\nvar _traverse = _interopRequireWildcard(__webpack_require__(98880));\n\nObject.keys(_traverse).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _traverse[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _traverse[key];\n    }\n  });\n});\n\nvar _traverseFast = _interopRequireDefault(__webpack_require__(92862));\n\nvar _shallowEqual = _interopRequireDefault(__webpack_require__(87610));\n\nvar _is = _interopRequireDefault(__webpack_require__(67275));\n\nvar _isBinding = _interopRequireDefault(__webpack_require__(86971));\n\nvar _isBlockScoped = _interopRequireDefault(__webpack_require__(60443));\n\nvar _isImmutable = _interopRequireDefault(__webpack_require__(49268));\n\nvar _isLet = _interopRequireDefault(__webpack_require__(77182));\n\nvar _isNode = _interopRequireDefault(__webpack_require__(8523));\n\nvar _isNodesEquivalent = _interopRequireDefault(__webpack_require__(4635));\n\nvar _isPlaceholderType = _interopRequireDefault(__webpack_require__(50015));\n\nvar _isReferenced = _interopRequireDefault(__webpack_require__(24837));\n\nvar _isScope = _interopRequireDefault(__webpack_require__(46400));\n\nvar _isSpecifierDefault = _interopRequireDefault(__webpack_require__(52800));\n\nvar _isType = _interopRequireDefault(__webpack_require__(11452));\n\nvar _isValidES3Identifier = _interopRequireDefault(__webpack_require__(38917));\n\nvar _isValidIdentifier = _interopRequireDefault(__webpack_require__(93045));\n\nvar _isVar = _interopRequireDefault(__webpack_require__(90830));\n\nvar _matchesPattern = _interopRequireDefault(__webpack_require__(92205));\n\nvar _validate = _interopRequireDefault(__webpack_require__(43804));\n\nvar _buildMatchMemberExpression = _interopRequireDefault(__webpack_require__(88847));\n\nvar _generated4 = __webpack_require__(94746);\n\nObject.keys(_generated4).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _generated4[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _generated4[key];\n    }\n  });\n});\n\nvar _generated5 = __webpack_require__(91585);\n\nObject.keys(_generated5).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _generated5[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _generated5[key];\n    }\n  });\n});\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst react = {\n  isReactComponent: _isReactComponent.default,\n  isCompatTag: _isCompatTag.default,\n  buildChildren: _buildChildren.default\n};\nexports.react = react;\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/index.js?')},47899:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = appendToMemberExpression;\n\nvar _generated = __webpack_require__(34391);\n\nfunction appendToMemberExpression(member, append, computed = false) {\n  member.object = (0, _generated.memberExpression)(member.object, member.property, member.computed);\n  member.property = append;\n  member.computed = !!computed;\n  return member;\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/modifications/appendToMemberExpression.js?')},17321:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = removeTypeDuplicates;\n\nvar _generated = __webpack_require__(94746);\n\nfunction getQualifiedName(node) {\n  return (0, _generated.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;\n}\n\nfunction removeTypeDuplicates(nodes) {\n  const generics = {};\n  const bases = {};\n  const typeGroups = [];\n  const types = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!node) continue;\n\n    if (types.indexOf(node) >= 0) {\n      continue;\n    }\n\n    if ((0, _generated.isAnyTypeAnnotation)(node)) {\n      return [node];\n    }\n\n    if ((0, _generated.isFlowBaseAnnotation)(node)) {\n      bases[node.type] = node;\n      continue;\n    }\n\n    if ((0, _generated.isUnionTypeAnnotation)(node)) {\n      if (typeGroups.indexOf(node.types) < 0) {\n        nodes = nodes.concat(node.types);\n        typeGroups.push(node.types);\n      }\n\n      continue;\n    }\n\n    if ((0, _generated.isGenericTypeAnnotation)(node)) {\n      const name = getQualifiedName(node.id);\n\n      if (generics[name]) {\n        let existing = generics[name];\n\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));\n          }\n        } else {\n          existing = node.typeParameters;\n        }\n      } else {\n        generics[name] = node;\n      }\n\n      continue;\n    }\n\n    types.push(node);\n  }\n\n  for (const type of Object.keys(bases)) {\n    types.push(bases[type]);\n  }\n\n  for (const name of Object.keys(generics)) {\n    types.push(generics[name]);\n  }\n\n  return types;\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js?')},13633:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = inherits;\n\nvar _constants = __webpack_require__(36325);\n\nvar _inheritsComments = _interopRequireDefault(__webpack_require__(29564));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction inherits(child, parent) {\n  if (!child || !parent) return child;\n\n  for (const key of _constants.INHERIT_KEYS.optional) {\n    if (child[key] == null) {\n      child[key] = parent[key];\n    }\n  }\n\n  for (const key of Object.keys(parent)) {\n    if (key[0] === "_" && key !== "__clone") child[key] = parent[key];\n  }\n\n  for (const key of _constants.INHERIT_KEYS.force) {\n    child[key] = parent[key];\n  }\n\n  (0, _inheritsComments.default)(child, parent);\n  return child;\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/modifications/inherits.js?')},73094:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = prependToMemberExpression;\n\nvar _generated = __webpack_require__(34391);\n\nfunction prependToMemberExpression(member, prepend) {\n  member.object = (0, _generated.memberExpression)(prepend, member.object);\n  return member;\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/modifications/prependToMemberExpression.js?')},92714:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = removeProperties;\n\nvar _constants = __webpack_require__(36325);\n\nconst CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];\n\nconst CLEAR_KEYS_PLUS_COMMENTS = _constants.COMMENT_KEYS.concat(["comments"]).concat(CLEAR_KEYS);\n\nfunction removeProperties(node, opts = {}) {\n  const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;\n\n  for (const key of map) {\n    if (node[key] != null) node[key] = undefined;\n  }\n\n  for (const key of Object.keys(node)) {\n    if (key[0] === "_" && node[key] != null) node[key] = undefined;\n  }\n\n  const symbols = Object.getOwnPropertySymbols(node);\n\n  for (const sym of symbols) {\n    node[sym] = null;\n  }\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/modifications/removeProperties.js?')},94936:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = removePropertiesDeep;\n\nvar _traverseFast = _interopRequireDefault(__webpack_require__(92862));\n\nvar _removeProperties = _interopRequireDefault(__webpack_require__(92714));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction removePropertiesDeep(tree, opts) {\n  (0, _traverseFast.default)(tree, _removeProperties.default, opts);\n  return tree;\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/modifications/removePropertiesDeep.js?')},71954:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = removeTypeDuplicates;\n\nvar _generated = __webpack_require__(94746);\n\nfunction removeTypeDuplicates(nodes) {\n  const generics = {};\n  const bases = {};\n  const typeGroups = [];\n  const types = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!node) continue;\n\n    if (types.indexOf(node) >= 0) {\n      continue;\n    }\n\n    if ((0, _generated.isTSAnyKeyword)(node)) {\n      return [node];\n    }\n\n    if ((0, _generated.isTSBaseType)(node)) {\n      bases[node.type] = node;\n      continue;\n    }\n\n    if ((0, _generated.isTSUnionType)(node)) {\n      if (typeGroups.indexOf(node.types) < 0) {\n        nodes = nodes.concat(node.types);\n        typeGroups.push(node.types);\n      }\n\n      continue;\n    }\n\n    types.push(node);\n  }\n\n  for (const type of Object.keys(bases)) {\n    types.push(bases[type]);\n  }\n\n  for (const name of Object.keys(generics)) {\n    types.push(generics[name]);\n  }\n\n  return types;\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js?')},1477:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = getBindingIdentifiers;\n\nvar _generated = __webpack_require__(94746);\n\nfunction getBindingIdentifiers(node, duplicates, outerOnly) {\n  let search = [].concat(node);\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    const keys = getBindingIdentifiers.keys[id.type];\n\n    if ((0, _generated.isIdentifier)(id)) {\n      if (duplicates) {\n        const _ids = ids[id.name] = ids[id.name] || [];\n\n        _ids.push(id);\n      } else {\n        ids[id.name] = id;\n      }\n\n      continue;\n    }\n\n    if ((0, _generated.isExportDeclaration)(id) && !(0, _generated.isExportAllDeclaration)(id)) {\n      if ((0, _generated.isDeclaration)(id.declaration)) {\n        search.push(id.declaration);\n      }\n\n      continue;\n    }\n\n    if (outerOnly) {\n      if ((0, _generated.isFunctionDeclaration)(id)) {\n        search.push(id.id);\n        continue;\n      }\n\n      if ((0, _generated.isFunctionExpression)(id)) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n\n        if (id[key]) {\n          search = search.concat(id[key]);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\ngetBindingIdentifiers.keys = {\n  DeclareClass: ["id"],\n  DeclareFunction: ["id"],\n  DeclareModule: ["id"],\n  DeclareVariable: ["id"],\n  DeclareInterface: ["id"],\n  DeclareTypeAlias: ["id"],\n  DeclareOpaqueType: ["id"],\n  InterfaceDeclaration: ["id"],\n  TypeAlias: ["id"],\n  OpaqueType: ["id"],\n  CatchClause: ["param"],\n  LabeledStatement: ["label"],\n  UnaryExpression: ["argument"],\n  AssignmentExpression: ["left"],\n  ImportSpecifier: ["local"],\n  ImportNamespaceSpecifier: ["local"],\n  ImportDefaultSpecifier: ["local"],\n  ImportDeclaration: ["specifiers"],\n  ExportSpecifier: ["exported"],\n  ExportNamespaceSpecifier: ["exported"],\n  ExportDefaultSpecifier: ["exported"],\n  FunctionDeclaration: ["id", "params"],\n  FunctionExpression: ["id", "params"],\n  ArrowFunctionExpression: ["params"],\n  ObjectMethod: ["params"],\n  ClassMethod: ["params"],\n  ForInStatement: ["left"],\n  ForOfStatement: ["left"],\n  ClassDeclaration: ["id"],\n  ClassExpression: ["id"],\n  RestElement: ["argument"],\n  UpdateExpression: ["argument"],\n  ObjectProperty: ["value"],\n  AssignmentPattern: ["left"],\n  ArrayPattern: ["elements"],\n  ObjectPattern: ["properties"],\n  VariableDeclaration: ["declarations"],\n  VariableDeclarator: ["id"]\n};\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js?')},92812:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar _getBindingIdentifiers = _interopRequireDefault(__webpack_require__(1477));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _default = getOuterBindingIdentifiers;\nexports.default = _default;\n\nfunction getOuterBindingIdentifiers(node, duplicates) {\n  return (0, _getBindingIdentifiers.default)(node, duplicates, true);\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js?')},98880:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = traverse;\n\nvar _definitions = __webpack_require__(46507);\n\nfunction traverse(node, handlers, state) {\n  if (typeof handlers === "function") {\n    handlers = {\n      enter: handlers\n    };\n  }\n\n  const {\n    enter,\n    exit\n  } = handlers;\n  traverseSimpleImpl(node, enter, exit, state, []);\n}\n\nfunction traverseSimpleImpl(node, enter, exit, state, ancestors) {\n  const keys = _definitions.VISITOR_KEYS[node.type];\n  if (!keys) return;\n  if (enter) enter(node, ancestors, state);\n\n  for (const key of keys) {\n    const subNode = node[key];\n\n    if (Array.isArray(subNode)) {\n      for (let i = 0; i < subNode.length; i++) {\n        const child = subNode[i];\n        if (!child) continue;\n        ancestors.push({\n          node,\n          key,\n          index: i\n        });\n        traverseSimpleImpl(child, enter, exit, state, ancestors);\n        ancestors.pop();\n      }\n    } else if (subNode) {\n      ancestors.push({\n        node,\n        key\n      });\n      traverseSimpleImpl(subNode, enter, exit, state, ancestors);\n      ancestors.pop();\n    }\n  }\n\n  if (exit) exit(node, ancestors, state);\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/traverse/traverse.js?')},92862:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = traverseFast;\n\nvar _definitions = __webpack_require__(46507);\n\nfunction traverseFast(node, enter, opts) {\n  if (!node) return;\n  const keys = _definitions.VISITOR_KEYS[node.type];\n  if (!keys) return;\n  opts = opts || {};\n  enter(node, opts);\n\n  for (const key of keys) {\n    const subNode = node[key];\n\n    if (Array.isArray(subNode)) {\n      for (const node of subNode) {\n        traverseFast(node, enter, opts);\n      }\n    } else {\n      traverseFast(subNode, enter, opts);\n    }\n  }\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/traverse/traverseFast.js?')},8834:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = inherit;\n\nfunction inherit(key, child, parent) {\n  if (child && parent) {\n    child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));\n  }\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/utils/inherit.js?')},15835:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = cleanJSXElementLiteralChild;\n\nvar _generated = __webpack_require__(34391);\n\nfunction cleanJSXElementLiteralChild(child, args) {\n  const lines = child.value.split(/\\r\\n|\\n|\\r/);\n  let lastNonEmptyLine = 0;\n\n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].match(/[^ \\t]/)) {\n      lastNonEmptyLine = i;\n    }\n  }\n\n  let str = "";\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const isFirstLine = i === 0;\n    const isLastLine = i === lines.length - 1;\n    const isLastNonEmptyLine = i === lastNonEmptyLine;\n    let trimmedLine = line.replace(/\\t/g, " ");\n\n    if (!isFirstLine) {\n      trimmedLine = trimmedLine.replace(/^[ ]+/, "");\n    }\n\n    if (!isLastLine) {\n      trimmedLine = trimmedLine.replace(/[ ]+$/, "");\n    }\n\n    if (trimmedLine) {\n      if (!isLastNonEmptyLine) {\n        trimmedLine += " ";\n      }\n\n      str += trimmedLine;\n    }\n  }\n\n  if (str) args.push((0, _generated.stringLiteral)(str));\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js?')},87610:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = shallowEqual;\n\nfunction shallowEqual(actual, expected) {\n  const keys = Object.keys(expected);\n\n  for (const key of keys) {\n    if (actual[key] !== expected[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/utils/shallowEqual.js?')},88847:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = buildMatchMemberExpression;\n\nvar _matchesPattern = _interopRequireDefault(__webpack_require__(92205));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction buildMatchMemberExpression(match, allowPartial) {\n  const parts = match.split(".");\n  return member => (0, _matchesPattern.default)(member, parts, allowPartial);\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js?')},94746:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.isArrayExpression = isArrayExpression;\nexports.isAssignmentExpression = isAssignmentExpression;\nexports.isBinaryExpression = isBinaryExpression;\nexports.isInterpreterDirective = isInterpreterDirective;\nexports.isDirective = isDirective;\nexports.isDirectiveLiteral = isDirectiveLiteral;\nexports.isBlockStatement = isBlockStatement;\nexports.isBreakStatement = isBreakStatement;\nexports.isCallExpression = isCallExpression;\nexports.isCatchClause = isCatchClause;\nexports.isConditionalExpression = isConditionalExpression;\nexports.isContinueStatement = isContinueStatement;\nexports.isDebuggerStatement = isDebuggerStatement;\nexports.isDoWhileStatement = isDoWhileStatement;\nexports.isEmptyStatement = isEmptyStatement;\nexports.isExpressionStatement = isExpressionStatement;\nexports.isFile = isFile;\nexports.isForInStatement = isForInStatement;\nexports.isForStatement = isForStatement;\nexports.isFunctionDeclaration = isFunctionDeclaration;\nexports.isFunctionExpression = isFunctionExpression;\nexports.isIdentifier = isIdentifier;\nexports.isIfStatement = isIfStatement;\nexports.isLabeledStatement = isLabeledStatement;\nexports.isStringLiteral = isStringLiteral;\nexports.isNumericLiteral = isNumericLiteral;\nexports.isNullLiteral = isNullLiteral;\nexports.isBooleanLiteral = isBooleanLiteral;\nexports.isRegExpLiteral = isRegExpLiteral;\nexports.isLogicalExpression = isLogicalExpression;\nexports.isMemberExpression = isMemberExpression;\nexports.isNewExpression = isNewExpression;\nexports.isProgram = isProgram;\nexports.isObjectExpression = isObjectExpression;\nexports.isObjectMethod = isObjectMethod;\nexports.isObjectProperty = isObjectProperty;\nexports.isRestElement = isRestElement;\nexports.isReturnStatement = isReturnStatement;\nexports.isSequenceExpression = isSequenceExpression;\nexports.isParenthesizedExpression = isParenthesizedExpression;\nexports.isSwitchCase = isSwitchCase;\nexports.isSwitchStatement = isSwitchStatement;\nexports.isThisExpression = isThisExpression;\nexports.isThrowStatement = isThrowStatement;\nexports.isTryStatement = isTryStatement;\nexports.isUnaryExpression = isUnaryExpression;\nexports.isUpdateExpression = isUpdateExpression;\nexports.isVariableDeclaration = isVariableDeclaration;\nexports.isVariableDeclarator = isVariableDeclarator;\nexports.isWhileStatement = isWhileStatement;\nexports.isWithStatement = isWithStatement;\nexports.isAssignmentPattern = isAssignmentPattern;\nexports.isArrayPattern = isArrayPattern;\nexports.isArrowFunctionExpression = isArrowFunctionExpression;\nexports.isClassBody = isClassBody;\nexports.isClassExpression = isClassExpression;\nexports.isClassDeclaration = isClassDeclaration;\nexports.isExportAllDeclaration = isExportAllDeclaration;\nexports.isExportDefaultDeclaration = isExportDefaultDeclaration;\nexports.isExportNamedDeclaration = isExportNamedDeclaration;\nexports.isExportSpecifier = isExportSpecifier;\nexports.isForOfStatement = isForOfStatement;\nexports.isImportDeclaration = isImportDeclaration;\nexports.isImportDefaultSpecifier = isImportDefaultSpecifier;\nexports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;\nexports.isImportSpecifier = isImportSpecifier;\nexports.isMetaProperty = isMetaProperty;\nexports.isClassMethod = isClassMethod;\nexports.isObjectPattern = isObjectPattern;\nexports.isSpreadElement = isSpreadElement;\nexports.isSuper = isSuper;\nexports.isTaggedTemplateExpression = isTaggedTemplateExpression;\nexports.isTemplateElement = isTemplateElement;\nexports.isTemplateLiteral = isTemplateLiteral;\nexports.isYieldExpression = isYieldExpression;\nexports.isAwaitExpression = isAwaitExpression;\nexports.isImport = isImport;\nexports.isBigIntLiteral = isBigIntLiteral;\nexports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;\nexports.isOptionalMemberExpression = isOptionalMemberExpression;\nexports.isOptionalCallExpression = isOptionalCallExpression;\nexports.isAnyTypeAnnotation = isAnyTypeAnnotation;\nexports.isArrayTypeAnnotation = isArrayTypeAnnotation;\nexports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;\nexports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;\nexports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;\nexports.isClassImplements = isClassImplements;\nexports.isDeclareClass = isDeclareClass;\nexports.isDeclareFunction = isDeclareFunction;\nexports.isDeclareInterface = isDeclareInterface;\nexports.isDeclareModule = isDeclareModule;\nexports.isDeclareModuleExports = isDeclareModuleExports;\nexports.isDeclareTypeAlias = isDeclareTypeAlias;\nexports.isDeclareOpaqueType = isDeclareOpaqueType;\nexports.isDeclareVariable = isDeclareVariable;\nexports.isDeclareExportDeclaration = isDeclareExportDeclaration;\nexports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;\nexports.isDeclaredPredicate = isDeclaredPredicate;\nexports.isExistsTypeAnnotation = isExistsTypeAnnotation;\nexports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;\nexports.isFunctionTypeParam = isFunctionTypeParam;\nexports.isGenericTypeAnnotation = isGenericTypeAnnotation;\nexports.isInferredPredicate = isInferredPredicate;\nexports.isInterfaceExtends = isInterfaceExtends;\nexports.isInterfaceDeclaration = isInterfaceDeclaration;\nexports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;\nexports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;\nexports.isMixedTypeAnnotation = isMixedTypeAnnotation;\nexports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;\nexports.isNullableTypeAnnotation = isNullableTypeAnnotation;\nexports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;\nexports.isNumberTypeAnnotation = isNumberTypeAnnotation;\nexports.isObjectTypeAnnotation = isObjectTypeAnnotation;\nexports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;\nexports.isObjectTypeCallProperty = isObjectTypeCallProperty;\nexports.isObjectTypeIndexer = isObjectTypeIndexer;\nexports.isObjectTypeProperty = isObjectTypeProperty;\nexports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;\nexports.isOpaqueType = isOpaqueType;\nexports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;\nexports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;\nexports.isStringTypeAnnotation = isStringTypeAnnotation;\nexports.isSymbolTypeAnnotation = isSymbolTypeAnnotation;\nexports.isThisTypeAnnotation = isThisTypeAnnotation;\nexports.isTupleTypeAnnotation = isTupleTypeAnnotation;\nexports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;\nexports.isTypeAlias = isTypeAlias;\nexports.isTypeAnnotation = isTypeAnnotation;\nexports.isTypeCastExpression = isTypeCastExpression;\nexports.isTypeParameter = isTypeParameter;\nexports.isTypeParameterDeclaration = isTypeParameterDeclaration;\nexports.isTypeParameterInstantiation = isTypeParameterInstantiation;\nexports.isUnionTypeAnnotation = isUnionTypeAnnotation;\nexports.isVariance = isVariance;\nexports.isVoidTypeAnnotation = isVoidTypeAnnotation;\nexports.isEnumDeclaration = isEnumDeclaration;\nexports.isEnumBooleanBody = isEnumBooleanBody;\nexports.isEnumNumberBody = isEnumNumberBody;\nexports.isEnumStringBody = isEnumStringBody;\nexports.isEnumSymbolBody = isEnumSymbolBody;\nexports.isEnumBooleanMember = isEnumBooleanMember;\nexports.isEnumNumberMember = isEnumNumberMember;\nexports.isEnumStringMember = isEnumStringMember;\nexports.isEnumDefaultedMember = isEnumDefaultedMember;\nexports.isJSXAttribute = isJSXAttribute;\nexports.isJSXClosingElement = isJSXClosingElement;\nexports.isJSXElement = isJSXElement;\nexports.isJSXEmptyExpression = isJSXEmptyExpression;\nexports.isJSXExpressionContainer = isJSXExpressionContainer;\nexports.isJSXSpreadChild = isJSXSpreadChild;\nexports.isJSXIdentifier = isJSXIdentifier;\nexports.isJSXMemberExpression = isJSXMemberExpression;\nexports.isJSXNamespacedName = isJSXNamespacedName;\nexports.isJSXOpeningElement = isJSXOpeningElement;\nexports.isJSXSpreadAttribute = isJSXSpreadAttribute;\nexports.isJSXText = isJSXText;\nexports.isJSXFragment = isJSXFragment;\nexports.isJSXOpeningFragment = isJSXOpeningFragment;\nexports.isJSXClosingFragment = isJSXClosingFragment;\nexports.isNoop = isNoop;\nexports.isPlaceholder = isPlaceholder;\nexports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;\nexports.isArgumentPlaceholder = isArgumentPlaceholder;\nexports.isBindExpression = isBindExpression;\nexports.isClassProperty = isClassProperty;\nexports.isPipelineTopicExpression = isPipelineTopicExpression;\nexports.isPipelineBareFunction = isPipelineBareFunction;\nexports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;\nexports.isClassPrivateProperty = isClassPrivateProperty;\nexports.isClassPrivateMethod = isClassPrivateMethod;\nexports.isImportAttribute = isImportAttribute;\nexports.isDecorator = isDecorator;\nexports.isDoExpression = isDoExpression;\nexports.isExportDefaultSpecifier = isExportDefaultSpecifier;\nexports.isPrivateName = isPrivateName;\nexports.isRecordExpression = isRecordExpression;\nexports.isTupleExpression = isTupleExpression;\nexports.isDecimalLiteral = isDecimalLiteral;\nexports.isStaticBlock = isStaticBlock;\nexports.isTSParameterProperty = isTSParameterProperty;\nexports.isTSDeclareFunction = isTSDeclareFunction;\nexports.isTSDeclareMethod = isTSDeclareMethod;\nexports.isTSQualifiedName = isTSQualifiedName;\nexports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;\nexports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;\nexports.isTSPropertySignature = isTSPropertySignature;\nexports.isTSMethodSignature = isTSMethodSignature;\nexports.isTSIndexSignature = isTSIndexSignature;\nexports.isTSAnyKeyword = isTSAnyKeyword;\nexports.isTSBooleanKeyword = isTSBooleanKeyword;\nexports.isTSBigIntKeyword = isTSBigIntKeyword;\nexports.isTSIntrinsicKeyword = isTSIntrinsicKeyword;\nexports.isTSNeverKeyword = isTSNeverKeyword;\nexports.isTSNullKeyword = isTSNullKeyword;\nexports.isTSNumberKeyword = isTSNumberKeyword;\nexports.isTSObjectKeyword = isTSObjectKeyword;\nexports.isTSStringKeyword = isTSStringKeyword;\nexports.isTSSymbolKeyword = isTSSymbolKeyword;\nexports.isTSUndefinedKeyword = isTSUndefinedKeyword;\nexports.isTSUnknownKeyword = isTSUnknownKeyword;\nexports.isTSVoidKeyword = isTSVoidKeyword;\nexports.isTSThisType = isTSThisType;\nexports.isTSFunctionType = isTSFunctionType;\nexports.isTSConstructorType = isTSConstructorType;\nexports.isTSTypeReference = isTSTypeReference;\nexports.isTSTypePredicate = isTSTypePredicate;\nexports.isTSTypeQuery = isTSTypeQuery;\nexports.isTSTypeLiteral = isTSTypeLiteral;\nexports.isTSArrayType = isTSArrayType;\nexports.isTSTupleType = isTSTupleType;\nexports.isTSOptionalType = isTSOptionalType;\nexports.isTSRestType = isTSRestType;\nexports.isTSNamedTupleMember = isTSNamedTupleMember;\nexports.isTSUnionType = isTSUnionType;\nexports.isTSIntersectionType = isTSIntersectionType;\nexports.isTSConditionalType = isTSConditionalType;\nexports.isTSInferType = isTSInferType;\nexports.isTSParenthesizedType = isTSParenthesizedType;\nexports.isTSTypeOperator = isTSTypeOperator;\nexports.isTSIndexedAccessType = isTSIndexedAccessType;\nexports.isTSMappedType = isTSMappedType;\nexports.isTSLiteralType = isTSLiteralType;\nexports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;\nexports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;\nexports.isTSInterfaceBody = isTSInterfaceBody;\nexports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;\nexports.isTSAsExpression = isTSAsExpression;\nexports.isTSTypeAssertion = isTSTypeAssertion;\nexports.isTSEnumDeclaration = isTSEnumDeclaration;\nexports.isTSEnumMember = isTSEnumMember;\nexports.isTSModuleDeclaration = isTSModuleDeclaration;\nexports.isTSModuleBlock = isTSModuleBlock;\nexports.isTSImportType = isTSImportType;\nexports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;\nexports.isTSExternalModuleReference = isTSExternalModuleReference;\nexports.isTSNonNullExpression = isTSNonNullExpression;\nexports.isTSExportAssignment = isTSExportAssignment;\nexports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;\nexports.isTSTypeAnnotation = isTSTypeAnnotation;\nexports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;\nexports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;\nexports.isTSTypeParameter = isTSTypeParameter;\nexports.isExpression = isExpression;\nexports.isBinary = isBinary;\nexports.isScopable = isScopable;\nexports.isBlockParent = isBlockParent;\nexports.isBlock = isBlock;\nexports.isStatement = isStatement;\nexports.isTerminatorless = isTerminatorless;\nexports.isCompletionStatement = isCompletionStatement;\nexports.isConditional = isConditional;\nexports.isLoop = isLoop;\nexports.isWhile = isWhile;\nexports.isExpressionWrapper = isExpressionWrapper;\nexports.isFor = isFor;\nexports.isForXStatement = isForXStatement;\nexports.isFunction = isFunction;\nexports.isFunctionParent = isFunctionParent;\nexports.isPureish = isPureish;\nexports.isDeclaration = isDeclaration;\nexports.isPatternLike = isPatternLike;\nexports.isLVal = isLVal;\nexports.isTSEntityName = isTSEntityName;\nexports.isLiteral = isLiteral;\nexports.isImmutable = isImmutable;\nexports.isUserWhitespacable = isUserWhitespacable;\nexports.isMethod = isMethod;\nexports.isObjectMember = isObjectMember;\nexports.isProperty = isProperty;\nexports.isUnaryLike = isUnaryLike;\nexports.isPattern = isPattern;\nexports.isClass = isClass;\nexports.isModuleDeclaration = isModuleDeclaration;\nexports.isExportDeclaration = isExportDeclaration;\nexports.isModuleSpecifier = isModuleSpecifier;\nexports.isFlow = isFlow;\nexports.isFlowType = isFlowType;\nexports.isFlowBaseAnnotation = isFlowBaseAnnotation;\nexports.isFlowDeclaration = isFlowDeclaration;\nexports.isFlowPredicate = isFlowPredicate;\nexports.isEnumBody = isEnumBody;\nexports.isEnumMember = isEnumMember;\nexports.isJSX = isJSX;\nexports.isPrivate = isPrivate;\nexports.isTSTypeElement = isTSTypeElement;\nexports.isTSType = isTSType;\nexports.isTSBaseType = isTSBaseType;\nexports.isNumberLiteral = isNumberLiteral;\nexports.isRegexLiteral = isRegexLiteral;\nexports.isRestProperty = isRestProperty;\nexports.isSpreadProperty = isSpreadProperty;\n\nvar _shallowEqual = _interopRequireDefault(__webpack_require__(87610));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isArrayExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ArrayExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isAssignmentExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "AssignmentExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isBinaryExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "BinaryExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isInterpreterDirective(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "InterpreterDirective") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDirective(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "Directive") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDirectiveLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "DirectiveLiteral") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isBlockStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "BlockStatement") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isBreakStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "BreakStatement") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isCallExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "CallExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isCatchClause(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "CatchClause") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isConditionalExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ConditionalExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isContinueStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ContinueStatement") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDebuggerStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "DebuggerStatement") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDoWhileStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "DoWhileStatement") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isEmptyStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "EmptyStatement") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isExpressionStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ExpressionStatement") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isFile(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "File") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isForInStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ForInStatement") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isForStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ForStatement") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isFunctionDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "FunctionDeclaration") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isFunctionExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "FunctionExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isIdentifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "Identifier") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isIfStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "IfStatement") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isLabeledStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "LabeledStatement") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isStringLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "StringLiteral") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isNumericLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "NumericLiteral") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isNullLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "NullLiteral") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isBooleanLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "BooleanLiteral") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isRegExpLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "RegExpLiteral") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isLogicalExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "LogicalExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isMemberExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "MemberExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isNewExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "NewExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isProgram(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "Program") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isObjectExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ObjectExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isObjectMethod(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ObjectMethod") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isObjectProperty(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ObjectProperty") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isRestElement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "RestElement") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isReturnStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ReturnStatement") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isSequenceExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "SequenceExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isParenthesizedExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ParenthesizedExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isSwitchCase(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "SwitchCase") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isSwitchStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "SwitchStatement") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isThisExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ThisExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isThrowStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ThrowStatement") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTryStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TryStatement") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isUnaryExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "UnaryExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isUpdateExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "UpdateExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isVariableDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "VariableDeclaration") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isVariableDeclarator(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "VariableDeclarator") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isWhileStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "WhileStatement") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isWithStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "WithStatement") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isAssignmentPattern(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "AssignmentPattern") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isArrayPattern(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ArrayPattern") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isArrowFunctionExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ArrowFunctionExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isClassBody(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ClassBody") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isClassExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ClassExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isClassDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ClassDeclaration") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isExportAllDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ExportAllDeclaration") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isExportDefaultDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ExportDefaultDeclaration") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isExportNamedDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ExportNamedDeclaration") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isExportSpecifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ExportSpecifier") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isForOfStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ForOfStatement") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isImportDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ImportDeclaration") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isImportDefaultSpecifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ImportDefaultSpecifier") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isImportNamespaceSpecifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ImportNamespaceSpecifier") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isImportSpecifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ImportSpecifier") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isMetaProperty(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "MetaProperty") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isClassMethod(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ClassMethod") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isObjectPattern(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ObjectPattern") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isSpreadElement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "SpreadElement") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isSuper(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "Super") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTaggedTemplateExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TaggedTemplateExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTemplateElement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TemplateElement") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTemplateLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TemplateLiteral") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isYieldExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "YieldExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isAwaitExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "AwaitExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isImport(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "Import") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isBigIntLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "BigIntLiteral") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isExportNamespaceSpecifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ExportNamespaceSpecifier") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isOptionalMemberExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "OptionalMemberExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isOptionalCallExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "OptionalCallExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isAnyTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "AnyTypeAnnotation") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isArrayTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ArrayTypeAnnotation") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isBooleanTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "BooleanTypeAnnotation") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isBooleanLiteralTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "BooleanLiteralTypeAnnotation") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isNullLiteralTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "NullLiteralTypeAnnotation") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isClassImplements(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ClassImplements") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDeclareClass(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "DeclareClass") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDeclareFunction(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "DeclareFunction") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDeclareInterface(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "DeclareInterface") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDeclareModule(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "DeclareModule") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDeclareModuleExports(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "DeclareModuleExports") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDeclareTypeAlias(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "DeclareTypeAlias") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDeclareOpaqueType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "DeclareOpaqueType") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDeclareVariable(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "DeclareVariable") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDeclareExportDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "DeclareExportDeclaration") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDeclareExportAllDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "DeclareExportAllDeclaration") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDeclaredPredicate(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "DeclaredPredicate") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isExistsTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ExistsTypeAnnotation") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isFunctionTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "FunctionTypeAnnotation") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isFunctionTypeParam(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "FunctionTypeParam") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isGenericTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "GenericTypeAnnotation") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isInferredPredicate(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "InferredPredicate") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isInterfaceExtends(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "InterfaceExtends") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isInterfaceDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "InterfaceDeclaration") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isInterfaceTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "InterfaceTypeAnnotation") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isIntersectionTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "IntersectionTypeAnnotation") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isMixedTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "MixedTypeAnnotation") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isEmptyTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "EmptyTypeAnnotation") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isNullableTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "NullableTypeAnnotation") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isNumberLiteralTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "NumberLiteralTypeAnnotation") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isNumberTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "NumberTypeAnnotation") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isObjectTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ObjectTypeAnnotation") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isObjectTypeInternalSlot(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ObjectTypeInternalSlot") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isObjectTypeCallProperty(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ObjectTypeCallProperty") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isObjectTypeIndexer(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ObjectTypeIndexer") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isObjectTypeProperty(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ObjectTypeProperty") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isObjectTypeSpreadProperty(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ObjectTypeSpreadProperty") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isOpaqueType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "OpaqueType") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isQualifiedTypeIdentifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "QualifiedTypeIdentifier") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isStringLiteralTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "StringLiteralTypeAnnotation") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isStringTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "StringTypeAnnotation") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isSymbolTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "SymbolTypeAnnotation") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isThisTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ThisTypeAnnotation") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTupleTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TupleTypeAnnotation") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTypeofTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TypeofTypeAnnotation") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTypeAlias(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TypeAlias") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TypeAnnotation") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTypeCastExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TypeCastExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTypeParameter(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TypeParameter") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTypeParameterDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TypeParameterDeclaration") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTypeParameterInstantiation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TypeParameterInstantiation") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isUnionTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "UnionTypeAnnotation") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isVariance(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "Variance") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isVoidTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "VoidTypeAnnotation") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isEnumDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "EnumDeclaration") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isEnumBooleanBody(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "EnumBooleanBody") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isEnumNumberBody(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "EnumNumberBody") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isEnumStringBody(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "EnumStringBody") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isEnumSymbolBody(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "EnumSymbolBody") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isEnumBooleanMember(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "EnumBooleanMember") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isEnumNumberMember(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "EnumNumberMember") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isEnumStringMember(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "EnumStringMember") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isEnumDefaultedMember(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "EnumDefaultedMember") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSXAttribute(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "JSXAttribute") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSXClosingElement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "JSXClosingElement") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSXElement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "JSXElement") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSXEmptyExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "JSXEmptyExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSXExpressionContainer(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "JSXExpressionContainer") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSXSpreadChild(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "JSXSpreadChild") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSXIdentifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "JSXIdentifier") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSXMemberExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "JSXMemberExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSXNamespacedName(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "JSXNamespacedName") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSXOpeningElement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "JSXOpeningElement") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSXSpreadAttribute(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "JSXSpreadAttribute") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSXText(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "JSXText") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSXFragment(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "JSXFragment") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSXOpeningFragment(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "JSXOpeningFragment") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSXClosingFragment(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "JSXClosingFragment") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isNoop(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "Noop") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isPlaceholder(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "Placeholder") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isV8IntrinsicIdentifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "V8IntrinsicIdentifier") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isArgumentPlaceholder(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ArgumentPlaceholder") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isBindExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "BindExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isClassProperty(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ClassProperty") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isPipelineTopicExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "PipelineTopicExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isPipelineBareFunction(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "PipelineBareFunction") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isPipelinePrimaryTopicReference(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "PipelinePrimaryTopicReference") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isClassPrivateProperty(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ClassPrivateProperty") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isClassPrivateMethod(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ClassPrivateMethod") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isImportAttribute(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ImportAttribute") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDecorator(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "Decorator") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDoExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "DoExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isExportDefaultSpecifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "ExportDefaultSpecifier") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isPrivateName(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "PrivateName") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isRecordExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "RecordExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTupleExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TupleExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDecimalLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "DecimalLiteral") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isStaticBlock(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "StaticBlock") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSParameterProperty(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSParameterProperty") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSDeclareFunction(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSDeclareFunction") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSDeclareMethod(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSDeclareMethod") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSQualifiedName(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSQualifiedName") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSCallSignatureDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSCallSignatureDeclaration") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSConstructSignatureDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSConstructSignatureDeclaration") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSPropertySignature(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSPropertySignature") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSMethodSignature(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSMethodSignature") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSIndexSignature(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSIndexSignature") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSAnyKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSAnyKeyword") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSBooleanKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSBooleanKeyword") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSBigIntKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSBigIntKeyword") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSIntrinsicKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSIntrinsicKeyword") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSNeverKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSNeverKeyword") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSNullKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSNullKeyword") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSNumberKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSNumberKeyword") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSObjectKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSObjectKeyword") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSStringKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSStringKeyword") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSSymbolKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSSymbolKeyword") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSUndefinedKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSUndefinedKeyword") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSUnknownKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSUnknownKeyword") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSVoidKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSVoidKeyword") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSThisType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSThisType") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSFunctionType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSFunctionType") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSConstructorType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSConstructorType") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSTypeReference(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSTypeReference") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSTypePredicate(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSTypePredicate") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSTypeQuery(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSTypeQuery") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSTypeLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSTypeLiteral") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSArrayType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSArrayType") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSTupleType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSTupleType") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSOptionalType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSOptionalType") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSRestType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSRestType") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSNamedTupleMember(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSNamedTupleMember") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSUnionType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSUnionType") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSIntersectionType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSIntersectionType") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSConditionalType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSConditionalType") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSInferType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSInferType") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSParenthesizedType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSParenthesizedType") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSTypeOperator(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSTypeOperator") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSIndexedAccessType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSIndexedAccessType") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSMappedType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSMappedType") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSLiteralType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSLiteralType") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSExpressionWithTypeArguments(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSExpressionWithTypeArguments") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSInterfaceDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSInterfaceDeclaration") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSInterfaceBody(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSInterfaceBody") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSTypeAliasDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSTypeAliasDeclaration") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSAsExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSAsExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSTypeAssertion(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSTypeAssertion") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSEnumDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSEnumDeclaration") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSEnumMember(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSEnumMember") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSModuleDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSModuleDeclaration") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSModuleBlock(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSModuleBlock") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSImportType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSImportType") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSImportEqualsDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSImportEqualsDeclaration") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSExternalModuleReference(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSExternalModuleReference") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSNonNullExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSNonNullExpression") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSExportAssignment(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSExportAssignment") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSNamespaceExportDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSNamespaceExportDeclaration") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSTypeAnnotation") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSTypeParameterInstantiation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSTypeParameterInstantiation") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSTypeParameterDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSTypeParameterDeclaration") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSTypeParameter(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "TSTypeParameter") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "CallExpression" === nodeType || "ConditionalExpression" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "ObjectExpression" === nodeType || "SequenceExpression" === nodeType || "ParenthesizedExpression" === nodeType || "ThisExpression" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "MetaProperty" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType || "Import" === nodeType || "BigIntLiteral" === nodeType || "OptionalMemberExpression" === nodeType || "OptionalCallExpression" === nodeType || "TypeCastExpression" === nodeType || "JSXElement" === nodeType || "JSXFragment" === nodeType || "BindExpression" === nodeType || "PipelinePrimaryTopicReference" === nodeType || "DoExpression" === nodeType || "RecordExpression" === nodeType || "TupleExpression" === nodeType || "DecimalLiteral" === nodeType || "TSAsExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSNonNullExpression" === nodeType || nodeType === "Placeholder" && ("Expression" === node.expectedNode || "Identifier" === node.expectedNode || "StringLiteral" === node.expectedNode)) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isBinary(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("BinaryExpression" === nodeType || "LogicalExpression" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isScopable(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isBlockParent(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isBlock(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("BlockStatement" === nodeType || "Program" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("BlockStatement" === nodeType || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "ReturnStatement" === nodeType || "SwitchStatement" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "VariableDeclaration" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType || nodeType === "Placeholder" && ("Statement" === node.expectedNode || "Declaration" === node.expectedNode || "BlockStatement" === node.expectedNode)) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTerminatorless(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isCompletionStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isConditional(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("ConditionalExpression" === nodeType || "IfStatement" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isLoop(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "WhileStatement" === nodeType || "ForOfStatement" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isWhile(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("DoWhileStatement" === nodeType || "WhileStatement" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isExpressionWrapper(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("ExpressionStatement" === nodeType || "ParenthesizedExpression" === nodeType || "TypeCastExpression" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isFor(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("ForInStatement" === nodeType || "ForStatement" === nodeType || "ForOfStatement" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isForXStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("ForInStatement" === nodeType || "ForOfStatement" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isFunction(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isFunctionParent(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isPureish(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "ArrowFunctionExpression" === nodeType || "BigIntLiteral" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("FunctionDeclaration" === nodeType || "VariableDeclaration" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || nodeType === "Placeholder" && "Declaration" === node.expectedNode) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isPatternLike(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("Identifier" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isLVal(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("Identifier" === nodeType || "MemberExpression" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || "TSParameterProperty" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSEntityName(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("Identifier" === nodeType || "TSQualifiedName" === nodeType || nodeType === "Placeholder" && "Identifier" === node.expectedNode) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "TemplateLiteral" === nodeType || "BigIntLiteral" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isImmutable(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "BigIntLiteral" === nodeType || "JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXOpeningElement" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isUserWhitespacable(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isMethod(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("ObjectMethod" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isObjectMember(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("ObjectMethod" === nodeType || "ObjectProperty" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isProperty(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("ObjectProperty" === nodeType || "ClassProperty" === nodeType || "ClassPrivateProperty" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isUnaryLike(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("UnaryExpression" === nodeType || "SpreadElement" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isPattern(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && "Pattern" === node.expectedNode) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isClass(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("ClassExpression" === nodeType || "ClassDeclaration" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isModuleDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isExportDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isModuleSpecifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("ExportSpecifier" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "ExportNamespaceSpecifier" === nodeType || "ExportDefaultSpecifier" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isFlow(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ClassImplements" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "DeclaredPredicate" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "FunctionTypeParam" === nodeType || "GenericTypeAnnotation" === nodeType || "InferredPredicate" === nodeType || "InterfaceExtends" === nodeType || "InterfaceDeclaration" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType || "OpaqueType" === nodeType || "QualifiedTypeIdentifier" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "TypeAlias" === nodeType || "TypeAnnotation" === nodeType || "TypeCastExpression" === nodeType || "TypeParameter" === nodeType || "TypeParameterDeclaration" === nodeType || "TypeParameterInstantiation" === nodeType || "UnionTypeAnnotation" === nodeType || "Variance" === nodeType || "VoidTypeAnnotation" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isFlowType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "GenericTypeAnnotation" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "UnionTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isFlowBaseAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("AnyTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isFlowDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isFlowPredicate(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("DeclaredPredicate" === nodeType || "InferredPredicate" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isEnumBody(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("EnumBooleanBody" === nodeType || "EnumNumberBody" === nodeType || "EnumStringBody" === nodeType || "EnumSymbolBody" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isEnumMember(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("EnumBooleanMember" === nodeType || "EnumNumberMember" === nodeType || "EnumStringMember" === nodeType || "EnumDefaultedMember" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSX(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXEmptyExpression" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXIdentifier" === nodeType || "JSXMemberExpression" === nodeType || "JSXNamespacedName" === nodeType || "JSXOpeningElement" === nodeType || "JSXSpreadAttribute" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isPrivate(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("ClassPrivateProperty" === nodeType || "ClassPrivateMethod" === nodeType || "PrivateName" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSTypeElement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSOptionalType" === nodeType || "TSRestType" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType || "TSImportType" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSBaseType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if ("TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSLiteralType" === nodeType) {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isNumberLiteral(node, opts) {\n  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "NumberLiteral") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isRegexLiteral(node, opts) {\n  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "RegexLiteral") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isRestProperty(node, opts) {\n  console.trace("The node type RestProperty has been renamed to RestElement");\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "RestProperty") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isSpreadProperty(node, opts) {\n  console.trace("The node type SpreadProperty has been renamed to SpreadElement");\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === "SpreadProperty") {\n    if (typeof opts === "undefined") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/validators/generated/index.js?')},67275:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = is;\n\nvar _shallowEqual = _interopRequireDefault(__webpack_require__(87610));\n\nvar _isType = _interopRequireDefault(__webpack_require__(11452));\n\nvar _isPlaceholderType = _interopRequireDefault(__webpack_require__(50015));\n\nvar _definitions = __webpack_require__(46507);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction is(type, node, opts) {\n  if (!node) return false;\n  const matches = (0, _isType.default)(node.type, type);\n\n  if (!matches) {\n    if (!opts && node.type === "Placeholder" && type in _definitions.FLIPPED_ALIAS_KEYS) {\n      return (0, _isPlaceholderType.default)(node.expectedNode, type);\n    }\n\n    return false;\n  }\n\n  if (typeof opts === "undefined") {\n    return true;\n  } else {\n    return (0, _shallowEqual.default)(node, opts);\n  }\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/validators/is.js?')},86971:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = isBinding;\n\nvar _getBindingIdentifiers = _interopRequireDefault(__webpack_require__(1477));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isBinding(node, parent, grandparent) {\n  if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {\n    return false;\n  }\n\n  const keys = _getBindingIdentifiers.default.keys[parent.type];\n\n  if (keys) {\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const val = parent[key];\n\n      if (Array.isArray(val)) {\n        if (val.indexOf(node) >= 0) return true;\n      } else {\n        if (val === node) return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/validators/isBinding.js?')},60443:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = isBlockScoped;\n\nvar _generated = __webpack_require__(94746);\n\nvar _isLet = _interopRequireDefault(__webpack_require__(77182));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isBlockScoped(node) {\n  return (0, _generated.isFunctionDeclaration)(node) || (0, _generated.isClassDeclaration)(node) || (0, _isLet.default)(node);\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/validators/isBlockScoped.js?')},49268:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = isImmutable;\n\nvar _isType = _interopRequireDefault(__webpack_require__(11452));\n\nvar _generated = __webpack_require__(94746);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isImmutable(node) {\n  if ((0, _isType.default)(node.type, "Immutable")) return true;\n\n  if ((0, _generated.isIdentifier)(node)) {\n    if (node.name === "undefined") {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/validators/isImmutable.js?')},77182:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = isLet;\n\nvar _generated = __webpack_require__(94746);\n\nvar _constants = __webpack_require__(36325);\n\nfunction isLet(node) {\n  return (0, _generated.isVariableDeclaration)(node) && (node.kind !== "var" || node[_constants.BLOCK_SCOPED_SYMBOL]);\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/validators/isLet.js?')},8523:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = isNode;\n\nvar _definitions = __webpack_require__(46507);\n\nfunction isNode(node) {\n  return !!(node && _definitions.VISITOR_KEYS[node.type]);\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/validators/isNode.js?')},4635:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = isNodesEquivalent;\n\nvar _definitions = __webpack_require__(46507);\n\nfunction isNodesEquivalent(a, b) {\n  if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {\n    return a === b;\n  }\n\n  if (a.type !== b.type) {\n    return false;\n  }\n\n  const fields = Object.keys(_definitions.NODE_FIELDS[a.type] || a.type);\n  const visitorKeys = _definitions.VISITOR_KEYS[a.type];\n\n  for (const field of fields) {\n    if (typeof a[field] !== typeof b[field]) {\n      return false;\n    }\n\n    if (a[field] == null && b[field] == null) {\n      continue;\n    } else if (a[field] == null || b[field] == null) {\n      return false;\n    }\n\n    if (Array.isArray(a[field])) {\n      if (!Array.isArray(b[field])) {\n        return false;\n      }\n\n      if (a[field].length !== b[field].length) {\n        return false;\n      }\n\n      for (let i = 0; i < a[field].length; i++) {\n        if (!isNodesEquivalent(a[field][i], b[field][i])) {\n          return false;\n        }\n      }\n\n      continue;\n    }\n\n    if (typeof a[field] === "object" && !(visitorKeys == null ? void 0 : visitorKeys.includes(field))) {\n      for (const key of Object.keys(a[field])) {\n        if (a[field][key] !== b[field][key]) {\n          return false;\n        }\n      }\n\n      continue;\n    }\n\n    if (!isNodesEquivalent(a[field], b[field])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/validators/isNodesEquivalent.js?')},50015:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = isPlaceholderType;\n\nvar _definitions = __webpack_require__(46507);\n\nfunction isPlaceholderType(placeholderType, targetType) {\n  if (placeholderType === targetType) return true;\n  const aliases = _definitions.PLACEHOLDERS_ALIAS[placeholderType];\n\n  if (aliases) {\n    for (const alias of aliases) {\n      if (targetType === alias) return true;\n    }\n  }\n\n  return false;\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/validators/isPlaceholderType.js?')},24837:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = isReferenced;\n\nfunction isReferenced(node, parent, grandparent) {\n  switch (parent.type) {\n    case "MemberExpression":\n    case "JSXMemberExpression":\n    case "OptionalMemberExpression":\n      if (parent.property === node) {\n        return !!parent.computed;\n      }\n\n      return parent.object === node;\n\n    case "VariableDeclarator":\n      return parent.init === node;\n\n    case "ArrowFunctionExpression":\n      return parent.body === node;\n\n    case "PrivateName":\n      return false;\n\n    case "ClassMethod":\n    case "ClassPrivateMethod":\n    case "ObjectMethod":\n      if (parent.params.includes(node)) {\n        return false;\n      }\n\n    case "ObjectProperty":\n    case "ClassProperty":\n    case "ClassPrivateProperty":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n\n      if (parent.value === node) {\n        return !grandparent || grandparent.type !== "ObjectPattern";\n      }\n\n      return true;\n\n    case "ClassDeclaration":\n    case "ClassExpression":\n      return parent.superClass === node;\n\n    case "AssignmentExpression":\n      return parent.right === node;\n\n    case "AssignmentPattern":\n      return parent.right === node;\n\n    case "LabeledStatement":\n      return false;\n\n    case "CatchClause":\n      return false;\n\n    case "RestElement":\n      return false;\n\n    case "BreakStatement":\n    case "ContinueStatement":\n      return false;\n\n    case "FunctionDeclaration":\n    case "FunctionExpression":\n      return false;\n\n    case "ExportNamespaceSpecifier":\n    case "ExportDefaultSpecifier":\n      return false;\n\n    case "ExportSpecifier":\n      if (grandparent == null ? void 0 : grandparent.source) {\n        return false;\n      }\n\n      return parent.local === node;\n\n    case "ImportDefaultSpecifier":\n    case "ImportNamespaceSpecifier":\n    case "ImportSpecifier":\n      return false;\n\n    case "JSXAttribute":\n      return false;\n\n    case "ObjectPattern":\n    case "ArrayPattern":\n      return false;\n\n    case "MetaProperty":\n      return false;\n\n    case "ObjectTypeProperty":\n      return parent.key !== node;\n\n    case "TSEnumMember":\n      return parent.id !== node;\n\n    case "TSPropertySignature":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n\n      return true;\n  }\n\n  return true;\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/validators/isReferenced.js?')},46400:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = isScope;\n\nvar _generated = __webpack_require__(94746);\n\nfunction isScope(node, parent) {\n  if ((0, _generated.isBlockStatement)(node) && ((0, _generated.isFunction)(parent) || (0, _generated.isCatchClause)(parent))) {\n    return false;\n  }\n\n  if ((0, _generated.isPattern)(node) && ((0, _generated.isFunction)(parent) || (0, _generated.isCatchClause)(parent))) {\n    return true;\n  }\n\n  return (0, _generated.isScopable)(node);\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/validators/isScope.js?')},52800:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = isSpecifierDefault;\n\nvar _generated = __webpack_require__(94746);\n\nfunction isSpecifierDefault(specifier) {\n  return (0, _generated.isImportDefaultSpecifier)(specifier) || (0, _generated.isIdentifier)(specifier.imported || specifier.exported, {\n    name: "default"\n  });\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/validators/isSpecifierDefault.js?')},11452:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = isType;\n\nvar _definitions = __webpack_require__(46507);\n\nfunction isType(nodeType, targetType) {\n  if (nodeType === targetType) return true;\n  if (_definitions.ALIAS_KEYS[targetType]) return false;\n  const aliases = _definitions.FLIPPED_ALIAS_KEYS[targetType];\n\n  if (aliases) {\n    if (aliases[0] === nodeType) return true;\n\n    for (const alias of aliases) {\n      if (nodeType === alias) return true;\n    }\n  }\n\n  return false;\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/validators/isType.js?')},38917:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = isValidES3Identifier;\n\nvar _isValidIdentifier = _interopRequireDefault(__webpack_require__(93045));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst RESERVED_WORDS_ES3_ONLY = new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);\n\nfunction isValidES3Identifier(name) {\n  return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/validators/isValidES3Identifier.js?')},93045:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = isValidIdentifier;\n\nvar _helperValidatorIdentifier = __webpack_require__(40720);\n\nfunction isValidIdentifier(name, reserved = true) {\n  if (typeof name !== "string") return false;\n\n  if (reserved) {\n    if ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name, true)) {\n      return false;\n    }\n  }\n\n  return (0, _helperValidatorIdentifier.isIdentifierName)(name);\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/validators/isValidIdentifier.js?')},90830:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = isVar;\n\nvar _generated = __webpack_require__(94746);\n\nvar _constants = __webpack_require__(36325);\n\nfunction isVar(node) {\n  return (0, _generated.isVariableDeclaration)(node, {\n    kind: "var"\n  }) && !node[_constants.BLOCK_SCOPED_SYMBOL];\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/validators/isVar.js?')},92205:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = matchesPattern;\n\nvar _generated = __webpack_require__(94746);\n\nfunction matchesPattern(member, match, allowPartial) {\n  if (!(0, _generated.isMemberExpression)(member)) return false;\n  const parts = Array.isArray(match) ? match : match.split(".");\n  const nodes = [];\n  let node;\n\n  for (node = member; (0, _generated.isMemberExpression)(node); node = node.object) {\n    nodes.push(node.property);\n  }\n\n  nodes.push(node);\n  if (nodes.length < parts.length) return false;\n  if (!allowPartial && nodes.length > parts.length) return false;\n\n  for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {\n    const node = nodes[j];\n    let value;\n\n    if ((0, _generated.isIdentifier)(node)) {\n      value = node.name;\n    } else if ((0, _generated.isStringLiteral)(node)) {\n      value = node.value;\n    } else {\n      return false;\n    }\n\n    if (parts[i] !== value) return false;\n  }\n\n  return true;\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/validators/matchesPattern.js?')},13193:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = isCompatTag;\n\nfunction isCompatTag(tagName) {\n  return !!tagName && /^[a-z]/.test(tagName);\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/validators/react/isCompatTag.js?')},86035:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar _buildMatchMemberExpression = _interopRequireDefault(__webpack_require__(88847));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component");\nvar _default = isReactComponent;\nexports.default = _default;\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/validators/react/isReactComponent.js?')},43804:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = validate;\nexports.validateField = validateField;\nexports.validateChild = validateChild;\n\nvar _definitions = __webpack_require__(46507);\n\nfunction validate(node, key, val) {\n  if (!node) return;\n  const fields = _definitions.NODE_FIELDS[node.type];\n  if (!fields) return;\n  const field = fields[key];\n  validateField(node, key, val, field);\n  validateChild(node, key, val);\n}\n\nfunction validateField(node, key, val, field) {\n  if (!(field == null ? void 0 : field.validate)) return;\n  if (field.optional && val == null) return;\n  field.validate(node, key, val);\n}\n\nfunction validateChild(node, key, val) {\n  if (val == null) return;\n  const validate = _definitions.NODE_PARENT_VALIDATIONS[val.type];\n  if (!validate) return;\n  validate(node, key, val);\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/@babel/types/lib/validators/validate.js?')},74746:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"YAML\": () => /* binding */ YAML\n});\n\n;// CONCATENATED MODULE: ./node_modules/yaml/browser/dist/PlainValue-ff5147c6.js\nfunction _typeof2(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof2(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toArray(arr) {\n  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e2) {\n          throw _e2;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e3) {\n      didErr = true;\n      err = _e3;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nvar Char = {\n  ANCHOR: '&',\n  COMMENT: '#',\n  TAG: '!',\n  DIRECTIVES_END: '-',\n  DOCUMENT_END: '.'\n};\nvar Type = {\n  ALIAS: 'ALIAS',\n  BLANK_LINE: 'BLANK_LINE',\n  BLOCK_FOLDED: 'BLOCK_FOLDED',\n  BLOCK_LITERAL: 'BLOCK_LITERAL',\n  COMMENT: 'COMMENT',\n  DIRECTIVE: 'DIRECTIVE',\n  DOCUMENT: 'DOCUMENT',\n  FLOW_MAP: 'FLOW_MAP',\n  FLOW_SEQ: 'FLOW_SEQ',\n  MAP: 'MAP',\n  MAP_KEY: 'MAP_KEY',\n  MAP_VALUE: 'MAP_VALUE',\n  PLAIN: 'PLAIN',\n  QUOTE_DOUBLE: 'QUOTE_DOUBLE',\n  QUOTE_SINGLE: 'QUOTE_SINGLE',\n  SEQ: 'SEQ',\n  SEQ_ITEM: 'SEQ_ITEM'\n};\nvar defaultTagPrefix = 'tag:yaml.org,2002:';\nvar defaultTags = {\n  MAP: 'tag:yaml.org,2002:map',\n  SEQ: 'tag:yaml.org,2002:seq',\n  STR: 'tag:yaml.org,2002:str'\n};\n\nfunction findLineStarts(src) {\n  var ls = [0];\n  var offset = src.indexOf('\\n');\n\n  while (offset !== -1) {\n    offset += 1;\n    ls.push(offset);\n    offset = src.indexOf('\\n', offset);\n  }\n\n  return ls;\n}\n\nfunction getSrcInfo(cst) {\n  var lineStarts, src;\n\n  if (typeof cst === 'string') {\n    lineStarts = findLineStarts(cst);\n    src = cst;\n  } else {\n    if (Array.isArray(cst)) cst = cst[0];\n\n    if (cst && cst.context) {\n      if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);\n      lineStarts = cst.lineStarts;\n      src = cst.context.src;\n    }\n  }\n\n  return {\n    lineStarts: lineStarts,\n    src: src\n  };\n}\n/**\n * @typedef {Object} LinePos - One-indexed position in the source\n * @property {number} line\n * @property {number} col\n */\n\n/**\n * Determine the line/col position matching a character offset.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns a one-indexed `{ line, col }` location if found, or\n * `undefined` otherwise.\n *\n * @param {number} offset\n * @param {string|Document|Document[]} cst\n * @returns {?LinePos}\n */\n\n\nfunction getLinePos(offset, cst) {\n  if (typeof offset !== 'number' || offset < 0) return null;\n\n  var _getSrcInfo = getSrcInfo(cst),\n      lineStarts = _getSrcInfo.lineStarts,\n      src = _getSrcInfo.src;\n\n  if (!lineStarts || !src || offset > src.length) return null;\n\n  for (var i = 0; i < lineStarts.length; ++i) {\n    var start = lineStarts[i];\n\n    if (offset < start) {\n      return {\n        line: i,\n        col: offset - lineStarts[i - 1] + 1\n      };\n    }\n\n    if (offset === start) return {\n      line: i + 1,\n      col: 1\n    };\n  }\n\n  var line = lineStarts.length;\n  return {\n    line: line,\n    col: offset - lineStarts[line - 1] + 1\n  };\n}\n/**\n * Get a specified line from the source.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns the line as a string if found, or `null` otherwise.\n *\n * @param {number} line One-indexed line number\n * @param {string|Document|Document[]} cst\n * @returns {?string}\n */\n\n\nfunction getLine(line, cst) {\n  var _getSrcInfo2 = getSrcInfo(cst),\n      lineStarts = _getSrcInfo2.lineStarts,\n      src = _getSrcInfo2.src;\n\n  if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;\n  var start = lineStarts[line - 1];\n  var end = lineStarts[line]; // undefined for last line; that's ok for slice()\n\n  while (end && end > start && src[end - 1] === '\\n') {\n    --end;\n  }\n\n  return src.slice(start, end);\n}\n/**\n * Pretty-print the starting line from the source indicated by the range `pos`\n *\n * Trims output to `maxWidth` chars while keeping the starting column visible,\n * using `…` at either end to indicate dropped characters.\n *\n * Returns a two-line string (or `null`) with `\\n` as separator; the second line\n * will hold appropriately indented `^` marks indicating the column range.\n *\n * @param {Object} pos\n * @param {LinePos} pos.start\n * @param {LinePos} [pos.end]\n * @param {string|Document|Document[]*} cst\n * @param {number} [maxWidth=80]\n * @returns {?string}\n */\n\n\nfunction getPrettyContext(_ref, cst) {\n  var start = _ref.start,\n      end = _ref.end;\n  var maxWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 80;\n  var src = getLine(start.line, cst);\n  if (!src) return null;\n  var col = start.col;\n\n  if (src.length > maxWidth) {\n    if (col <= maxWidth - 10) {\n      src = src.substr(0, maxWidth - 1) + '…';\n    } else {\n      var halfWidth = Math.round(maxWidth / 2);\n      if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + '…';\n      col -= src.length - maxWidth;\n      src = '…' + src.substr(1 - maxWidth);\n    }\n  }\n\n  var errLen = 1;\n  var errEnd = '';\n\n  if (end) {\n    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {\n      errLen = end.col - start.col;\n    } else {\n      errLen = Math.min(src.length + 1, maxWidth) - col;\n      errEnd = '…';\n    }\n  }\n\n  var offset = col > 1 ? ' '.repeat(col - 1) : '';\n  var err = '^'.repeat(errLen);\n  return \"\".concat(src, \"\\n\").concat(offset).concat(err).concat(errEnd);\n}\n\nvar Range = /*#__PURE__*/function () {\n  _createClass(Range, null, [{\n    key: \"copy\",\n    value: function copy(orig) {\n      return new Range(orig.start, orig.end);\n    }\n  }]);\n\n  function Range(start, end) {\n    _classCallCheck(this, Range);\n\n    this.start = start;\n    this.end = end || start;\n  }\n\n  _createClass(Range, [{\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return typeof this.start !== 'number' || !this.end || this.end <= this.start;\n    }\n    /**\n     * Set `origStart` and `origEnd` to point to the original source range for\n     * this node, which may differ due to dropped CR characters.\n     *\n     * @param {number[]} cr - Positions of dropped CR characters\n     * @param {number} offset - Starting index of `cr` from the last call\n     * @returns {number} - The next offset, matching the one found for `origStart`\n     */\n\n  }, {\n    key: \"setOrigRange\",\n    value: function setOrigRange(cr, offset) {\n      var start = this.start,\n          end = this.end;\n\n      if (cr.length === 0 || end <= cr[0]) {\n        this.origStart = start;\n        this.origEnd = end;\n        return offset;\n      }\n\n      var i = offset;\n\n      while (i < cr.length) {\n        if (cr[i] > start) break;else ++i;\n      }\n\n      this.origStart = start + i;\n      var nextOffset = i;\n\n      while (i < cr.length) {\n        // if end was at \\n, it should now be at \\r\n        if (cr[i] >= end) break;else ++i;\n      }\n\n      this.origEnd = end + i;\n      return nextOffset;\n    }\n  }]);\n\n  return Range;\n}();\n/** Root class of all nodes */\n\n\nvar Node = /*#__PURE__*/function () {\n  _createClass(Node, null, [{\n    key: \"addStringTerminator\",\n    value: function addStringTerminator(src, offset, str) {\n      if (str[str.length - 1] === '\\n') return str;\n      var next = Node.endOfWhiteSpace(src, offset);\n      return next >= src.length || src[next] === '\\n' ? str + '\\n' : str;\n    } // ^(---|...)\n\n  }, {\n    key: \"atDocumentBoundary\",\n    value: function atDocumentBoundary(src, offset, sep) {\n      var ch0 = src[offset];\n      if (!ch0) return true;\n      var prev = src[offset - 1];\n      if (prev && prev !== '\\n') return false;\n\n      if (sep) {\n        if (ch0 !== sep) return false;\n      } else {\n        if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;\n      }\n\n      var ch1 = src[offset + 1];\n      var ch2 = src[offset + 2];\n      if (ch1 !== ch0 || ch2 !== ch0) return false;\n      var ch3 = src[offset + 3];\n      return !ch3 || ch3 === '\\n' || ch3 === '\\t' || ch3 === ' ';\n    }\n  }, {\n    key: \"endOfIdentifier\",\n    value: function endOfIdentifier(src, offset) {\n      var ch = src[offset];\n      var isVerbatim = ch === '<';\n      var notOk = isVerbatim ? ['\\n', '\\t', ' ', '>'] : ['\\n', '\\t', ' ', '[', ']', '{', '}', ','];\n\n      while (ch && notOk.indexOf(ch) === -1) {\n        ch = src[offset += 1];\n      }\n\n      if (isVerbatim && ch === '>') offset += 1;\n      return offset;\n    }\n  }, {\n    key: \"endOfIndent\",\n    value: function endOfIndent(src, offset) {\n      var ch = src[offset];\n\n      while (ch === ' ') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"endOfLine\",\n    value: function endOfLine(src, offset) {\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"endOfWhiteSpace\",\n    value: function endOfWhiteSpace(src, offset) {\n      var ch = src[offset];\n\n      while (ch === '\\t' || ch === ' ') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"startOfLine\",\n    value: function startOfLine(src, offset) {\n      var ch = src[offset - 1];\n      if (ch === '\\n') return offset;\n\n      while (ch && ch !== '\\n') {\n        ch = src[offset -= 1];\n      }\n\n      return offset + 1;\n    }\n    /**\n     * End of indentation, or null if the line's indent level is not more\n     * than `indent`\n     *\n     * @param {string} src\n     * @param {number} indent\n     * @param {number} lineStart\n     * @returns {?number}\n     */\n\n  }, {\n    key: \"endOfBlockIndent\",\n    value: function endOfBlockIndent(src, indent, lineStart) {\n      var inEnd = Node.endOfIndent(src, lineStart);\n\n      if (inEnd > lineStart + indent) {\n        return inEnd;\n      } else {\n        var wsEnd = Node.endOfWhiteSpace(src, inEnd);\n        var ch = src[wsEnd];\n        if (!ch || ch === '\\n') return wsEnd;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"atBlank\",\n    value: function atBlank(src, offset, endAsBlank) {\n      var ch = src[offset];\n      return ch === '\\n' || ch === '\\t' || ch === ' ' || endAsBlank && !ch;\n    }\n  }, {\n    key: \"nextNodeIsIndented\",\n    value: function nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {\n      if (!ch || indentDiff < 0) return false;\n      if (indentDiff > 0) return true;\n      return indicatorAsIndent && ch === '-';\n    } // should be at line or string end, or at next non-whitespace char\n\n  }, {\n    key: \"normalizeOffset\",\n    value: function normalizeOffset(src, offset) {\n      var ch = src[offset];\n      return !ch ? offset : ch !== '\\n' && src[offset - 1] === '\\n' ? offset - 1 : Node.endOfWhiteSpace(src, offset);\n    } // fold single newline into space, multiple newlines to N - 1 newlines\n    // presumes src[offset] === '\\n'\n\n  }, {\n    key: \"foldNewline\",\n    value: function foldNewline(src, offset, indent) {\n      var inCount = 0;\n      var error = false;\n      var fold = '';\n      var ch = src[offset + 1];\n\n      while (ch === ' ' || ch === '\\t' || ch === '\\n') {\n        switch (ch) {\n          case '\\n':\n            inCount = 0;\n            offset += 1;\n            fold += '\\n';\n            break;\n\n          case '\\t':\n            if (inCount <= indent) error = true;\n            offset = Node.endOfWhiteSpace(src, offset + 2) - 1;\n            break;\n\n          case ' ':\n            inCount += 1;\n            offset += 1;\n            break;\n        }\n\n        ch = src[offset + 1];\n      }\n\n      if (!fold) fold = ' ';\n      if (ch && inCount <= indent) error = true;\n      return {\n        fold: fold,\n        offset: offset,\n        error: error\n      };\n    }\n  }]);\n\n  function Node(type, props, context) {\n    _classCallCheck(this, Node);\n\n    Object.defineProperty(this, 'context', {\n      value: context || null,\n      writable: true\n    });\n    this.error = null;\n    this.range = null;\n    this.valueRange = null;\n    this.props = props || [];\n    this.type = type;\n    this.value = null;\n  }\n\n  _createClass(Node, [{\n    key: \"getPropValue\",\n    value: function getPropValue(idx, key, skipKey) {\n      if (!this.context) return null;\n      var src = this.context.src;\n      var prop = this.props[idx];\n      return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;\n    }\n  }, {\n    key: \"commentHasRequiredWhitespace\",\n    value: function commentHasRequiredWhitespace(start) {\n      var src = this.context.src;\n      if (this.header && start === this.header.end) return false;\n      if (!this.valueRange) return false;\n      var end = this.valueRange.end;\n      return start !== end || Node.atBlank(src, end - 1);\n    }\n  }, {\n    key: \"parseComment\",\n    value: function parseComment(start) {\n      var src = this.context.src;\n\n      if (src[start] === Char.COMMENT) {\n        var end = Node.endOfLine(src, start + 1);\n        var commentRange = new Range(start, end);\n        this.props.push(commentRange);\n        return end;\n      }\n\n      return start;\n    }\n    /**\n     * Populates the `origStart` and `origEnd` values of all ranges for this\n     * node. Extended by child classes to handle descendant nodes.\n     *\n     * @param {number[]} cr - Positions of dropped CR characters\n     * @param {number} offset - Starting index of `cr` from the last call\n     * @returns {number} - The next offset, matching the one found for `origStart`\n     */\n\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      if (this.range) offset = this.range.setOrigRange(cr, offset);\n      if (this.valueRange) this.valueRange.setOrigRange(cr, offset);\n      this.props.forEach(function (prop) {\n        return prop.setOrigRange(cr, offset);\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = src.slice(range.start, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }, {\n    key: \"anchor\",\n    get: function get() {\n      for (var i = 0; i < this.props.length; ++i) {\n        var anchor = this.getPropValue(i, Char.ANCHOR, true);\n        if (anchor != null) return anchor;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"comment\",\n    get: function get() {\n      var comments = [];\n\n      for (var i = 0; i < this.props.length; ++i) {\n        var comment = this.getPropValue(i, Char.COMMENT, true);\n        if (comment != null) comments.push(comment);\n      }\n\n      return comments.length > 0 ? comments.join('\\n') : null;\n    }\n  }, {\n    key: \"hasComment\",\n    get: function get() {\n      if (this.context) {\n        var src = this.context.src;\n\n        for (var i = 0; i < this.props.length; ++i) {\n          if (src[this.props[i].start] === Char.COMMENT) return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"hasProps\",\n    get: function get() {\n      if (this.context) {\n        var src = this.context.src;\n\n        for (var i = 0; i < this.props.length; ++i) {\n          if (src[this.props[i].start] !== Char.COMMENT) return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"jsonLike\",\n    get: function get() {\n      var jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];\n      return jsonLikeTypes.indexOf(this.type) !== -1;\n    }\n  }, {\n    key: \"rangeAsLinePos\",\n    get: function get() {\n      if (!this.range || !this.context) return undefined;\n      var start = getLinePos(this.range.start, this.context.root);\n      if (!start) return undefined;\n      var end = getLinePos(this.range.end, this.context.root);\n      return {\n        start: start,\n        end: end\n      };\n    }\n  }, {\n    key: \"rawValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      return this.context.src.slice(start, end);\n    }\n  }, {\n    key: \"tag\",\n    get: function get() {\n      for (var i = 0; i < this.props.length; ++i) {\n        var tag = this.getPropValue(i, Char.TAG, false);\n\n        if (tag != null) {\n          if (tag[1] === '<') {\n            return {\n              verbatim: tag.slice(2, -1)\n            };\n          } else {\n            // eslint-disable-next-line no-unused-vars\n            var _tag$match = tag.match(/^(.*!)([^!]*)$/),\n                _tag$match2 = _slicedToArray(_tag$match, 3),\n                _ = _tag$match2[0],\n                handle = _tag$match2[1],\n                suffix = _tag$match2[2];\n\n            return {\n              handle: handle,\n              suffix: suffix\n            };\n          }\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"valueRangeContainsNewline\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return false;\n      var _this$valueRange2 = this.valueRange,\n          start = _this$valueRange2.start,\n          end = _this$valueRange2.end;\n      var src = this.context.src;\n\n      for (var i = start; i < end; ++i) {\n        if (src[i] === '\\n') return true;\n      }\n\n      return false;\n    }\n  }]);\n\n  return Node;\n}();\n\nvar YAMLError = /*#__PURE__*/function (_Error) {\n  _inherits(YAMLError, _Error);\n\n  var _super = _createSuper(YAMLError);\n\n  function YAMLError(name, source, message) {\n    var _this;\n\n    _classCallCheck(this, YAMLError);\n\n    if (!message || !(source instanceof Node)) throw new Error(\"Invalid arguments for new \".concat(name));\n    _this = _super.call(this);\n    _this.name = name;\n    _this.message = message;\n    _this.source = source;\n    return _this;\n  }\n\n  _createClass(YAMLError, [{\n    key: \"makePretty\",\n    value: function makePretty() {\n      if (!this.source) return;\n      this.nodeType = this.source.type;\n      var cst = this.source.context && this.source.context.root;\n\n      if (typeof this.offset === 'number') {\n        this.range = new Range(this.offset, this.offset + 1);\n        var start = cst && getLinePos(this.offset, cst);\n\n        if (start) {\n          var end = {\n            line: start.line,\n            col: start.col + 1\n          };\n          this.linePos = {\n            start: start,\n            end: end\n          };\n        }\n\n        delete this.offset;\n      } else {\n        this.range = this.source.range;\n        this.linePos = this.source.rangeAsLinePos;\n      }\n\n      if (this.linePos) {\n        var _this$linePos$start = this.linePos.start,\n            line = _this$linePos$start.line,\n            col = _this$linePos$start.col;\n        this.message += \" at line \".concat(line, \", column \").concat(col);\n        var ctx = cst && getPrettyContext(this.linePos, cst);\n        if (ctx) this.message += \":\\n\\n\".concat(ctx, \"\\n\");\n      }\n\n      delete this.source;\n    }\n  }]);\n\n  return YAMLError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar YAMLReferenceError = /*#__PURE__*/function (_YAMLError) {\n  _inherits(YAMLReferenceError, _YAMLError);\n\n  var _super2 = _createSuper(YAMLReferenceError);\n\n  function YAMLReferenceError(source, message) {\n    _classCallCheck(this, YAMLReferenceError);\n\n    return _super2.call(this, 'YAMLReferenceError', source, message);\n  }\n\n  return YAMLReferenceError;\n}(YAMLError);\n\nvar YAMLSemanticError = /*#__PURE__*/function (_YAMLError2) {\n  _inherits(YAMLSemanticError, _YAMLError2);\n\n  var _super3 = _createSuper(YAMLSemanticError);\n\n  function YAMLSemanticError(source, message) {\n    _classCallCheck(this, YAMLSemanticError);\n\n    return _super3.call(this, 'YAMLSemanticError', source, message);\n  }\n\n  return YAMLSemanticError;\n}(YAMLError);\n\nvar YAMLSyntaxError = /*#__PURE__*/function (_YAMLError3) {\n  _inherits(YAMLSyntaxError, _YAMLError3);\n\n  var _super4 = _createSuper(YAMLSyntaxError);\n\n  function YAMLSyntaxError(source, message) {\n    _classCallCheck(this, YAMLSyntaxError);\n\n    return _super4.call(this, 'YAMLSyntaxError', source, message);\n  }\n\n  return YAMLSyntaxError;\n}(YAMLError);\n\nvar YAMLWarning = /*#__PURE__*/function (_YAMLError4) {\n  _inherits(YAMLWarning, _YAMLError4);\n\n  var _super5 = _createSuper(YAMLWarning);\n\n  function YAMLWarning(source, message) {\n    _classCallCheck(this, YAMLWarning);\n\n    return _super5.call(this, 'YAMLWarning', source, message);\n  }\n\n  return YAMLWarning;\n}(YAMLError);\n\nvar PlainValue = /*#__PURE__*/function (_Node) {\n  _inherits(PlainValue, _Node);\n\n  var _super = _createSuper(PlainValue);\n\n  function PlainValue() {\n    _classCallCheck(this, PlainValue);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(PlainValue, [{\n    key: \"parseBlockValue\",\n    value: function parseBlockValue(start) {\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          inFlow = _this$context.inFlow,\n          src = _this$context.src;\n      var offset = start;\n      var valueEnd = start;\n\n      for (var ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n        if (Node.atDocumentBoundary(src, offset + 1)) break;\n        var end = Node.endOfBlockIndent(src, indent, offset + 1);\n        if (end === null || src[end] === '#') break;\n\n        if (src[end] === '\\n') {\n          offset = end;\n        } else {\n          valueEnd = PlainValue.endOfLine(src, end, inFlow);\n          offset = valueEnd;\n        }\n      }\n\n      if (this.valueRange.isEmpty()) this.valueRange.start = start;\n      this.valueRange.end = valueEnd;\n      return valueEnd;\n    }\n    /**\n     * Parses a plain value from the source\n     *\n     * Accepted forms are:\n     * ```\n     * #comment\n     *\n     * first line\n     *\n     * first line #comment\n     *\n     * first line\n     * block\n     * lines\n     *\n     * #comment\n     * block\n     * lines\n     * ```\n     * where block lines are empty or have an indent level greater than `indent`.\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar, may be `\\n`\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var inFlow = context.inFlow,\n          src = context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      if (ch && ch !== '#' && ch !== '\\n') {\n        offset = PlainValue.endOfLine(src, start, inFlow);\n      }\n\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n\n      if (!this.hasComment || this.valueRange.isEmpty()) {\n        offset = this.parseBlockValue(offset);\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"strValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var src = this.context.src;\n      var ch = src[end - 1];\n\n      while (start < end && (ch === '\\n' || ch === '\\t' || ch === ' ')) {\n        ch = src[--end - 1];\n      }\n\n      var str = '';\n\n      for (var i = start; i < end; ++i) {\n        var _ch = src[i];\n\n        if (_ch === '\\n') {\n          var _Node$foldNewline = Node.foldNewline(src, i, -1),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset;\n\n          str += fold;\n          i = offset;\n        } else if (_ch === ' ' || _ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (i < end && (next === ' ' || next === '\\t')) {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : _ch;\n        } else {\n          str += _ch;\n        }\n      }\n\n      var ch0 = src[start];\n\n      switch (ch0) {\n        case '\\t':\n          {\n            var msg = 'Plain value cannot start with a tab character';\n            var errors = [new YAMLSemanticError(this, msg)];\n            return {\n              errors: errors,\n              str: str\n            };\n          }\n\n        case '@':\n        case '`':\n          {\n            var _msg = \"Plain value cannot start with reserved character \".concat(ch0);\n\n            var _errors = [new YAMLSemanticError(this, _msg)];\n            return {\n              errors: _errors,\n              str: str\n            };\n          }\n\n        default:\n          return str;\n      }\n    }\n  }], [{\n    key: \"endOfLine\",\n    value: function endOfLine(src, start, inFlow) {\n      var ch = src[start];\n      var offset = start;\n\n      while (ch && ch !== '\\n') {\n        if (inFlow && (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ',')) break;\n        var next = src[offset + 1];\n        if (ch === ':' && (!next || next === '\\n' || next === '\\t' || next === ' ' || inFlow && next === ',')) break;\n        if ((ch === ' ' || ch === '\\t') && next === '#') break;\n        offset += 1;\n        ch = next;\n      }\n\n      return offset;\n    }\n  }]);\n\n  return PlainValue;\n}(Node);\n\n\n;// CONCATENATED MODULE: ./node_modules/yaml/browser/dist/parse-cst.js\n\n\nvar BlankLine = /*#__PURE__*/function (_Node) {\n  _inherits(BlankLine, _Node);\n\n  var _super = _createSuper(BlankLine);\n\n  function BlankLine() {\n    _classCallCheck(this, BlankLine);\n\n    return _super.call(this, Type.BLANK_LINE);\n  }\n  /* istanbul ignore next */\n\n\n  _createClass(BlankLine, [{\n    key: \"parse\",\n\n    /**\n     * Parses a blank line from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first \\n character\n     * @returns {number} - Index of the character after this\n     */\n    value: function parse(context, start) {\n      this.context = context;\n      this.range = new Range(start, start + 1);\n      return start + 1;\n    }\n  }, {\n    key: \"includesTrailingLines\",\n    get: function get() {\n      // This is never called from anywhere, but if it were,\n      // this is the value it should return.\n      return true;\n    }\n  }]);\n\n  return BlankLine;\n}(Node);\n\nvar CollectionItem = /*#__PURE__*/function (_Node) {\n  _inherits(CollectionItem, _Node);\n\n  var _super = _createSuper(CollectionItem);\n\n  function CollectionItem(type, props) {\n    var _this;\n\n    _classCallCheck(this, CollectionItem);\n\n    _this = _super.call(this, type, props);\n    _this.node = null;\n    return _this;\n  }\n\n  _createClass(CollectionItem, [{\n    key: \"parse\",\n\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src;\n      var atLineStart = context.atLineStart,\n          lineStart = context.lineStart;\n      if (!atLineStart && this.type === Type.SEQ_ITEM) this.error = new YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');\n      var indent = atLineStart ? start - lineStart : context.indent;\n      var offset = Node.endOfWhiteSpace(src, start + 1);\n      var ch = src[offset];\n      var inlineComment = ch === '#';\n      var comments = [];\n      var blankLine = null;\n\n      while (ch === '\\n' || ch === '#') {\n        if (ch === '#') {\n          var _end = Node.endOfLine(src, offset + 1);\n\n          comments.push(new Range(offset, _end));\n          offset = _end;\n        } else {\n          atLineStart = true;\n          lineStart = offset + 1;\n          var wsEnd = Node.endOfWhiteSpace(src, lineStart);\n\n          if (src[wsEnd] === '\\n' && comments.length === 0) {\n            blankLine = new BlankLine();\n            lineStart = blankLine.parse({\n              src: src\n            }, lineStart);\n          }\n\n          offset = Node.endOfIndent(src, lineStart);\n        }\n\n        ch = src[offset];\n      }\n\n      if (Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== Type.SEQ_ITEM)) {\n        this.node = parseNode({\n          atLineStart: atLineStart,\n          inCollection: false,\n          indent: indent,\n          lineStart: lineStart,\n          parent: this\n        }, offset);\n      } else if (ch && lineStart > start + 1) {\n        offset = lineStart - 1;\n      }\n\n      if (this.node) {\n        if (blankLine) {\n          // Only blank lines preceding non-empty nodes are captured. Note that\n          // this means that collection item range start indices do not always\n          // increase monotonically. -- eemeli/yaml#126\n          var items = context.parent.items || context.parent.contents;\n          if (items) items.push(blankLine);\n        }\n\n        if (comments.length) Array.prototype.push.apply(this.props, comments);\n        offset = this.node.range.end;\n      } else {\n        if (inlineComment) {\n          var c = comments[0];\n          this.props.push(c);\n          offset = c.end;\n        } else {\n          offset = Node.endOfLine(src, start + 1);\n        }\n      }\n\n      var end = this.node ? this.node.valueRange.end : offset;\n      this.valueRange = new Range(start, end);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(CollectionItem.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      return this.node ? this.node.setOrigRanges(cr, offset) : offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          node = this.node,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }, {\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return !!this.node && this.node.includesTrailingLines;\n    }\n  }]);\n\n  return CollectionItem;\n}(Node);\n\nvar Comment = /*#__PURE__*/function (_Node) {\n  _inherits(Comment, _Node);\n\n  var _super = _createSuper(Comment);\n\n  function Comment() {\n    _classCallCheck(this, Comment);\n\n    return _super.call(this, Type.COMMENT);\n  }\n  /**\n   * Parses a comment line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  _createClass(Comment, [{\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var offset = this.parseComment(start);\n      this.range = new Range(start, offset);\n      return offset;\n    }\n  }]);\n\n  return Comment;\n}(Node);\n\nfunction grabCollectionEndComments(node) {\n  var cnode = node;\n\n  while (cnode instanceof CollectionItem) {\n    cnode = cnode.node;\n  }\n\n  if (!(cnode instanceof Collection)) return null;\n  var len = cnode.items.length;\n  var ci = -1;\n\n  for (var i = len - 1; i >= 0; --i) {\n    var n = cnode.items[i];\n\n    if (n.type === Type.COMMENT) {\n      // Keep sufficiently indented comments with preceding node\n      var _n$context = n.context,\n          indent = _n$context.indent,\n          lineStart = _n$context.lineStart;\n      if (indent > 0 && n.range.start >= lineStart + indent) break;\n      ci = i;\n    } else if (n.type === Type.BLANK_LINE) ci = i;else break;\n  }\n\n  if (ci === -1) return null;\n  var ca = cnode.items.splice(ci, len - ci);\n  var prevEnd = ca[0].range.start;\n\n  while (true) {\n    cnode.range.end = prevEnd;\n    if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;\n    if (cnode === node) break;\n    cnode = cnode.context.parent;\n  }\n\n  return ca;\n}\n\nvar Collection = /*#__PURE__*/function (_Node) {\n  _inherits(Collection, _Node);\n\n  var _super = _createSuper(Collection);\n\n  _createClass(Collection, null, [{\n    key: \"nextContentHasIndent\",\n    value: function nextContentHasIndent(src, offset, indent) {\n      var lineStart = Node.endOfLine(src, offset) + 1;\n      offset = Node.endOfWhiteSpace(src, lineStart);\n      var ch = src[offset];\n      if (!ch) return false;\n      if (offset >= lineStart + indent) return true;\n      if (ch !== '#' && ch !== '\\n') return false;\n      return Collection.nextContentHasIndent(src, offset, indent);\n    }\n  }]);\n\n  function Collection(firstItem) {\n    var _this;\n\n    _classCallCheck(this, Collection);\n\n    _this = _super.call(this, firstItem.type === Type.SEQ_ITEM ? Type.SEQ : Type.MAP);\n\n    for (var i = firstItem.props.length - 1; i >= 0; --i) {\n      if (firstItem.props[i].start < firstItem.context.lineStart) {\n        // props on previous line are assumed by the collection\n        _this.props = firstItem.props.slice(0, i + 1);\n        firstItem.props = firstItem.props.slice(i + 1);\n        var itemRange = firstItem.props[0] || firstItem.valueRange;\n        firstItem.range.start = itemRange.start;\n        break;\n      }\n    }\n\n    _this.items = [firstItem];\n    var ec = grabCollectionEndComments(firstItem);\n    if (ec) Array.prototype.push.apply(_this.items, ec);\n    return _this;\n  }\n\n  _createClass(Collection, [{\n    key: \"parse\",\n\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src; // It's easier to recalculate lineStart here rather than tracking down the\n      // last context from which to read it -- eemeli/yaml#2\n\n      var lineStart = Node.startOfLine(src, start);\n      var firstItem = this.items[0]; // First-item context needs to be correct for later comment handling\n      // -- eemeli/yaml#17\n\n      firstItem.context.parent = this;\n      this.valueRange = Range.copy(firstItem.valueRange);\n      var indent = firstItem.range.start - firstItem.context.lineStart;\n      var offset = start;\n      offset = Node.normalizeOffset(src, offset);\n      var ch = src[offset];\n      var atLineStart = Node.endOfWhiteSpace(src, lineStart) === offset;\n      var prevIncludesTrailingLines = false;\n\n      while (ch) {\n        while (ch === '\\n' || ch === '#') {\n          if (atLineStart && ch === '\\n' && !prevIncludesTrailingLines) {\n            var blankLine = new BlankLine();\n            offset = blankLine.parse({\n              src: src\n            }, offset);\n            this.valueRange.end = offset;\n\n            if (offset >= src.length) {\n              ch = null;\n              break;\n            }\n\n            this.items.push(blankLine);\n            offset -= 1; // blankLine.parse() consumes terminal newline\n          } else if (ch === '#') {\n            if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) {\n              return offset;\n            }\n\n            var comment = new Comment();\n            offset = comment.parse({\n              indent: indent,\n              lineStart: lineStart,\n              src: src\n            }, offset);\n            this.items.push(comment);\n            this.valueRange.end = offset;\n\n            if (offset >= src.length) {\n              ch = null;\n              break;\n            }\n          }\n\n          lineStart = offset + 1;\n          offset = Node.endOfIndent(src, lineStart);\n\n          if (Node.atBlank(src, offset)) {\n            var wsEnd = Node.endOfWhiteSpace(src, offset);\n            var next = src[wsEnd];\n\n            if (!next || next === '\\n' || next === '#') {\n              offset = wsEnd;\n            }\n          }\n\n          ch = src[offset];\n          atLineStart = true;\n        }\n\n        if (!ch) {\n          break;\n        }\n\n        if (offset !== lineStart + indent && (atLineStart || ch !== ':')) {\n          if (offset < lineStart + indent) {\n            if (lineStart > start) offset = lineStart;\n            break;\n          } else if (!this.error) {\n            var msg = 'All collection items must start at the same column';\n            this.error = new YAMLSyntaxError(this, msg);\n          }\n        }\n\n        if (firstItem.type === Type.SEQ_ITEM) {\n          if (ch !== '-') {\n            if (lineStart > start) offset = lineStart;\n            break;\n          }\n        } else if (ch === '-' && !this.error) {\n          // map key may start with -, as long as it's followed by a non-whitespace char\n          var _next = src[offset + 1];\n\n          if (!_next || _next === '\\n' || _next === '\\t' || _next === ' ') {\n            var _msg = 'A collection cannot be both a mapping and a sequence';\n            this.error = new YAMLSyntaxError(this, _msg);\n          }\n        }\n\n        var node = parseNode({\n          atLineStart: atLineStart,\n          inCollection: true,\n          indent: indent,\n          lineStart: lineStart,\n          parent: this\n        }, offset);\n        if (!node) return offset; // at next document start\n\n        this.items.push(node);\n        this.valueRange.end = node.valueRange.end;\n        offset = Node.normalizeOffset(src, node.range.end);\n        ch = src[offset];\n        atLineStart = false;\n        prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range\n        // has advanced to check the current line's indentation level\n        // -- eemeli/yaml#10 & eemeli/yaml#38\n\n        if (ch) {\n          var ls = offset - 1;\n          var prev = src[ls];\n\n          while (prev === ' ' || prev === '\\t') {\n            prev = src[--ls];\n          }\n\n          if (prev === '\\n') {\n            lineStart = ls + 1;\n            atLineStart = true;\n          }\n        }\n\n        var ec = grabCollectionEndComments(node);\n        if (ec) Array.prototype.push.apply(this.items, ec);\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(Collection.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.items.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          items = this.items,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = src.slice(range.start, items[0].range.start) + String(items[0]);\n\n      for (var i = 1; i < items.length; ++i) {\n        var item = items[i];\n        var _item$context = item.context,\n            atLineStart = _item$context.atLineStart,\n            indent = _item$context.indent;\n        if (atLineStart) for (var _i = 0; _i < indent; ++_i) {\n          str += ' ';\n        }\n        str += String(item);\n      }\n\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }, {\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return this.items.length > 0;\n    }\n  }]);\n\n  return Collection;\n}(Node);\n\nvar Directive = /*#__PURE__*/function (_Node) {\n  _inherits(Directive, _Node);\n\n  var _super = _createSuper(Directive);\n\n  function Directive() {\n    var _this;\n\n    _classCallCheck(this, Directive);\n\n    _this = _super.call(this, Type.DIRECTIVE);\n    _this.name = null;\n    return _this;\n  }\n\n  _createClass(Directive, [{\n    key: \"parseName\",\n    value: function parseName(start) {\n      var src = this.context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n' && ch !== '\\t' && ch !== ' ') {\n        ch = src[offset += 1];\n      }\n\n      this.name = src.slice(start, offset);\n      return offset;\n    }\n  }, {\n    key: \"parseParameters\",\n    value: function parseParameters(start) {\n      var src = this.context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n' && ch !== '#') {\n        ch = src[offset += 1];\n      }\n\n      this.valueRange = new Range(start, offset);\n      return offset;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var offset = this.parseName(start + 1);\n      offset = this.parseParameters(offset);\n      offset = this.parseComment(offset);\n      this.range = new Range(start, offset);\n      return offset;\n    }\n  }, {\n    key: \"parameters\",\n    get: function get() {\n      var raw = this.rawValue;\n      return raw ? raw.trim().split(/[ \\t]+/) : [];\n    }\n  }]);\n\n  return Directive;\n}(Node);\n\nvar Document = /*#__PURE__*/function (_Node) {\n  _inherits(Document, _Node);\n\n  var _super = _createSuper(Document);\n\n  _createClass(Document, null, [{\n    key: \"startCommentOrEndBlankLine\",\n    value: function startCommentOrEndBlankLine(src, start) {\n      var offset = Node.endOfWhiteSpace(src, start);\n      var ch = src[offset];\n      return ch === '#' || ch === '\\n' ? offset : start;\n    }\n  }]);\n\n  function Document() {\n    var _this;\n\n    _classCallCheck(this, Document);\n\n    _this = _super.call(this, Type.DOCUMENT);\n    _this.directives = null;\n    _this.contents = null;\n    _this.directivesEndMarker = null;\n    _this.documentEndMarker = null;\n    return _this;\n  }\n\n  _createClass(Document, [{\n    key: \"parseDirectives\",\n    value: function parseDirectives(start) {\n      var src = this.context.src;\n      this.directives = [];\n      var atLineStart = true;\n      var hasDirectives = false;\n      var offset = start;\n\n      while (!Node.atDocumentBoundary(src, offset, Char.DIRECTIVES_END)) {\n        offset = Document.startCommentOrEndBlankLine(src, offset);\n\n        switch (src[offset]) {\n          case '\\n':\n            if (atLineStart) {\n              var blankLine = new BlankLine();\n              offset = blankLine.parse({\n                src: src\n              }, offset);\n\n              if (offset < src.length) {\n                this.directives.push(blankLine);\n              }\n            } else {\n              offset += 1;\n              atLineStart = true;\n            }\n\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.directives.push(comment);\n              atLineStart = false;\n            }\n            break;\n\n          case '%':\n            {\n              var directive = new Directive();\n              offset = directive.parse({\n                parent: this,\n                src: src\n              }, offset);\n              this.directives.push(directive);\n              hasDirectives = true;\n              atLineStart = false;\n            }\n            break;\n\n          default:\n            if (hasDirectives) {\n              this.error = new YAMLSemanticError(this, 'Missing directives-end indicator line');\n            } else if (this.directives.length > 0) {\n              this.contents = this.directives;\n              this.directives = [];\n            }\n\n            return offset;\n        }\n      }\n\n      if (src[offset]) {\n        this.directivesEndMarker = new Range(offset, offset + 3);\n        return offset + 3;\n      }\n\n      if (hasDirectives) {\n        this.error = new YAMLSemanticError(this, 'Missing directives-end indicator line');\n      } else if (this.directives.length > 0) {\n        this.contents = this.directives;\n        this.directives = [];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"parseContents\",\n    value: function parseContents(start) {\n      var _this$context = this.context,\n          parseNode = _this$context.parseNode,\n          src = _this$context.src;\n      if (!this.contents) this.contents = [];\n      var lineStart = start;\n\n      while (src[lineStart - 1] === '-') {\n        lineStart -= 1;\n      }\n\n      var offset = Node.endOfWhiteSpace(src, start);\n      var atLineStart = lineStart === start;\n      this.valueRange = new Range(offset);\n\n      while (!Node.atDocumentBoundary(src, offset, Char.DOCUMENT_END)) {\n        switch (src[offset]) {\n          case '\\n':\n            if (atLineStart) {\n              var blankLine = new BlankLine();\n              offset = blankLine.parse({\n                src: src\n              }, offset);\n\n              if (offset < src.length) {\n                this.contents.push(blankLine);\n              }\n            } else {\n              offset += 1;\n              atLineStart = true;\n            }\n\n            lineStart = offset;\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.contents.push(comment);\n              atLineStart = false;\n            }\n            break;\n\n          default:\n            {\n              var iEnd = Node.endOfIndent(src, offset);\n              var context = {\n                atLineStart: atLineStart,\n                indent: -1,\n                inFlow: false,\n                inCollection: false,\n                lineStart: lineStart,\n                parent: this\n              };\n              var node = parseNode(context, iEnd);\n              if (!node) return this.valueRange.end = iEnd; // at next document start\n\n              this.contents.push(node);\n              offset = node.range.end;\n              atLineStart = false;\n              var ec = grabCollectionEndComments(node);\n              if (ec) Array.prototype.push.apply(this.contents, ec);\n            }\n        }\n\n        offset = Document.startCommentOrEndBlankLine(src, offset);\n      }\n\n      this.valueRange.end = offset;\n\n      if (src[offset]) {\n        this.documentEndMarker = new Range(offset, offset + 3);\n        offset += 3;\n\n        if (src[offset]) {\n          offset = Node.endOfWhiteSpace(src, offset);\n\n          if (src[offset] === '#') {\n            var _comment = new Comment();\n\n            offset = _comment.parse({\n              src: src\n            }, offset);\n            this.contents.push(_comment);\n          }\n\n          switch (src[offset]) {\n            case '\\n':\n              offset += 1;\n              break;\n\n            case undefined:\n              break;\n\n            default:\n              this.error = new YAMLSyntaxError(this, 'Document end marker line cannot have a non-comment suffix');\n          }\n        }\n      }\n\n      return offset;\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      context.root = this;\n      this.context = context;\n      var src = context.src;\n      var offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM\n\n      offset = this.parseDirectives(offset);\n      offset = this.parseContents(offset);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(Document.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.directives.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);\n      this.contents.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var contents = this.contents,\n          directives = this.directives,\n          value = this.value;\n      if (value != null) return value;\n      var str = directives.join('');\n\n      if (contents.length > 0) {\n        if (directives.length > 0 || contents[0].type === Type.COMMENT) str += '---\\n';\n        str += contents.join('');\n      }\n\n      if (str[str.length - 1] !== '\\n') str += '\\n';\n      return str;\n    }\n  }]);\n\n  return Document;\n}(Node);\n\nvar Alias = /*#__PURE__*/function (_Node) {\n  _inherits(Alias, _Node);\n\n  var _super = _createSuper(Alias);\n\n  function Alias() {\n    _classCallCheck(this, Alias);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Alias, [{\n    key: \"parse\",\n\n    /**\n     * Parses an *alias from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = Node.endOfIdentifier(src, start + 1);\n      this.valueRange = new Range(start + 1, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }]);\n\n  return Alias;\n}(Node);\n\nvar Chomp = {\n  CLIP: 'CLIP',\n  KEEP: 'KEEP',\n  STRIP: 'STRIP'\n};\n\nvar BlockValue = /*#__PURE__*/function (_Node) {\n  _inherits(BlockValue, _Node);\n\n  var _super = _createSuper(BlockValue);\n\n  function BlockValue(type, props) {\n    var _this;\n\n    _classCallCheck(this, BlockValue);\n\n    _this = _super.call(this, type, props);\n    _this.blockIndent = null;\n    _this.chomping = Chomp.CLIP;\n    _this.header = null;\n    return _this;\n  }\n\n  _createClass(BlockValue, [{\n    key: \"parseBlockHeader\",\n    value: function parseBlockHeader(start) {\n      var src = this.context.src;\n      var offset = start + 1;\n      var bi = '';\n\n      while (true) {\n        var ch = src[offset];\n\n        switch (ch) {\n          case '-':\n            this.chomping = Chomp.STRIP;\n            break;\n\n          case '+':\n            this.chomping = Chomp.KEEP;\n            break;\n\n          case '0':\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9':\n            bi += ch;\n            break;\n\n          default:\n            this.blockIndent = Number(bi) || null;\n            this.header = new Range(start, offset);\n            return offset;\n        }\n\n        offset += 1;\n      }\n    }\n  }, {\n    key: \"parseBlockValue\",\n    value: function parseBlockValue(start) {\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      var explicit = !!this.blockIndent;\n      var offset = start;\n      var valueEnd = start;\n      var minBlockIndent = 1;\n\n      for (var ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n        offset += 1;\n        if (Node.atDocumentBoundary(src, offset)) break;\n        var end = Node.endOfBlockIndent(src, indent, offset); // should not include tab?\n\n        if (end === null) break;\n        var _ch = src[end];\n        var lineIndent = end - (offset + indent);\n\n        if (!this.blockIndent) {\n          // no explicit block indent, none yet detected\n          if (src[end] !== '\\n') {\n            // first line with non-whitespace content\n            if (lineIndent < minBlockIndent) {\n              var msg = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n              this.error = new YAMLSemanticError(this, msg);\n            }\n\n            this.blockIndent = lineIndent;\n          } else if (lineIndent > minBlockIndent) {\n            // empty line with more whitespace\n            minBlockIndent = lineIndent;\n          }\n        } else if (_ch && _ch !== '\\n' && lineIndent < this.blockIndent) {\n          if (src[end] === '#') break;\n\n          if (!this.error) {\n            var _src = explicit ? 'explicit indentation indicator' : 'first line';\n\n            var _msg = \"Block scalars must not be less indented than their \".concat(_src);\n\n            this.error = new YAMLSemanticError(this, _msg);\n          }\n        }\n\n        if (src[end] === '\\n') {\n          offset = end;\n        } else {\n          offset = valueEnd = Node.endOfLine(src, end);\n        }\n      }\n\n      if (this.chomping !== Chomp.KEEP) {\n        offset = src[valueEnd] ? valueEnd + 1 : valueEnd;\n      }\n\n      this.valueRange = new Range(start + 1, offset);\n      return offset;\n    }\n    /**\n     * Parses a block value from the source\n     *\n     * Accepted forms are:\n     * ```\n     * BS\n     * block\n     * lines\n     *\n     * BS #comment\n     * block\n     * lines\n     * ```\n     * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines\n     * are empty or have an indent level greater than `indent`.\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this block\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = this.parseBlockHeader(start);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      offset = this.parseBlockValue(offset);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(BlockValue.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      return this.header ? this.header.setOrigRange(cr, offset) : offset;\n    }\n  }, {\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return this.chomping === Chomp.KEEP;\n    }\n  }, {\n    key: \"strValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context2 = this.context,\n          indent = _this$context2.indent,\n          src = _this$context2.src;\n      if (this.valueRange.isEmpty()) return '';\n      var lastNewLine = null;\n      var ch = src[end - 1];\n\n      while (ch === '\\n' || ch === '\\t' || ch === ' ') {\n        end -= 1;\n\n        if (end <= start) {\n          if (this.chomping === Chomp.KEEP) break;else return ''; // probably never happens\n        }\n\n        if (ch === '\\n') lastNewLine = end;\n        ch = src[end - 1];\n      }\n\n      var keepStart = end + 1;\n\n      if (lastNewLine) {\n        if (this.chomping === Chomp.KEEP) {\n          keepStart = lastNewLine;\n          end = this.valueRange.end;\n        } else {\n          end = lastNewLine;\n        }\n      }\n\n      var bi = indent + this.blockIndent;\n      var folded = this.type === Type.BLOCK_FOLDED;\n      var atStart = true;\n      var str = '';\n      var sep = '';\n      var prevMoreIndented = false;\n\n      for (var i = start; i < end; ++i) {\n        for (var j = 0; j < bi; ++j) {\n          if (src[i] !== ' ') break;\n          i += 1;\n        }\n\n        var _ch2 = src[i];\n\n        if (_ch2 === '\\n') {\n          if (sep === '\\n') str += '\\n';else sep = '\\n';\n        } else {\n          var lineEnd = Node.endOfLine(src, i);\n          var line = src.slice(i, lineEnd);\n          i = lineEnd;\n\n          if (folded && (_ch2 === ' ' || _ch2 === '\\t') && i < keepStart) {\n            if (sep === ' ') sep = '\\n';else if (!prevMoreIndented && !atStart && sep === '\\n') sep = '\\n\\n';\n            str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')\n\n            sep = lineEnd < end && src[lineEnd] || '';\n            prevMoreIndented = true;\n          } else {\n            str += sep + line;\n            sep = folded && i < keepStart ? ' ' : '\\n';\n            prevMoreIndented = false;\n          }\n\n          if (atStart && line !== '') atStart = false;\n        }\n      }\n\n      return this.chomping === Chomp.STRIP ? str : str + '\\n';\n    }\n  }]);\n\n  return BlockValue;\n}(Node);\n\nvar FlowCollection = /*#__PURE__*/function (_Node) {\n  _inherits(FlowCollection, _Node);\n\n  var _super = _createSuper(FlowCollection);\n\n  function FlowCollection(type, props) {\n    var _this;\n\n    _classCallCheck(this, FlowCollection);\n\n    _this = _super.call(this, type, props);\n    _this.items = null;\n    return _this;\n  }\n\n  _createClass(FlowCollection, [{\n    key: \"prevNodeIsJsonLike\",\n    value: function prevNodeIsJsonLike() {\n      var idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items.length;\n      var node = this.items[idx - 1];\n      return !!node && (node.jsonLike || node.type === Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src;\n      var indent = context.indent,\n          lineStart = context.lineStart;\n      var _char = src[start]; // { or [\n\n      this.items = [{\n        \"char\": _char,\n        offset: start\n      }];\n      var offset = Node.endOfWhiteSpace(src, start + 1);\n      _char = src[offset];\n\n      while (_char && _char !== ']' && _char !== '}') {\n        switch (_char) {\n          case '\\n':\n            {\n              lineStart = offset + 1;\n              var wsEnd = Node.endOfWhiteSpace(src, lineStart);\n\n              if (src[wsEnd] === '\\n') {\n                var blankLine = new BlankLine();\n                lineStart = blankLine.parse({\n                  src: src\n                }, lineStart);\n                this.items.push(blankLine);\n              }\n\n              offset = Node.endOfIndent(src, lineStart);\n\n              if (offset <= lineStart + indent) {\n                _char = src[offset];\n\n                if (offset < lineStart + indent || _char !== ']' && _char !== '}') {\n                  var msg = 'Insufficient indentation in flow collection';\n                  this.error = new YAMLSemanticError(this, msg);\n                }\n              }\n            }\n            break;\n\n          case ',':\n            {\n              this.items.push({\n                \"char\": _char,\n                offset: offset\n              });\n              offset += 1;\n            }\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.items.push(comment);\n            }\n            break;\n\n          case '?':\n          case ':':\n            {\n              var next = src[offset + 1];\n\n              if (next === '\\n' || next === '\\t' || next === ' ' || next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace\n              _char === ':' && this.prevNodeIsJsonLike()) {\n                this.items.push({\n                  \"char\": _char,\n                  offset: offset\n                });\n                offset += 1;\n                break;\n              }\n            }\n          // fallthrough\n\n          default:\n            {\n              var node = parseNode({\n                atLineStart: false,\n                inCollection: false,\n                inFlow: true,\n                indent: -1,\n                lineStart: lineStart,\n                parent: this\n              }, offset);\n\n              if (!node) {\n                // at next document start\n                this.valueRange = new Range(start, offset);\n                return offset;\n              }\n\n              this.items.push(node);\n              offset = Node.normalizeOffset(src, node.range.end);\n            }\n        }\n\n        offset = Node.endOfWhiteSpace(src, offset);\n        _char = src[offset];\n      }\n\n      this.valueRange = new Range(start, offset + 1);\n\n      if (_char) {\n        this.items.push({\n          \"char\": _char,\n          offset: offset\n        });\n        offset = Node.endOfWhiteSpace(src, offset + 1);\n        offset = this.parseComment(offset);\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(FlowCollection.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.items.forEach(function (node) {\n        if (node instanceof Node) {\n          offset = node.setOrigRanges(cr, offset);\n        } else if (cr.length === 0) {\n          node.origOffset = node.offset;\n        } else {\n          var i = offset;\n\n          while (i < cr.length) {\n            if (cr[i] > node.offset) break;else ++i;\n          }\n\n          node.origOffset = node.offset + i;\n          offset = i;\n        }\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          items = this.items,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var nodes = items.filter(function (item) {\n        return item instanceof Node;\n      });\n      var str = '';\n      var prevEnd = range.start;\n      nodes.forEach(function (node) {\n        var prefix = src.slice(prevEnd, node.range.start);\n        prevEnd = node.range.end;\n        str += prefix + String(node);\n\n        if (str[str.length - 1] === '\\n' && src[prevEnd - 1] !== '\\n' && src[prevEnd] === '\\n') {\n          // Comment range does not include the terminal newline, but its\n          // stringified value does. Without this fix, newlines at comment ends\n          // get duplicated.\n          prevEnd += 1;\n        }\n      });\n      str += src.slice(prevEnd, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }]);\n\n  return FlowCollection;\n}(Node);\n\nvar QuoteDouble = /*#__PURE__*/function (_Node) {\n  _inherits(QuoteDouble, _Node);\n\n  var _super = _createSuper(QuoteDouble);\n\n  function QuoteDouble() {\n    _classCallCheck(this, QuoteDouble);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(QuoteDouble, [{\n    key: \"parseCharCode\",\n    value: function parseCharCode(offset, length, errors) {\n      var src = this.context.src;\n      var cc = src.substr(offset, length);\n      var ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n      var code = ok ? parseInt(cc, 16) : NaN;\n\n      if (isNaN(code)) {\n        errors.push(new YAMLSyntaxError(this, \"Invalid escape sequence \".concat(src.substr(offset - 2, length + 2))));\n        return src.substr(offset - 2, length + 2);\n      }\n\n      return String.fromCodePoint(code);\n    }\n    /**\n     * Parses a \"double quoted\" value from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = QuoteDouble.endOfQuote(src, start + 1);\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }, {\n    key: \"strValue\",\n\n    /**\n     * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n     */\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var errors = [];\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      if (src[end - 1] !== '\"') errors.push(new YAMLSyntaxError(this, 'Missing closing \"quote')); // Using String#replace is too painful with escaped newlines preceded by\n      // escaped backslashes; also, this should be faster.\n\n      var str = '';\n\n      for (var i = start + 1; i < end - 1; ++i) {\n        var ch = src[i];\n\n        if (ch === '\\n') {\n          if (Node.atDocumentBoundary(src, i + 1)) errors.push(new YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n\n          var _Node$foldNewline = Node.foldNewline(src, i, indent),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset,\n              error = _Node$foldNewline.error;\n\n          str += fold;\n          i = offset;\n          if (error) errors.push(new YAMLSemanticError(this, 'Multi-line double-quoted string needs to be sufficiently indented'));\n        } else if (ch === '\\\\') {\n          i += 1;\n\n          switch (src[i]) {\n            case '0':\n              str += '\\0';\n              break;\n            // null character\n\n            case 'a':\n              str += '\\x07';\n              break;\n            // bell character\n\n            case 'b':\n              str += '\\b';\n              break;\n            // backspace\n\n            case 'e':\n              str += '\\x1b';\n              break;\n            // escape character\n\n            case 'f':\n              str += '\\f';\n              break;\n            // form feed\n\n            case 'n':\n              str += '\\n';\n              break;\n            // line feed\n\n            case 'r':\n              str += '\\r';\n              break;\n            // carriage return\n\n            case 't':\n              str += '\\t';\n              break;\n            // horizontal tab\n\n            case 'v':\n              str += '\\v';\n              break;\n            // vertical tab\n\n            case 'N':\n              str += \"\\x85\";\n              break;\n            // Unicode next line\n\n            case '_':\n              str += \"\\xA0\";\n              break;\n            // Unicode non-breaking space\n\n            case 'L':\n              str += \"\\u2028\";\n              break;\n            // Unicode line separator\n\n            case 'P':\n              str += \"\\u2029\";\n              break;\n            // Unicode paragraph separator\n\n            case ' ':\n              str += ' ';\n              break;\n\n            case '\"':\n              str += '\"';\n              break;\n\n            case '/':\n              str += '/';\n              break;\n\n            case '\\\\':\n              str += '\\\\';\n              break;\n\n            case '\\t':\n              str += '\\t';\n              break;\n\n            case 'x':\n              str += this.parseCharCode(i + 1, 2, errors);\n              i += 2;\n              break;\n\n            case 'u':\n              str += this.parseCharCode(i + 1, 4, errors);\n              i += 4;\n              break;\n\n            case 'U':\n              str += this.parseCharCode(i + 1, 8, errors);\n              i += 8;\n              break;\n\n            case '\\n':\n              // skip escaped newlines, but still trim the following line\n              while (src[i + 1] === ' ' || src[i + 1] === '\\t') {\n                i += 1;\n              }\n\n              break;\n\n            default:\n              errors.push(new YAMLSyntaxError(this, \"Invalid escape sequence \".concat(src.substr(i - 1, 2))));\n              str += '\\\\' + src[i];\n          }\n        } else if (ch === ' ' || ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (next === ' ' || next === '\\t') {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n        } else {\n          str += ch;\n        }\n      }\n\n      return errors.length > 0 ? {\n        errors: errors,\n        str: str\n      } : str;\n    }\n  }], [{\n    key: \"endOfQuote\",\n    value: function endOfQuote(src, offset) {\n      var ch = src[offset];\n\n      while (ch && ch !== '\"') {\n        offset += ch === '\\\\' ? 2 : 1;\n        ch = src[offset];\n      }\n\n      return offset + 1;\n    }\n  }]);\n\n  return QuoteDouble;\n}(Node);\n\nvar QuoteSingle = /*#__PURE__*/function (_Node) {\n  _inherits(QuoteSingle, _Node);\n\n  var _super = _createSuper(QuoteSingle);\n\n  function QuoteSingle() {\n    _classCallCheck(this, QuoteSingle);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(QuoteSingle, [{\n    key: \"parse\",\n\n    /**\n     * Parses a 'single quoted' value from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = QuoteSingle.endOfQuote(src, start + 1);\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }, {\n    key: \"strValue\",\n\n    /**\n     * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n     */\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var errors = [];\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      if (src[end - 1] !== \"'\") errors.push(new YAMLSyntaxError(this, \"Missing closing 'quote\"));\n      var str = '';\n\n      for (var i = start + 1; i < end - 1; ++i) {\n        var ch = src[i];\n\n        if (ch === '\\n') {\n          if (Node.atDocumentBoundary(src, i + 1)) errors.push(new YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n\n          var _Node$foldNewline = Node.foldNewline(src, i, indent),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset,\n              error = _Node$foldNewline.error;\n\n          str += fold;\n          i = offset;\n          if (error) errors.push(new YAMLSemanticError(this, 'Multi-line single-quoted string needs to be sufficiently indented'));\n        } else if (ch === \"'\") {\n          str += ch;\n          i += 1;\n          if (src[i] !== \"'\") errors.push(new YAMLSyntaxError(this, 'Unescaped single quote? This should not happen.'));\n        } else if (ch === ' ' || ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (next === ' ' || next === '\\t') {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n        } else {\n          str += ch;\n        }\n      }\n\n      return errors.length > 0 ? {\n        errors: errors,\n        str: str\n      } : str;\n    }\n  }], [{\n    key: \"endOfQuote\",\n    value: function endOfQuote(src, offset) {\n      var ch = src[offset];\n\n      while (ch) {\n        if (ch === \"'\") {\n          if (src[offset + 1] !== \"'\") break;\n          ch = src[offset += 2];\n        } else {\n          ch = src[offset += 1];\n        }\n      }\n\n      return offset + 1;\n    }\n  }]);\n\n  return QuoteSingle;\n}(Node);\n\nfunction createNewNode(type, props) {\n  switch (type) {\n    case Type.ALIAS:\n      return new Alias(type, props);\n\n    case Type.BLOCK_FOLDED:\n    case Type.BLOCK_LITERAL:\n      return new BlockValue(type, props);\n\n    case Type.FLOW_MAP:\n    case Type.FLOW_SEQ:\n      return new FlowCollection(type, props);\n\n    case Type.MAP_KEY:\n    case Type.MAP_VALUE:\n    case Type.SEQ_ITEM:\n      return new CollectionItem(type, props);\n\n    case Type.COMMENT:\n    case Type.PLAIN:\n      return new PlainValue(type, props);\n\n    case Type.QUOTE_DOUBLE:\n      return new QuoteDouble(type, props);\n\n    case Type.QUOTE_SINGLE:\n      return new QuoteSingle(type, props);\n\n    /* istanbul ignore next */\n\n    default:\n      return null;\n    // should never happen\n  }\n}\n/**\n * @param {boolean} atLineStart - Node starts at beginning of line\n * @param {boolean} inFlow - true if currently in a flow context\n * @param {boolean} inCollection - true if currently in a collection context\n * @param {number} indent - Current level of indentation\n * @param {number} lineStart - Start of the current line\n * @param {Node} parent - The parent of the node\n * @param {string} src - Source of the YAML document\n */\n\n\nvar ParseContext = /*#__PURE__*/function () {\n  _createClass(ParseContext, null, [{\n    key: \"parseType\",\n    value: function parseType(src, offset, inFlow) {\n      switch (src[offset]) {\n        case '*':\n          return Type.ALIAS;\n\n        case '>':\n          return Type.BLOCK_FOLDED;\n\n        case '|':\n          return Type.BLOCK_LITERAL;\n\n        case '{':\n          return Type.FLOW_MAP;\n\n        case '[':\n          return Type.FLOW_SEQ;\n\n        case '?':\n          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.MAP_KEY : Type.PLAIN;\n\n        case ':':\n          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.MAP_VALUE : Type.PLAIN;\n\n        case '-':\n          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.SEQ_ITEM : Type.PLAIN;\n\n        case '\"':\n          return Type.QUOTE_DOUBLE;\n\n        case \"'\":\n          return Type.QUOTE_SINGLE;\n\n        default:\n          return Type.PLAIN;\n      }\n    }\n  }]);\n\n  function ParseContext() {\n    var _this = this;\n\n    var orig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        atLineStart = _ref.atLineStart,\n        inCollection = _ref.inCollection,\n        inFlow = _ref.inFlow,\n        indent = _ref.indent,\n        lineStart = _ref.lineStart,\n        parent = _ref.parent;\n\n    _classCallCheck(this, ParseContext);\n\n    _defineProperty(this, \"parseNode\", function (overlay, start) {\n      if (Node.atDocumentBoundary(_this.src, start)) return null;\n      var context = new ParseContext(_this, overlay);\n\n      var _context$parseProps = context.parseProps(start),\n          props = _context$parseProps.props,\n          type = _context$parseProps.type,\n          valueStart = _context$parseProps.valueStart;\n\n      var node = createNewNode(type, props);\n      var offset = node.parse(context, valueStart);\n      node.range = new Range(start, offset);\n      /* istanbul ignore if */\n\n      if (offset <= start) {\n        // This should never happen, but if it does, let's make sure to at least\n        // step one character forward to avoid a busy loop.\n        node.error = new Error(\"Node#parse consumed no characters\");\n        node.error.parseEnd = offset;\n        node.error.source = node;\n        node.range.end = start + 1;\n      }\n\n      if (context.nodeStartsCollection(node)) {\n        if (!node.error && !context.atLineStart && context.parent.type === Type.DOCUMENT) {\n          node.error = new YAMLSyntaxError(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');\n        }\n\n        var collection = new Collection(node);\n        offset = collection.parse(new ParseContext(context), offset);\n        collection.range = new Range(start, offset);\n        return collection;\n      }\n\n      return node;\n    });\n\n    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;\n    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;\n    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;\n    this.indent = indent != null ? indent : orig.indent;\n    this.lineStart = lineStart != null ? lineStart : orig.lineStart;\n    this.parent = parent != null ? parent : orig.parent || {};\n    this.root = orig.root;\n    this.src = orig.src;\n  }\n\n  _createClass(ParseContext, [{\n    key: \"nodeStartsCollection\",\n    value: function nodeStartsCollection(node) {\n      var inCollection = this.inCollection,\n          inFlow = this.inFlow,\n          src = this.src;\n      if (inCollection || inFlow) return false;\n      if (node instanceof CollectionItem) return true; // check for implicit key\n\n      var offset = node.range.end;\n      if (src[offset] === '\\n' || src[offset - 1] === '\\n') return false;\n      offset = Node.endOfWhiteSpace(src, offset);\n      return src[offset] === ':';\n    } // Anchor and tag are before type, which determines the node implementation\n    // class; hence this intermediate step.\n\n  }, {\n    key: \"parseProps\",\n    value: function parseProps(offset) {\n      var inFlow = this.inFlow,\n          parent = this.parent,\n          src = this.src;\n      var props = [];\n      var lineHasProps = false;\n      offset = this.atLineStart ? Node.endOfIndent(src, offset) : Node.endOfWhiteSpace(src, offset);\n      var ch = src[offset];\n\n      while (ch === Char.ANCHOR || ch === Char.COMMENT || ch === Char.TAG || ch === '\\n') {\n        if (ch === '\\n') {\n          var lineStart = offset + 1;\n          var inEnd = Node.endOfIndent(src, lineStart);\n          var indentDiff = inEnd - (lineStart + this.indent);\n          var noIndicatorAsIndent = parent.type === Type.SEQ_ITEM && parent.context.atLineStart;\n          if (!Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;\n          this.atLineStart = true;\n          this.lineStart = lineStart;\n          lineHasProps = false;\n          offset = inEnd;\n        } else if (ch === Char.COMMENT) {\n          var end = Node.endOfLine(src, offset + 1);\n          props.push(new Range(offset, end));\n          offset = end;\n        } else {\n          var _end = Node.endOfIdentifier(src, offset + 1);\n\n          if (ch === Char.TAG && src[_end] === ',' && /^[a-zA-Z0-9-]+\\.[a-zA-Z0-9-]+,\\d\\d\\d\\d(-\\d\\d){0,2}\\/\\S/.test(src.slice(offset + 1, _end + 13))) {\n            // Let's presume we're dealing with a YAML 1.0 domain tag here, rather\n            // than an empty but 'foo.bar' private-tagged node in a flow collection\n            // followed without whitespace by a plain string starting with a year\n            // or date divided by something.\n            _end = Node.endOfIdentifier(src, _end + 5);\n          }\n\n          props.push(new Range(offset, _end));\n          lineHasProps = true;\n          offset = Node.endOfWhiteSpace(src, _end);\n        }\n\n        ch = src[offset];\n      } // '- &a : b' has an anchor on an empty node\n\n\n      if (lineHasProps && ch === ':' && Node.atBlank(src, offset + 1, true)) offset -= 1;\n      var type = ParseContext.parseType(src, offset, inFlow);\n      return {\n        props: props,\n        type: type,\n        valueStart: offset\n      };\n    }\n    /**\n     * Parses a node from the source\n     * @param {ParseContext} overlay\n     * @param {number} start - Index of first non-whitespace character for the node\n     * @returns {?Node} - null if at a document boundary\n     */\n\n  }]);\n\n  return ParseContext;\n}(); // Published as 'yaml/parse-cst'\n\n\nfunction parse(src) {\n  var cr = [];\n\n  if (src.indexOf('\\r') !== -1) {\n    src = src.replace(/\\r\\n?/g, function (match, offset) {\n      if (match.length > 1) cr.push(offset);\n      return '\\n';\n    });\n  }\n\n  var documents = [];\n  var offset = 0;\n\n  do {\n    var doc = new Document();\n    var context = new ParseContext({\n      src: src\n    });\n    offset = doc.parse(context, offset);\n    documents.push(doc);\n  } while (offset < src.length);\n\n  documents.setOrigRanges = function () {\n    if (cr.length === 0) return false;\n\n    for (var i = 1; i < cr.length; ++i) {\n      cr[i] -= i;\n    }\n\n    var crOffset = 0;\n\n    for (var _i = 0; _i < documents.length; ++_i) {\n      crOffset = documents[_i].setOrigRanges(cr, crOffset);\n    }\n\n    cr.splice(0, cr.length);\n    return true;\n  };\n\n  documents.toString = function () {\n    return documents.join('...\\n');\n  };\n\n  return documents;\n}\n\n\n;// CONCATENATED MODULE: ./node_modules/yaml/browser/dist/resolveSeq-04825f30.js\n\n\nfunction addCommentBefore(str, indent, comment) {\n  if (!comment) return str;\n  var cc = comment.replace(/[\\s\\S]^/gm, \"$&\".concat(indent, \"#\"));\n  return \"#\".concat(cc, \"\\n\").concat(indent).concat(str);\n}\n\nfunction addComment(str, indent, comment) {\n  return !comment ? str : comment.indexOf('\\n') === -1 ? \"\".concat(str, \" #\").concat(comment) : \"\".concat(str, \"\\n\") + comment.replace(/^/gm, \"\".concat(indent || '', \"#\"));\n}\n\nvar resolveSeq_04825f30_Node = function Node() {\n  _classCallCheck(this, Node);\n};\n\nfunction toJSON(value, arg, ctx) {\n  if (Array.isArray(value)) return value.map(function (v, i) {\n    return toJSON(v, String(i), ctx);\n  });\n\n  if (value && typeof value.toJSON === 'function') {\n    var anchor = ctx && ctx.anchors && ctx.anchors.get(value);\n    if (anchor) ctx.onCreate = function (res) {\n      anchor.res = res;\n      delete ctx.onCreate;\n    };\n    var res = value.toJSON(arg, ctx);\n    if (anchor && ctx.onCreate) ctx.onCreate(res);\n    return res;\n  }\n\n  if ((!ctx || !ctx.keep) && typeof value === 'bigint') return Number(value);\n  return value;\n}\n\nvar Scalar = /*#__PURE__*/function (_Node) {\n  _inherits(Scalar, _Node);\n\n  var _super = _createSuper(Scalar);\n\n  function Scalar(value) {\n    var _this;\n\n    _classCallCheck(this, Scalar);\n\n    _this = _super.call(this);\n    _this.value = value;\n    return _this;\n  }\n\n  _createClass(Scalar, [{\n    key: \"toJSON\",\n    value: function toJSON$1(arg, ctx) {\n      return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return String(this.value);\n    }\n  }]);\n\n  return Scalar;\n}(resolveSeq_04825f30_Node);\n\nfunction collectionFromPath(schema, path, value) {\n  var v = value;\n\n  for (var i = path.length - 1; i >= 0; --i) {\n    var k = path[i];\n    var o = Number.isInteger(k) && k >= 0 ? [] : {};\n    o[k] = v;\n    v = o;\n  }\n\n  return schema.createNode(v, false);\n} // null, undefined, or an empty non-string iterable (e.g. [])\n\n\nvar isEmptyPath = function isEmptyPath(path) {\n  return path == null || _typeof(path) === 'object' && path[Symbol.iterator]().next().done;\n};\n\nvar resolveSeq_04825f30_Collection = /*#__PURE__*/function (_Node) {\n  _inherits(Collection, _Node);\n\n  var _super = _createSuper(Collection);\n\n  function Collection(schema) {\n    var _this;\n\n    _classCallCheck(this, Collection);\n\n    _this = _super.call(this);\n\n    _defineProperty(_assertThisInitialized(_this), \"items\", []);\n\n    _this.schema = schema;\n    return _this;\n  }\n\n  _createClass(Collection, [{\n    key: \"addIn\",\n    value: function addIn(path, value) {\n      if (isEmptyPath(path)) this.add(value);else {\n        var _path = _toArray(path),\n            key = _path[0],\n            rest = _path.slice(1);\n\n        var node = this.get(key, true);\n        if (node instanceof Collection) node.addIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(\"Expected YAML collection at \".concat(key, \". Remaining path: \").concat(rest));\n      }\n    }\n  }, {\n    key: \"deleteIn\",\n    value: function deleteIn(_ref) {\n      var _ref2 = _toArray(_ref),\n          key = _ref2[0],\n          rest = _ref2.slice(1);\n\n      if (rest.length === 0) return this[\"delete\"](key);\n      var node = this.get(key, true);\n      if (node instanceof Collection) return node.deleteIn(rest);else throw new Error(\"Expected YAML collection at \".concat(key, \". Remaining path: \").concat(rest));\n    }\n  }, {\n    key: \"getIn\",\n    value: function getIn(_ref3, keepScalar) {\n      var _ref4 = _toArray(_ref3),\n          key = _ref4[0],\n          rest = _ref4.slice(1);\n\n      var node = this.get(key, true);\n      if (rest.length === 0) return !keepScalar && node instanceof Scalar ? node.value : node;else return node instanceof Collection ? node.getIn(rest, keepScalar) : undefined;\n    }\n  }, {\n    key: \"hasAllNullValues\",\n    value: function hasAllNullValues() {\n      return this.items.every(function (node) {\n        if (!node || node.type !== 'PAIR') return false;\n        var n = node.value;\n        return n == null || n instanceof Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;\n      });\n    }\n  }, {\n    key: \"hasIn\",\n    value: function hasIn(_ref5) {\n      var _ref6 = _toArray(_ref5),\n          key = _ref6[0],\n          rest = _ref6.slice(1);\n\n      if (rest.length === 0) return this.has(key);\n      var node = this.get(key, true);\n      return node instanceof Collection ? node.hasIn(rest) : false;\n    }\n  }, {\n    key: \"setIn\",\n    value: function setIn(_ref7, value) {\n      var _ref8 = _toArray(_ref7),\n          key = _ref8[0],\n          rest = _ref8.slice(1);\n\n      if (rest.length === 0) {\n        this.set(key, value);\n      } else {\n        var node = this.get(key, true);\n        if (node instanceof Collection) node.setIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(\"Expected YAML collection at \".concat(key, \". Remaining path: \").concat(rest));\n      }\n    } // overridden in implementations\n\n    /* istanbul ignore next */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return null;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(ctx, _ref9, onComment, onChompKeep) {\n      var _this2 = this;\n\n      var blockItem = _ref9.blockItem,\n          flowChars = _ref9.flowChars,\n          isMap = _ref9.isMap,\n          itemIndent = _ref9.itemIndent;\n      var _ctx = ctx,\n          indent = _ctx.indent,\n          indentStep = _ctx.indentStep,\n          stringify = _ctx.stringify;\n      var inFlow = this.type === Type.FLOW_MAP || this.type === Type.FLOW_SEQ || ctx.inFlow;\n      if (inFlow) itemIndent += indentStep;\n      var allNullValues = isMap && this.hasAllNullValues();\n      ctx = Object.assign({}, ctx, {\n        allNullValues: allNullValues,\n        indent: itemIndent,\n        inFlow: inFlow,\n        type: null\n      });\n      var chompKeep = false;\n      var hasItemWithNewLine = false;\n      var nodes = this.items.reduce(function (nodes, item, i) {\n        var comment;\n\n        if (item) {\n          if (!chompKeep && item.spaceBefore) nodes.push({\n            type: 'comment',\n            str: ''\n          });\n          if (item.commentBefore) item.commentBefore.match(/^.*$/gm).forEach(function (line) {\n            nodes.push({\n              type: 'comment',\n              str: \"#\".concat(line)\n            });\n          });\n          if (item.comment) comment = item.comment;\n          if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment))) hasItemWithNewLine = true;\n        }\n\n        chompKeep = false;\n        var str = stringify(item, ctx, function () {\n          return comment = null;\n        }, function () {\n          return chompKeep = true;\n        });\n        if (inFlow && !hasItemWithNewLine && str.includes('\\n')) hasItemWithNewLine = true;\n        if (inFlow && i < _this2.items.length - 1) str += ',';\n        str = addComment(str, itemIndent, comment);\n        if (chompKeep && (comment || inFlow)) chompKeep = false;\n        nodes.push({\n          type: 'item',\n          str: str\n        });\n        return nodes;\n      }, []);\n      var str;\n\n      if (nodes.length === 0) {\n        str = flowChars.start + flowChars.end;\n      } else if (inFlow) {\n        var start = flowChars.start,\n            end = flowChars.end;\n        var strings = nodes.map(function (n) {\n          return n.str;\n        });\n\n        if (hasItemWithNewLine || strings.reduce(function (sum, str) {\n          return sum + str.length + 2;\n        }, 2) > Collection.maxFlowStringSingleLineLength) {\n          str = start;\n\n          var _iterator = _createForOfIteratorHelper(strings),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var s = _step.value;\n              str += s ? \"\\n\".concat(indentStep).concat(indent).concat(s) : '\\n';\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          str += \"\\n\".concat(indent).concat(end);\n        } else {\n          str = \"\".concat(start, \" \").concat(strings.join(' '), \" \").concat(end);\n        }\n      } else {\n        var _strings = nodes.map(blockItem);\n\n        str = _strings.shift();\n\n        var _iterator2 = _createForOfIteratorHelper(_strings),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _s = _step2.value;\n            str += _s ? \"\\n\".concat(indent).concat(_s) : '\\n';\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      if (this.comment) {\n        str += '\\n' + this.comment.replace(/^/gm, \"\".concat(indent, \"#\"));\n        if (onComment) onComment();\n      } else if (chompKeep && onChompKeep) onChompKeep();\n\n      return str;\n    }\n  }]);\n\n  return Collection;\n}(resolveSeq_04825f30_Node);\n\n_defineProperty(resolveSeq_04825f30_Collection, \"maxFlowStringSingleLineLength\", 60);\n\nfunction asItemIndex(key) {\n  var idx = key instanceof Scalar ? key.value : key;\n  if (idx && typeof idx === 'string') idx = Number(idx);\n  return Number.isInteger(idx) && idx >= 0 ? idx : null;\n}\n\nvar YAMLSeq = /*#__PURE__*/function (_Collection) {\n  _inherits(YAMLSeq, _Collection);\n\n  var _super = _createSuper(YAMLSeq);\n\n  function YAMLSeq() {\n    _classCallCheck(this, YAMLSeq);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(YAMLSeq, [{\n    key: \"add\",\n    value: function add(value) {\n      this.items.push(value);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      var idx = asItemIndex(key);\n      if (typeof idx !== 'number') return false;\n      var del = this.items.splice(idx, 1);\n      return del.length > 0;\n    }\n  }, {\n    key: \"get\",\n    value: function get(key, keepScalar) {\n      var idx = asItemIndex(key);\n      if (typeof idx !== 'number') return undefined;\n      var it = this.items[idx];\n      return !keepScalar && it instanceof Scalar ? it.value : it;\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      var idx = asItemIndex(key);\n      return typeof idx === 'number' && idx < this.items.length;\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      var idx = asItemIndex(key);\n      if (typeof idx !== 'number') throw new Error(\"Expected a valid index, not \".concat(key, \".\"));\n      this.items[idx] = value;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON$1(_, ctx) {\n      var seq = [];\n      if (ctx && ctx.onCreate) ctx.onCreate(seq);\n      var i = 0;\n\n      var _iterator = _createForOfIteratorHelper(this.items),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var item = _step.value;\n          seq.push(toJSON(item, String(i++), ctx));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return seq;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(ctx, onComment, onChompKeep) {\n      if (!ctx) return JSON.stringify(this);\n      return _get(_getPrototypeOf(YAMLSeq.prototype), \"toString\", this).call(this, ctx, {\n        blockItem: function blockItem(n) {\n          return n.type === 'comment' ? n.str : \"- \".concat(n.str);\n        },\n        flowChars: {\n          start: '[',\n          end: ']'\n        },\n        isMap: false,\n        itemIndent: (ctx.indent || '') + '  '\n      }, onComment, onChompKeep);\n    }\n  }]);\n\n  return YAMLSeq;\n}(resolveSeq_04825f30_Collection);\n\nvar stringifyKey = function stringifyKey(key, jsKey, ctx) {\n  if (jsKey === null) return '';\n  if (_typeof(jsKey) !== 'object') return String(jsKey);\n  if (key instanceof resolveSeq_04825f30_Node && ctx && ctx.doc) return key.toString({\n    anchors: {},\n    doc: ctx.doc,\n    indent: '',\n    indentStep: ctx.indentStep,\n    inFlow: true,\n    inStringifyKey: true,\n    stringify: ctx.stringify\n  });\n  return JSON.stringify(jsKey);\n};\n\nvar Pair = /*#__PURE__*/function (_Node) {\n  _inherits(Pair, _Node);\n\n  var _super = _createSuper(Pair);\n\n  function Pair(key) {\n    var _this;\n\n    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _classCallCheck(this, Pair);\n\n    _this = _super.call(this);\n    _this.key = key;\n    _this.value = value;\n    _this.type = Pair.Type.PAIR;\n    return _this;\n  }\n\n  _createClass(Pair, [{\n    key: \"addToJSMap\",\n    value: function addToJSMap(ctx, map) {\n      var key = toJSON(this.key, '', ctx);\n\n      if (map instanceof Map) {\n        var value = toJSON(this.value, key, ctx);\n        map.set(key, value);\n      } else if (map instanceof Set) {\n        map.add(key);\n      } else {\n        var stringKey = stringifyKey(this.key, key, ctx);\n        map[stringKey] = toJSON(this.value, stringKey, ctx);\n      }\n\n      return map;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(_, ctx) {\n      var pair = ctx && ctx.mapAsMap ? new Map() : {};\n      return this.addToJSMap(ctx, pair);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(ctx, onComment, onChompKeep) {\n      if (!ctx || !ctx.doc) return JSON.stringify(this);\n      var _ctx$doc$options = ctx.doc.options,\n          indentSize = _ctx$doc$options.indent,\n          indentSeq = _ctx$doc$options.indentSeq,\n          simpleKeys = _ctx$doc$options.simpleKeys;\n      var key = this.key,\n          value = this.value;\n      var keyComment = key instanceof resolveSeq_04825f30_Node && key.comment;\n\n      if (simpleKeys) {\n        if (keyComment) {\n          throw new Error('With simple keys, key nodes cannot have comments');\n        }\n\n        if (key instanceof resolveSeq_04825f30_Collection) {\n          var msg = 'With simple keys, collection cannot be used as a key value';\n          throw new Error(msg);\n        }\n      }\n\n      var explicitKey = !simpleKeys && (!key || keyComment || key instanceof resolveSeq_04825f30_Collection || key.type === Type.BLOCK_FOLDED || key.type === Type.BLOCK_LITERAL);\n      var _ctx = ctx,\n          doc = _ctx.doc,\n          indent = _ctx.indent,\n          indentStep = _ctx.indentStep,\n          stringify = _ctx.stringify;\n      ctx = Object.assign({}, ctx, {\n        implicitKey: !explicitKey,\n        indent: indent + indentStep\n      });\n      var chompKeep = false;\n      var str = stringify(key, ctx, function () {\n        return keyComment = null;\n      }, function () {\n        return chompKeep = true;\n      });\n      str = addComment(str, ctx.indent, keyComment);\n\n      if (ctx.allNullValues && !simpleKeys) {\n        if (this.comment) {\n          str = addComment(str, ctx.indent, this.comment);\n          if (onComment) onComment();\n        } else if (chompKeep && !keyComment && onChompKeep) onChompKeep();\n\n        return ctx.inFlow ? str : \"? \".concat(str);\n      }\n\n      str = explicitKey ? \"? \".concat(str, \"\\n\").concat(indent, \":\") : \"\".concat(str, \":\");\n\n      if (this.comment) {\n        // expected (but not strictly required) to be a single-line comment\n        str = addComment(str, ctx.indent, this.comment);\n        if (onComment) onComment();\n      }\n\n      var vcb = '';\n      var valueComment = null;\n\n      if (value instanceof resolveSeq_04825f30_Node) {\n        if (value.spaceBefore) vcb = '\\n';\n\n        if (value.commentBefore) {\n          var cs = value.commentBefore.replace(/^/gm, \"\".concat(ctx.indent, \"#\"));\n          vcb += \"\\n\".concat(cs);\n        }\n\n        valueComment = value.comment;\n      } else if (value && _typeof(value) === 'object') {\n        value = doc.schema.createNode(value, true);\n      }\n\n      ctx.implicitKey = false;\n      if (!explicitKey && !this.comment && value instanceof Scalar) ctx.indentAtStart = str.length + 1;\n      chompKeep = false;\n\n      if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {\n        // If indentSeq === false, consider '- ' as part of indentation where possible\n        ctx.indent = ctx.indent.substr(2);\n      }\n\n      var valueStr = stringify(value, ctx, function () {\n        return valueComment = null;\n      }, function () {\n        return chompKeep = true;\n      });\n      var ws = ' ';\n\n      if (vcb || this.comment) {\n        ws = \"\".concat(vcb, \"\\n\").concat(ctx.indent);\n      } else if (!explicitKey && value instanceof resolveSeq_04825f30_Collection) {\n        var flow = valueStr[0] === '[' || valueStr[0] === '{';\n        if (!flow || valueStr.includes('\\n')) ws = \"\\n\".concat(ctx.indent);\n      }\n\n      if (chompKeep && !valueComment && onChompKeep) onChompKeep();\n      return addComment(str + ws + valueStr, ctx.indent, valueComment);\n    }\n  }, {\n    key: \"commentBefore\",\n    get: function get() {\n      return this.key instanceof resolveSeq_04825f30_Node ? this.key.commentBefore : undefined;\n    },\n    set: function set(cb) {\n      if (this.key == null) this.key = new Scalar(null);\n      if (this.key instanceof resolveSeq_04825f30_Node) this.key.commentBefore = cb;else {\n        var msg = 'Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.';\n        throw new Error(msg);\n      }\n    }\n  }]);\n\n  return Pair;\n}(resolveSeq_04825f30_Node);\n\n_defineProperty(Pair, \"Type\", {\n  PAIR: 'PAIR',\n  MERGE_PAIR: 'MERGE_PAIR'\n});\n\nvar getAliasCount = function getAliasCount(node, anchors) {\n  if (node instanceof resolveSeq_04825f30_Alias) {\n    var anchor = anchors.get(node.source);\n    return anchor.count * anchor.aliasCount;\n  } else if (node instanceof resolveSeq_04825f30_Collection) {\n    var count = 0;\n\n    var _iterator = _createForOfIteratorHelper(node.items),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var item = _step.value;\n        var c = getAliasCount(item, anchors);\n        if (c > count) count = c;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return count;\n  } else if (node instanceof Pair) {\n    var kc = getAliasCount(node.key, anchors);\n    var vc = getAliasCount(node.value, anchors);\n    return Math.max(kc, vc);\n  }\n\n  return 1;\n};\n\nvar resolveSeq_04825f30_Alias = /*#__PURE__*/function (_Node) {\n  _inherits(Alias, _Node);\n\n  var _super = _createSuper(Alias);\n\n  _createClass(Alias, null, [{\n    key: \"stringify\",\n    value: function stringify(_ref, _ref2) {\n      var range = _ref.range,\n          source = _ref.source;\n      var anchors = _ref2.anchors,\n          doc = _ref2.doc,\n          implicitKey = _ref2.implicitKey,\n          inStringifyKey = _ref2.inStringifyKey;\n      var anchor = Object.keys(anchors).find(function (a) {\n        return anchors[a] === source;\n      });\n      if (!anchor && inStringifyKey) anchor = doc.anchors.getName(source) || doc.anchors.newName();\n      if (anchor) return \"*\".concat(anchor).concat(implicitKey ? ' ' : '');\n      var msg = doc.anchors.getName(source) ? 'Alias node must be after source node' : 'Source node not found for alias node';\n      throw new Error(\"\".concat(msg, \" [\").concat(range, \"]\"));\n    }\n  }]);\n\n  function Alias(source) {\n    var _this;\n\n    _classCallCheck(this, Alias);\n\n    _this = _super.call(this);\n    _this.source = source;\n    _this.type = Type.ALIAS;\n    return _this;\n  }\n\n  _createClass(Alias, [{\n    key: \"toJSON\",\n    value: function toJSON$1(arg, ctx) {\n      if (!ctx) return toJSON(this.source, arg, ctx);\n      var anchors = ctx.anchors,\n          maxAliasCount = ctx.maxAliasCount;\n      var anchor = anchors.get(this.source);\n      /* istanbul ignore if */\n\n      if (!anchor || anchor.res === undefined) {\n        var msg = 'This should not happen: Alias anchor was not resolved?';\n        if (this.cstNode) throw new YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);\n      }\n\n      if (maxAliasCount >= 0) {\n        anchor.count += 1;\n        if (anchor.aliasCount === 0) anchor.aliasCount = getAliasCount(this.source, anchors);\n\n        if (anchor.count * anchor.aliasCount > maxAliasCount) {\n          var _msg = 'Excessive alias count indicates a resource exhaustion attack';\n          if (this.cstNode) throw new YAMLReferenceError(this.cstNode, _msg);else throw new ReferenceError(_msg);\n        }\n      }\n\n      return anchor.res;\n    } // Only called when stringifying an alias mapping key while constructing\n    // Object output.\n\n  }, {\n    key: \"toString\",\n    value: function toString(ctx) {\n      return Alias.stringify(this, ctx);\n    }\n  }, {\n    key: \"tag\",\n    set: function set(t) {\n      throw new Error('Alias nodes cannot have tags');\n    }\n  }]);\n\n  return Alias;\n}(resolveSeq_04825f30_Node);\n\n_defineProperty(resolveSeq_04825f30_Alias, \"default\", true);\n\nfunction findPair(items, key) {\n  var k = key instanceof Scalar ? key.value : key;\n\n  var _iterator = _createForOfIteratorHelper(items),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var it = _step.value;\n\n      if (it instanceof Pair) {\n        if (it.key === key || it.key === k) return it;\n        if (it.key && it.key.value === k) return it;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return undefined;\n}\n\nvar YAMLMap = /*#__PURE__*/function (_Collection) {\n  _inherits(YAMLMap, _Collection);\n\n  var _super = _createSuper(YAMLMap);\n\n  function YAMLMap() {\n    _classCallCheck(this, YAMLMap);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(YAMLMap, [{\n    key: \"add\",\n    value: function add(pair, overwrite) {\n      if (!pair) pair = new Pair(pair);else if (!(pair instanceof Pair)) pair = new Pair(pair.key || pair, pair.value);\n      var prev = findPair(this.items, pair.key);\n      var sortEntries = this.schema && this.schema.sortMapEntries;\n\n      if (prev) {\n        if (overwrite) prev.value = pair.value;else throw new Error(\"Key \".concat(pair.key, \" already set\"));\n      } else if (sortEntries) {\n        var i = this.items.findIndex(function (item) {\n          return sortEntries(pair, item) < 0;\n        });\n        if (i === -1) this.items.push(pair);else this.items.splice(i, 0, pair);\n      } else {\n        this.items.push(pair);\n      }\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      var it = findPair(this.items, key);\n      if (!it) return false;\n      var del = this.items.splice(this.items.indexOf(it), 1);\n      return del.length > 0;\n    }\n  }, {\n    key: \"get\",\n    value: function get(key, keepScalar) {\n      var it = findPair(this.items, key);\n      var node = it && it.value;\n      return !keepScalar && node instanceof Scalar ? node.value : node;\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return !!findPair(this.items, key);\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      this.add(new Pair(key, value), true);\n    }\n    /**\n     * @param {*} arg ignored\n     * @param {*} ctx Conversion context, originally set in Document#toJSON()\n     * @param {Class} Type If set, forces the returned collection type\n     * @returns {*} Instance of Type, Map, or Object\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(_, ctx, Type) {\n      var map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};\n      if (ctx && ctx.onCreate) ctx.onCreate(map);\n\n      var _iterator2 = _createForOfIteratorHelper(this.items),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var item = _step2.value;\n          item.addToJSMap(ctx, map);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return map;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(ctx, onComment, onChompKeep) {\n      if (!ctx) return JSON.stringify(this);\n\n      var _iterator3 = _createForOfIteratorHelper(this.items),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var item = _step3.value;\n          if (!(item instanceof Pair)) throw new Error(\"Map items must all be pairs; found \".concat(JSON.stringify(item), \" instead\"));\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return _get(_getPrototypeOf(YAMLMap.prototype), \"toString\", this).call(this, ctx, {\n        blockItem: function blockItem(n) {\n          return n.str;\n        },\n        flowChars: {\n          start: '{',\n          end: '}'\n        },\n        isMap: true,\n        itemIndent: ctx.indent || ''\n      }, onComment, onChompKeep);\n    }\n  }]);\n\n  return YAMLMap;\n}(resolveSeq_04825f30_Collection);\n\nvar MERGE_KEY = '<<';\n\nvar Merge = /*#__PURE__*/function (_Pair) {\n  _inherits(Merge, _Pair);\n\n  var _super = _createSuper(Merge);\n\n  function Merge(pair) {\n    var _this;\n\n    _classCallCheck(this, Merge);\n\n    if (pair instanceof Pair) {\n      var seq = pair.value;\n\n      if (!(seq instanceof YAMLSeq)) {\n        seq = new YAMLSeq();\n        seq.items.push(pair.value);\n        seq.range = pair.value.range;\n      }\n\n      _this = _super.call(this, pair.key, seq);\n      _this.range = pair.range;\n    } else {\n      _this = _super.call(this, new Scalar(MERGE_KEY), new YAMLSeq());\n    }\n\n    _this.type = Pair.Type.MERGE_PAIR;\n    return _possibleConstructorReturn(_this);\n  } // If the value associated with a merge key is a single mapping node, each of\n  // its key/value pairs is inserted into the current mapping, unless the key\n  // already exists in it. If the value associated with the merge key is a\n  // sequence, then this sequence is expected to contain mapping nodes and each\n  // of these nodes is merged in turn according to its order in the sequence.\n  // Keys in mapping nodes earlier in the sequence override keys specified in\n  // later mapping nodes. -- http://yaml.org/type/merge.html\n\n\n  _createClass(Merge, [{\n    key: \"addToJSMap\",\n    value: function addToJSMap(ctx, map) {\n      var _iterator = _createForOfIteratorHelper(this.value.items),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var source = _step.value.source;\n          if (!(source instanceof YAMLMap)) throw new Error('Merge sources must be maps');\n          var srcMap = source.toJSON(null, ctx, Map);\n\n          var _iterator2 = _createForOfIteratorHelper(srcMap),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _step2$value = _slicedToArray(_step2.value, 2),\n                  key = _step2$value[0],\n                  value = _step2$value[1];\n\n              if (map instanceof Map) {\n                if (!map.has(key)) map.set(key, value);\n              } else if (map instanceof Set) {\n                map.add(key);\n              } else {\n                if (!Object.prototype.hasOwnProperty.call(map, key)) map[key] = value;\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return map;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(ctx, onComment) {\n      var seq = this.value;\n      if (seq.items.length > 1) return _get(_getPrototypeOf(Merge.prototype), \"toString\", this).call(this, ctx, onComment);\n      this.value = seq.items[0];\n\n      var str = _get(_getPrototypeOf(Merge.prototype), \"toString\", this).call(this, ctx, onComment);\n\n      this.value = seq;\n      return str;\n    }\n  }]);\n\n  return Merge;\n}(Pair);\n\nvar binaryOptions = {\n  defaultType: Type.BLOCK_LITERAL,\n  lineWidth: 76\n};\nvar boolOptions = {\n  trueStr: 'true',\n  falseStr: 'false'\n};\nvar intOptions = {\n  asBigInt: false\n};\nvar nullOptions = {\n  nullStr: 'null'\n};\nvar strOptions = {\n  defaultType: Type.PLAIN,\n  doubleQuoted: {\n    jsonEncoding: false,\n    minMultiLineLength: 40\n  },\n  fold: {\n    lineWidth: 80,\n    minContentWidth: 20\n  }\n};\n\nfunction resolveScalar(str, tags, scalarFallback) {\n  var _iterator = _createForOfIteratorHelper(tags),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _step.value,\n          format = _step$value.format,\n          test = _step$value.test,\n          resolve = _step$value.resolve;\n\n      if (test) {\n        var match = str.match(test);\n\n        if (match) {\n          var res = resolve.apply(null, match);\n          if (!(res instanceof Scalar)) res = new Scalar(res);\n          if (format) res.format = format;\n          return res;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (scalarFallback) str = scalarFallback(str);\n  return new Scalar(str);\n}\n\nvar FOLD_FLOW = 'flow';\nvar FOLD_BLOCK = 'block';\nvar FOLD_QUOTED = 'quoted'; // presumes i+1 is at the start of a line\n// returns index of last newline in more-indented block\n\nvar consumeMoreIndentedLines = function consumeMoreIndentedLines(text, i) {\n  var ch = text[i + 1];\n\n  while (ch === ' ' || ch === '\\t') {\n    do {\n      ch = text[i += 1];\n    } while (ch && ch !== '\\n');\n\n    ch = text[i + 1];\n  }\n\n  return i;\n};\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n *\n * @param {string} text\n * @param {string} indent\n * @param {string} [mode='flow'] `'block'` prevents more-indented lines\n *   from being folded; `'quoted'` allows for `\\` escapes, including escaped\n *   newlines\n * @param {Object} options\n * @param {number} [options.indentAtStart] Accounts for leading contents on\n *   the first line, defaulting to `indent.length`\n * @param {number} [options.lineWidth=80]\n * @param {number} [options.minContentWidth=20] Allow highly indented lines to\n *   stretch the line width\n * @param {function} options.onFold Called once if the text is folded\n * @param {function} options.onFold Called once if any line of text exceeds\n *   lineWidth characters\n */\n\n\nfunction foldFlowLines(text, indent, mode, _ref) {\n  var indentAtStart = _ref.indentAtStart,\n      _ref$lineWidth = _ref.lineWidth,\n      lineWidth = _ref$lineWidth === void 0 ? 80 : _ref$lineWidth,\n      _ref$minContentWidth = _ref.minContentWidth,\n      minContentWidth = _ref$minContentWidth === void 0 ? 20 : _ref$minContentWidth,\n      onFold = _ref.onFold,\n      onOverflow = _ref.onOverflow;\n  if (!lineWidth || lineWidth < 0) return text;\n  var endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n  if (text.length <= endStep) return text;\n  var folds = [];\n  var escapedFolds = {};\n  var end = lineWidth - (typeof indentAtStart === 'number' ? indentAtStart : indent.length);\n  var split = undefined;\n  var prev = undefined;\n  var overflow = false;\n  var i = -1;\n\n  if (mode === FOLD_BLOCK) {\n    i = consumeMoreIndentedLines(text, i);\n    if (i !== -1) end = i + endStep;\n  }\n\n  for (var ch; ch = text[i += 1];) {\n    if (mode === FOLD_QUOTED && ch === '\\\\') {\n      switch (text[i + 1]) {\n        case 'x':\n          i += 3;\n          break;\n\n        case 'u':\n          i += 5;\n          break;\n\n        case 'U':\n          i += 9;\n          break;\n\n        default:\n          i += 1;\n      }\n    }\n\n    if (ch === '\\n') {\n      if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);\n      end = i + endStep;\n      split = undefined;\n    } else {\n      if (ch === ' ' && prev && prev !== ' ' && prev !== '\\n' && prev !== '\\t') {\n        // space surrounded by non-space can be replaced with newline + indent\n        var next = text[i + 1];\n        if (next && next !== ' ' && next !== '\\n' && next !== '\\t') split = i;\n      }\n\n      if (i >= end) {\n        if (split) {\n          folds.push(split);\n          end = split + endStep;\n          split = undefined;\n        } else if (mode === FOLD_QUOTED) {\n          // white-space collected at end may stretch past lineWidth\n          while (prev === ' ' || prev === '\\t') {\n            prev = ch;\n            ch = text[i += 1];\n            overflow = true;\n          } // i - 2 accounts for not-dropped last char + newline-escaping \\\n\n\n          folds.push(i - 2);\n          escapedFolds[i - 2] = true;\n          end = i - 2 + endStep;\n          split = undefined;\n        } else {\n          overflow = true;\n        }\n      }\n    }\n\n    prev = ch;\n  }\n\n  if (overflow && onOverflow) onOverflow();\n  if (folds.length === 0) return text;\n  if (onFold) onFold();\n  var res = text.slice(0, folds[0]);\n\n  for (var _i = 0; _i < folds.length; ++_i) {\n    var fold = folds[_i];\n\n    var _end = folds[_i + 1] || text.length;\n\n    if (mode === FOLD_QUOTED && escapedFolds[fold]) res += \"\".concat(text[fold], \"\\\\\");\n    res += \"\\n\".concat(indent).concat(text.slice(fold + 1, _end));\n  }\n\n  return res;\n}\n\nvar getFoldOptions = function getFoldOptions(_ref) {\n  var indentAtStart = _ref.indentAtStart;\n  return indentAtStart ? Object.assign({\n    indentAtStart: indentAtStart\n  }, strOptions.fold) : strOptions.fold;\n}; // Also checks for lines starting with %, as parsing the output as YAML 1.1 will\n// presume that's starting a new document.\n\n\nvar containsDocumentMarker = function containsDocumentMarker(str) {\n  return /^(%|---|\\.\\.\\.)/m.test(str);\n};\n\nfunction lineLengthOverLimit(str, limit) {\n  var strLen = str.length;\n  if (strLen <= limit) return false;\n\n  for (var i = 0, start = 0; i < strLen; ++i) {\n    if (str[i] === '\\n') {\n      if (i - start > limit) return true;\n      start = i + 1;\n      if (strLen - start <= limit) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction doubleQuotedString(value, ctx) {\n  var implicitKey = ctx.implicitKey;\n  var _strOptions$doubleQuo = strOptions.doubleQuoted,\n      jsonEncoding = _strOptions$doubleQuo.jsonEncoding,\n      minMultiLineLength = _strOptions$doubleQuo.minMultiLineLength;\n  var json = JSON.stringify(value);\n  if (jsonEncoding) return json;\n  var indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  var str = '';\n  var start = 0;\n\n  for (var i = 0, ch = json[i]; ch; ch = json[++i]) {\n    if (ch === ' ' && json[i + 1] === '\\\\' && json[i + 2] === 'n') {\n      // space before newline needs to be escaped to not be folded\n      str += json.slice(start, i) + '\\\\ ';\n      i += 1;\n      start = i;\n      ch = '\\\\';\n    }\n\n    if (ch === '\\\\') switch (json[i + 1]) {\n      case 'u':\n        {\n          str += json.slice(start, i);\n          var code = json.substr(i + 2, 4);\n\n          switch (code) {\n            case '0000':\n              str += '\\\\0';\n              break;\n\n            case '0007':\n              str += '\\\\a';\n              break;\n\n            case '000b':\n              str += '\\\\v';\n              break;\n\n            case '001b':\n              str += '\\\\e';\n              break;\n\n            case '0085':\n              str += '\\\\N';\n              break;\n\n            case '00a0':\n              str += '\\\\_';\n              break;\n\n            case '2028':\n              str += '\\\\L';\n              break;\n\n            case '2029':\n              str += '\\\\P';\n              break;\n\n            default:\n              if (code.substr(0, 2) === '00') str += '\\\\x' + code.substr(2);else str += json.substr(i, 6);\n          }\n\n          i += 5;\n          start = i + 1;\n        }\n        break;\n\n      case 'n':\n        if (implicitKey || json[i + 2] === '\"' || json.length < minMultiLineLength) {\n          i += 1;\n        } else {\n          // folding will eat first newline\n          str += json.slice(start, i) + '\\n\\n';\n\n          while (json[i + 2] === '\\\\' && json[i + 3] === 'n' && json[i + 4] !== '\"') {\n            str += '\\n';\n            i += 2;\n          }\n\n          str += indent; // space after newline needs to be escaped to not be folded\n\n          if (json[i + 2] === ' ') str += '\\\\';\n          i += 1;\n          start = i + 1;\n        }\n\n        break;\n\n      default:\n        i += 1;\n    }\n  }\n\n  str = start ? str + json.slice(start) : json;\n  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));\n}\n\nfunction singleQuotedString(value, ctx) {\n  if (ctx.implicitKey) {\n    if (/\\n/.test(value)) return doubleQuotedString(value, ctx);\n  } else {\n    // single quoted string can't have leading or trailing whitespace around newline\n    if (/[ \\t]\\n|\\n[ \\t]/.test(value)) return doubleQuotedString(value, ctx);\n  }\n\n  var indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  var res = \"'\" + value.replace(/'/g, \"''\").replace(/\\n+/g, \"$&\\n\".concat(indent)) + \"'\";\n  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));\n}\n\nfunction blockString(_ref2, ctx, onComment, onChompKeep) {\n  var comment = _ref2.comment,\n      type = _ref2.type,\n      value = _ref2.value; // 1. Block can't end in whitespace unless the last line is non-empty.\n  // 2. Strings consisting of only whitespace are best rendered explicitly.\n\n  if (/\\n[\\t ]+$/.test(value) || /^\\s*$/.test(value)) {\n    return doubleQuotedString(value, ctx);\n  }\n\n  var indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');\n  var indentSize = indent ? '2' : '1'; // root is at -1\n\n  var literal = type === Type.BLOCK_FOLDED ? false : type === Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth - indent.length);\n  var header = literal ? '|' : '>';\n  if (!value) return header + '\\n';\n  var wsStart = '';\n  var wsEnd = '';\n  value = value.replace(/[\\n\\t ]*$/, function (ws) {\n    var n = ws.indexOf('\\n');\n\n    if (n === -1) {\n      header += '-'; // strip\n    } else if (value === ws || n !== ws.length - 1) {\n      header += '+'; // keep\n\n      if (onChompKeep) onChompKeep();\n    }\n\n    wsEnd = ws.replace(/\\n$/, '');\n    return '';\n  }).replace(/^[\\n ]*/, function (ws) {\n    if (ws.indexOf(' ') !== -1) header += indentSize;\n    var m = ws.match(/ +$/);\n\n    if (m) {\n      wsStart = ws.slice(0, -m[0].length);\n      return m[0];\n    } else {\n      wsStart = ws;\n      return '';\n    }\n  });\n  if (wsEnd) wsEnd = wsEnd.replace(/\\n+(?!\\n|$)/g, \"$&\".concat(indent));\n  if (wsStart) wsStart = wsStart.replace(/\\n+/g, \"$&\".concat(indent));\n\n  if (comment) {\n    header += ' #' + comment.replace(/ ?[\\r\\n]+/g, ' ');\n    if (onComment) onComment();\n  }\n\n  if (!value) return \"\".concat(header).concat(indentSize, \"\\n\").concat(indent).concat(wsEnd);\n\n  if (literal) {\n    value = value.replace(/\\n+/g, \"$&\".concat(indent));\n    return \"\".concat(header, \"\\n\").concat(indent).concat(wsStart).concat(value).concat(wsEnd);\n  }\n\n  value = value.replace(/\\n+/g, '\\n$&').replace(/(?:^|\\n)([\\t ].*)(?:([\\n\\t ]*)\\n(?![\\n\\t ]))?/g, '$1$2') // more-indented lines aren't folded\n  //         ^ ind.line  ^ empty     ^ capture next empty lines only at end of indent\n  .replace(/\\n+/g, \"$&\".concat(indent));\n  var body = foldFlowLines(\"\".concat(wsStart).concat(value).concat(wsEnd), indent, FOLD_BLOCK, strOptions.fold);\n  return \"\".concat(header, \"\\n\").concat(indent).concat(body);\n}\n\nfunction plainString(item, ctx, onComment, onChompKeep) {\n  var comment = item.comment,\n      type = item.type,\n      value = item.value;\n  var actualString = ctx.actualString,\n      implicitKey = ctx.implicitKey,\n      indent = ctx.indent,\n      inFlow = ctx.inFlow;\n\n  if (implicitKey && /[\\n[\\]{},]/.test(value) || inFlow && /[[\\]{},]/.test(value)) {\n    return doubleQuotedString(value, ctx);\n  }\n\n  if (!value || /^[\\n\\t ,[\\]{}#&*!|>'\"%@`]|^[?-]$|^[?-][ \\t]|[\\n:][ \\t]|[ \\t]\\n|[\\n\\t ]#|[\\n\\t :]$/.test(value)) {\n    // not allowed:\n    // - empty string, '-' or '?'\n    // - start with an indicator character (except [?:-]) or /[?-] /\n    // - '\\n ', ': ' or ' \\n' anywhere\n    // - '#' not preceded by a non-space char\n    // - end with ' ' or ':'\n    return implicitKey || inFlow || value.indexOf('\\n') === -1 ? value.indexOf('\"') !== -1 && value.indexOf(\"'\") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  if (!implicitKey && !inFlow && type !== Type.PLAIN && value.indexOf('\\n') !== -1) {\n    // Where allowed & type not set explicitly, prefer block style for multiline strings\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  if (indent === '' && containsDocumentMarker(value)) {\n    ctx.forceBlockIndent = true;\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  var str = value.replace(/\\n+/g, \"$&\\n\".concat(indent)); // Verify that output will be parsed as a string, as e.g. plain numbers and\n  // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),\n  // and others in v1.1.\n\n  if (actualString) {\n    var tags = ctx.doc.schema.tags;\n    var resolved = resolveScalar(str, tags, tags.scalarFallback).value;\n    if (typeof resolved !== 'string') return doubleQuotedString(value, ctx);\n  }\n\n  var body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));\n\n  if (comment && !inFlow && (body.indexOf('\\n') !== -1 || comment.indexOf('\\n') !== -1)) {\n    if (onComment) onComment();\n    return addCommentBefore(body, indent, comment);\n  }\n\n  return body;\n}\n\nfunction stringifyString(item, ctx, onComment, onChompKeep) {\n  var defaultType = strOptions.defaultType;\n  var implicitKey = ctx.implicitKey,\n      inFlow = ctx.inFlow;\n  var _item = item,\n      type = _item.type,\n      value = _item.value;\n\n  if (typeof value !== 'string') {\n    value = String(value);\n    item = Object.assign({}, item, {\n      value: value\n    });\n  }\n\n  var _stringify = function _stringify(_type) {\n    switch (_type) {\n      case Type.BLOCK_FOLDED:\n      case Type.BLOCK_LITERAL:\n        return blockString(item, ctx, onComment, onChompKeep);\n\n      case Type.QUOTE_DOUBLE:\n        return doubleQuotedString(value, ctx);\n\n      case Type.QUOTE_SINGLE:\n        return singleQuotedString(value, ctx);\n\n      case Type.PLAIN:\n        return plainString(item, ctx, onComment, onChompKeep);\n\n      default:\n        return null;\n    }\n  };\n\n  if (type !== Type.QUOTE_DOUBLE && /[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f]/.test(value)) {\n    // force double quotes on control characters\n    type = Type.QUOTE_DOUBLE;\n  } else if ((implicitKey || inFlow) && (type === Type.BLOCK_FOLDED || type === Type.BLOCK_LITERAL)) {\n    // should not happen; blocks are not valid inside flow containers\n    type = Type.QUOTE_DOUBLE;\n  }\n\n  var res = _stringify(type);\n\n  if (res === null) {\n    res = _stringify(defaultType);\n    if (res === null) throw new Error(\"Unsupported default string type \".concat(defaultType));\n  }\n\n  return res;\n}\n\nfunction stringifyNumber(_ref) {\n  var format = _ref.format,\n      minFractionDigits = _ref.minFractionDigits,\n      tag = _ref.tag,\n      value = _ref.value;\n  if (typeof value === 'bigint') return String(value);\n  if (!isFinite(value)) return isNaN(value) ? '.nan' : value < 0 ? '-.inf' : '.inf';\n  var n = JSON.stringify(value);\n\n  if (!format && minFractionDigits && (!tag || tag === 'tag:yaml.org,2002:float') && /^\\d/.test(n)) {\n    var i = n.indexOf('.');\n\n    if (i < 0) {\n      i = n.length;\n      n += '.';\n    }\n\n    var d = minFractionDigits - (n.length - i - 1);\n\n    while (d-- > 0) {\n      n += '0';\n    }\n  }\n\n  return n;\n}\n\nfunction checkFlowCollectionEnd(errors, cst) {\n  var _char, name;\n\n  switch (cst.type) {\n    case Type.FLOW_MAP:\n      _char = '}';\n      name = 'flow map';\n      break;\n\n    case Type.FLOW_SEQ:\n      _char = ']';\n      name = 'flow sequence';\n      break;\n\n    default:\n      errors.push(new YAMLSemanticError(cst, 'Not a flow collection!?'));\n      return;\n  }\n\n  var lastItem;\n\n  for (var i = cst.items.length - 1; i >= 0; --i) {\n    var item = cst.items[i];\n\n    if (!item || item.type !== Type.COMMENT) {\n      lastItem = item;\n      break;\n    }\n  }\n\n  if (lastItem && lastItem[\"char\"] !== _char) {\n    var msg = \"Expected \".concat(name, \" to end with \").concat(_char);\n    var err;\n\n    if (typeof lastItem.offset === 'number') {\n      err = new YAMLSemanticError(cst, msg);\n      err.offset = lastItem.offset + 1;\n    } else {\n      err = new YAMLSemanticError(lastItem, msg);\n      if (lastItem.range && lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start;\n    }\n\n    errors.push(err);\n  }\n}\n\nfunction checkFlowCommentSpace(errors, comment) {\n  var prev = comment.context.src[comment.range.start - 1];\n\n  if (prev !== '\\n' && prev !== '\\t' && prev !== ' ') {\n    var msg = 'Comments must be separated from other tokens by white space characters';\n    errors.push(new YAMLSemanticError(comment, msg));\n  }\n}\n\nfunction getLongKeyError(source, key) {\n  var sk = String(key);\n  var k = sk.substr(0, 8) + '...' + sk.substr(-8);\n  return new YAMLSemanticError(source, \"The \\\"\".concat(k, \"\\\" key is too long\"));\n}\n\nfunction resolveComments(collection, comments) {\n  var _iterator = _createForOfIteratorHelper(comments),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _step.value,\n          afterKey = _step$value.afterKey,\n          before = _step$value.before,\n          comment = _step$value.comment;\n      var item = collection.items[before];\n\n      if (!item) {\n        if (comment !== undefined) {\n          if (collection.comment) collection.comment += '\\n' + comment;else collection.comment = comment;\n        }\n      } else {\n        if (afterKey && item.value) item = item.value;\n\n        if (comment === undefined) {\n          if (afterKey || !item.commentBefore) item.spaceBefore = true;\n        } else {\n          if (item.commentBefore) item.commentBefore += '\\n' + comment;else item.commentBefore = comment;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n} // on error, will return { str: string, errors: Error[] }\n\n\nfunction resolveString(doc, node) {\n  var res = node.strValue;\n  if (!res) return '';\n  if (typeof res === 'string') return res;\n  res.errors.forEach(function (error) {\n    if (!error.source) error.source = node;\n    doc.errors.push(error);\n  });\n  return res.str;\n}\n\nfunction resolveTagHandle(doc, node) {\n  var _node$tag = node.tag,\n      handle = _node$tag.handle,\n      suffix = _node$tag.suffix;\n  var prefix = doc.tagPrefixes.find(function (p) {\n    return p.handle === handle;\n  });\n\n  if (!prefix) {\n    var dtp = doc.getDefaults().tagPrefixes;\n    if (dtp) prefix = dtp.find(function (p) {\n      return p.handle === handle;\n    });\n    if (!prefix) throw new YAMLSemanticError(node, \"The \".concat(handle, \" tag handle is non-default and was not declared.\"));\n  }\n\n  if (!suffix) throw new YAMLSemanticError(node, \"The \".concat(handle, \" tag has no suffix.\"));\n\n  if (handle === '!' && (doc.version || doc.options.version) === '1.0') {\n    if (suffix[0] === '^') {\n      doc.warnings.push(new YAMLWarning(node, 'YAML 1.0 ^ tag expansion is not supported'));\n      return suffix;\n    }\n\n    if (/[:/]/.test(suffix)) {\n      // word/foo -> tag:word.yaml.org,2002:foo\n      var vocab = suffix.match(/^([a-z0-9-]+)\\/(.*)/i);\n      return vocab ? \"tag:\".concat(vocab[1], \".yaml.org,2002:\").concat(vocab[2]) : \"tag:\".concat(suffix);\n    }\n  }\n\n  return prefix.prefix + decodeURIComponent(suffix);\n}\n\nfunction resolveTagName(doc, node) {\n  var tag = node.tag,\n      type = node.type;\n  var nonSpecific = false;\n\n  if (tag) {\n    var handle = tag.handle,\n        suffix = tag.suffix,\n        verbatim = tag.verbatim;\n\n    if (verbatim) {\n      if (verbatim !== '!' && verbatim !== '!!') return verbatim;\n      var msg = \"Verbatim tags aren't resolved, so \".concat(verbatim, \" is invalid.\");\n      doc.errors.push(new YAMLSemanticError(node, msg));\n    } else if (handle === '!' && !suffix) {\n      nonSpecific = true;\n    } else {\n      try {\n        return resolveTagHandle(doc, node);\n      } catch (error) {\n        doc.errors.push(error);\n      }\n    }\n  }\n\n  switch (type) {\n    case Type.BLOCK_FOLDED:\n    case Type.BLOCK_LITERAL:\n    case Type.QUOTE_DOUBLE:\n    case Type.QUOTE_SINGLE:\n      return defaultTags.STR;\n\n    case Type.FLOW_MAP:\n    case Type.MAP:\n      return defaultTags.MAP;\n\n    case Type.FLOW_SEQ:\n    case Type.SEQ:\n      return defaultTags.SEQ;\n\n    case Type.PLAIN:\n      return nonSpecific ? defaultTags.STR : null;\n\n    default:\n      return null;\n  }\n}\n\nfunction resolveByTagName(doc, node, tagName) {\n  var tags = doc.schema.tags;\n  var matchWithTest = [];\n\n  var _iterator = _createForOfIteratorHelper(tags),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var tag = _step.value;\n\n      if (tag.tag === tagName) {\n        if (tag.test) matchWithTest.push(tag);else {\n          var res = tag.resolve(doc, node);\n          return res instanceof resolveSeq_04825f30_Collection ? res : new Scalar(res);\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var str = resolveString(doc, node);\n  if (typeof str === 'string' && matchWithTest.length > 0) return resolveScalar(str, matchWithTest, tags.scalarFallback);\n  return null;\n}\n\nfunction getFallbackTagName(_ref) {\n  var type = _ref.type;\n\n  switch (type) {\n    case Type.FLOW_MAP:\n    case Type.MAP:\n      return defaultTags.MAP;\n\n    case Type.FLOW_SEQ:\n    case Type.SEQ:\n      return defaultTags.SEQ;\n\n    default:\n      return defaultTags.STR;\n  }\n}\n\nfunction resolveTag(doc, node, tagName) {\n  try {\n    var res = resolveByTagName(doc, node, tagName);\n\n    if (res) {\n      if (tagName && node.tag) res.tag = tagName;\n      return res;\n    }\n  } catch (error) {\n    /* istanbul ignore if */\n    if (!error.source) error.source = node;\n    doc.errors.push(error);\n    return null;\n  }\n\n  try {\n    var fallback = getFallbackTagName(node);\n    if (!fallback) throw new Error(\"The tag \".concat(tagName, \" is unavailable\"));\n    var msg = \"The tag \".concat(tagName, \" is unavailable, falling back to \").concat(fallback);\n    doc.warnings.push(new YAMLWarning(node, msg));\n\n    var _res = resolveByTagName(doc, node, fallback);\n\n    _res.tag = tagName;\n    return _res;\n  } catch (error) {\n    var refError = new YAMLReferenceError(node, error.message);\n    refError.stack = error.stack;\n    doc.errors.push(refError);\n    return null;\n  }\n}\n\nvar isCollectionItem = function isCollectionItem(node) {\n  if (!node) return false;\n  var type = node.type;\n  return type === Type.MAP_KEY || type === Type.MAP_VALUE || type === Type.SEQ_ITEM;\n};\n\nfunction resolveNodeProps(errors, node) {\n  var comments = {\n    before: [],\n    after: []\n  };\n  var hasAnchor = false;\n  var hasTag = false;\n  var props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;\n\n  var _iterator = _createForOfIteratorHelper(props),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _step.value,\n          start = _step$value.start,\n          end = _step$value.end;\n\n      switch (node.context.src[start]) {\n        case Char.COMMENT:\n          {\n            if (!node.commentHasRequiredWhitespace(start)) {\n              var msg = 'Comments must be separated from other tokens by white space characters';\n              errors.push(new YAMLSemanticError(node, msg));\n            }\n\n            var header = node.header,\n                valueRange = node.valueRange;\n            var cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;\n            cc.push(node.context.src.slice(start + 1, end));\n            break;\n          }\n        // Actual anchor & tag resolution is handled by schema, here we just complain\n\n        case Char.ANCHOR:\n          if (hasAnchor) {\n            var _msg = 'A node can have at most one anchor';\n            errors.push(new YAMLSemanticError(node, _msg));\n          }\n\n          hasAnchor = true;\n          break;\n\n        case Char.TAG:\n          if (hasTag) {\n            var _msg2 = 'A node can have at most one tag';\n            errors.push(new YAMLSemanticError(node, _msg2));\n          }\n\n          hasTag = true;\n          break;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return {\n    comments: comments,\n    hasAnchor: hasAnchor,\n    hasTag: hasTag\n  };\n}\n\nfunction resolveNodeValue(doc, node) {\n  var anchors = doc.anchors,\n      errors = doc.errors,\n      schema = doc.schema;\n\n  if (node.type === Type.ALIAS) {\n    var name = node.rawValue;\n    var src = anchors.getNode(name);\n\n    if (!src) {\n      var msg = \"Aliased anchor not found: \".concat(name);\n      errors.push(new YAMLReferenceError(node, msg));\n      return null;\n    } // Lazy resolution for circular references\n\n\n    var res = new resolveSeq_04825f30_Alias(src);\n\n    anchors._cstAliases.push(res);\n\n    return res;\n  }\n\n  var tagName = resolveTagName(doc, node);\n  if (tagName) return resolveTag(doc, node, tagName);\n\n  if (node.type !== Type.PLAIN) {\n    var _msg3 = \"Failed to resolve \".concat(node.type, \" node here\");\n\n    errors.push(new YAMLSyntaxError(node, _msg3));\n    return null;\n  }\n\n  try {\n    var str = resolveString(doc, node);\n    return resolveScalar(str, schema.tags, schema.tags.scalarFallback);\n  } catch (error) {\n    if (!error.source) error.source = node;\n    errors.push(error);\n    return null;\n  }\n} // sets node.resolved on success\n\n\nfunction resolveNode(doc, node) {\n  if (!node) return null;\n  if (node.error) doc.errors.push(node.error);\n\n  var _resolveNodeProps = resolveNodeProps(doc.errors, node),\n      comments = _resolveNodeProps.comments,\n      hasAnchor = _resolveNodeProps.hasAnchor,\n      hasTag = _resolveNodeProps.hasTag;\n\n  if (hasAnchor) {\n    var anchors = doc.anchors;\n    var name = node.anchor;\n    var prev = anchors.getNode(name); // At this point, aliases for any preceding node with the same anchor\n    // name have already been resolved, so it may safely be renamed.\n\n    if (prev) anchors.map[anchors.newName(name)] = prev; // During parsing, we need to store the CST node in anchors.map as\n    // anchors need to be available during resolution to allow for\n    // circular references.\n\n    anchors.map[name] = node;\n  }\n\n  if (node.type === Type.ALIAS && (hasAnchor || hasTag)) {\n    var msg = 'An alias node must not specify any properties';\n    doc.errors.push(new YAMLSemanticError(node, msg));\n  }\n\n  var res = resolveNodeValue(doc, node);\n\n  if (res) {\n    res.range = [node.range.start, node.range.end];\n    if (doc.options.keepCstNodes) res.cstNode = node;\n    if (doc.options.keepNodeTypes) res.type = node.type;\n    var cb = comments.before.join('\\n');\n\n    if (cb) {\n      res.commentBefore = res.commentBefore ? \"\".concat(res.commentBefore, \"\\n\").concat(cb) : cb;\n    }\n\n    var ca = comments.after.join('\\n');\n    if (ca) res.comment = res.comment ? \"\".concat(res.comment, \"\\n\").concat(ca) : ca;\n  }\n\n  return node.resolved = res;\n}\n\nfunction resolveMap(doc, cst) {\n  if (cst.type !== Type.MAP && cst.type !== Type.FLOW_MAP) {\n    var msg = \"A \".concat(cst.type, \" node cannot be resolved as a mapping\");\n    doc.errors.push(new YAMLSyntaxError(cst, msg));\n    return null;\n  }\n\n  var _ref = cst.type === Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst),\n      comments = _ref.comments,\n      items = _ref.items;\n\n  var map = new YAMLMap();\n  map.items = items;\n  resolveComments(map, comments);\n  var hasCollectionKey = false;\n\n  for (var i = 0; i < items.length; ++i) {\n    var iKey = items[i].key;\n    if (iKey instanceof resolveSeq_04825f30_Collection) hasCollectionKey = true;\n\n    if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {\n      items[i] = new Merge(items[i]);\n      var sources = items[i].value.items;\n      var error = null;\n      sources.some(function (node) {\n        if (node instanceof resolveSeq_04825f30_Alias) {\n          // During parsing, alias sources are CST nodes; to account for\n          // circular references their resolved values can't be used here.\n          var type = node.source.type;\n          if (type === Type.MAP || type === Type.FLOW_MAP) return false;\n          return error = 'Merge nodes aliases can only point to maps';\n        }\n\n        return error = 'Merge nodes can only have Alias nodes as values';\n      });\n      if (error) doc.errors.push(new YAMLSemanticError(cst, error));\n    } else {\n      for (var j = i + 1; j < items.length; ++j) {\n        var jKey = items[j].key;\n\n        if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, 'value') && iKey.value === jKey.value) {\n          var _msg = \"Map keys must be unique; \\\"\".concat(iKey, \"\\\" is repeated\");\n\n          doc.errors.push(new YAMLSemanticError(cst, _msg));\n          break;\n        }\n      }\n    }\n  }\n\n  if (hasCollectionKey && !doc.options.mapAsMap) {\n    var warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';\n    doc.warnings.push(new YAMLWarning(cst, warn));\n  }\n\n  cst.resolved = map;\n  return map;\n}\n\nvar valueHasPairComment = function valueHasPairComment(_ref2) {\n  var _ref2$context = _ref2.context,\n      lineStart = _ref2$context.lineStart,\n      node = _ref2$context.node,\n      src = _ref2$context.src,\n      props = _ref2.props;\n  if (props.length === 0) return false;\n  var start = props[0].start;\n  if (node && start > node.valueRange.start) return false;\n  if (src[start] !== Char.COMMENT) return false;\n\n  for (var i = lineStart; i < start; ++i) {\n    if (src[i] === '\\n') return false;\n  }\n\n  return true;\n};\n\nfunction resolvePairComment(item, pair) {\n  if (!valueHasPairComment(item)) return;\n  var comment = item.getPropValue(0, Char.COMMENT, true);\n  var found = false;\n  var cb = pair.value.commentBefore;\n\n  if (cb && cb.startsWith(comment)) {\n    pair.value.commentBefore = cb.substr(comment.length + 1);\n    found = true;\n  } else {\n    var cc = pair.value.comment;\n\n    if (!item.node && cc && cc.startsWith(comment)) {\n      pair.value.comment = cc.substr(comment.length + 1);\n      found = true;\n    }\n  }\n\n  if (found) pair.comment = comment;\n}\n\nfunction resolveBlockMapItems(doc, cst) {\n  var comments = [];\n  var items = [];\n  var key = undefined;\n  var keyStart = null;\n\n  for (var i = 0; i < cst.items.length; ++i) {\n    var item = cst.items[i];\n\n    switch (item.type) {\n      case Type.BLANK_LINE:\n        comments.push({\n          afterKey: !!key,\n          before: items.length\n        });\n        break;\n\n      case Type.COMMENT:\n        comments.push({\n          afterKey: !!key,\n          before: items.length,\n          comment: item.comment\n        });\n        break;\n\n      case Type.MAP_KEY:\n        if (key !== undefined) items.push(new Pair(key));\n        if (item.error) doc.errors.push(item.error);\n        key = resolveNode(doc, item.node);\n        keyStart = null;\n        break;\n\n      case Type.MAP_VALUE:\n        {\n          if (key === undefined) key = null;\n          if (item.error) doc.errors.push(item.error);\n\n          if (!item.context.atLineStart && item.node && item.node.type === Type.MAP && !item.node.context.atLineStart) {\n            var msg = 'Nested mappings are not allowed in compact mappings';\n            doc.errors.push(new YAMLSemanticError(item.node, msg));\n          }\n\n          var valueNode = item.node;\n\n          if (!valueNode && item.props.length > 0) {\n            // Comments on an empty mapping value need to be preserved, so we\n            // need to construct a minimal empty node here to use instead of the\n            // missing `item.node`. -- eemeli/yaml#19\n            valueNode = new PlainValue(Type.PLAIN, []);\n            valueNode.context = {\n              parent: item,\n              src: item.context.src\n            };\n            var pos = item.range.start + 1;\n            valueNode.range = {\n              start: pos,\n              end: pos\n            };\n            valueNode.valueRange = {\n              start: pos,\n              end: pos\n            };\n\n            if (typeof item.range.origStart === 'number') {\n              var origPos = item.range.origStart + 1;\n              valueNode.range.origStart = valueNode.range.origEnd = origPos;\n              valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;\n            }\n          }\n\n          var pair = new Pair(key, resolveNode(doc, valueNode));\n          resolvePairComment(item, pair);\n          items.push(pair);\n\n          if (key && typeof keyStart === 'number') {\n            if (item.range.start > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n          }\n\n          key = undefined;\n          keyStart = null;\n        }\n        break;\n\n      default:\n        if (key !== undefined) items.push(new Pair(key));\n        key = resolveNode(doc, item);\n        keyStart = item.range.start;\n        if (item.error) doc.errors.push(item.error);\n\n        next: for (var j = i + 1;; ++j) {\n          var nextItem = cst.items[j];\n\n          switch (nextItem && nextItem.type) {\n            case Type.BLANK_LINE:\n            case Type.COMMENT:\n              continue next;\n\n            case Type.MAP_VALUE:\n              break next;\n\n            default:\n              {\n                var _msg2 = 'Implicit map keys need to be followed by map values';\n                doc.errors.push(new YAMLSemanticError(item, _msg2));\n                break next;\n              }\n          }\n        }\n\n        if (item.valueRangeContainsNewline) {\n          var _msg3 = 'Implicit map keys need to be on a single line';\n          doc.errors.push(new YAMLSemanticError(item, _msg3));\n        }\n\n    }\n  }\n\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments: comments,\n    items: items\n  };\n}\n\nfunction resolveFlowMapItems(doc, cst) {\n  var comments = [];\n  var items = [];\n  var key = undefined;\n  var explicitKey = false;\n  var next = '{';\n\n  for (var i = 0; i < cst.items.length; ++i) {\n    var item = cst.items[i];\n\n    if (typeof item[\"char\"] === 'string') {\n      var _char2 = item[\"char\"],\n          offset = item.offset;\n\n      if (_char2 === '?' && key === undefined && !explicitKey) {\n        explicitKey = true;\n        next = ':';\n        continue;\n      }\n\n      if (_char2 === ':') {\n        if (key === undefined) key = null;\n\n        if (next === ':') {\n          next = ',';\n          continue;\n        }\n      } else {\n        if (explicitKey) {\n          if (key === undefined && _char2 !== ',') key = null;\n          explicitKey = false;\n        }\n\n        if (key !== undefined) {\n          items.push(new Pair(key));\n          key = undefined;\n\n          if (_char2 === ',') {\n            next = ':';\n            continue;\n          }\n        }\n      }\n\n      if (_char2 === '}') {\n        if (i === cst.items.length - 1) continue;\n      } else if (_char2 === next) {\n        next = ':';\n        continue;\n      }\n\n      var msg = \"Flow map contains an unexpected \".concat(_char2);\n      var err = new YAMLSyntaxError(cst, msg);\n      err.offset = offset;\n      doc.errors.push(err);\n    } else if (item.type === Type.BLANK_LINE) {\n      comments.push({\n        afterKey: !!key,\n        before: items.length\n      });\n    } else if (item.type === Type.COMMENT) {\n      checkFlowCommentSpace(doc.errors, item);\n      comments.push({\n        afterKey: !!key,\n        before: items.length,\n        comment: item.comment\n      });\n    } else if (key === undefined) {\n      if (next === ',') doc.errors.push(new YAMLSemanticError(item, 'Separator , missing in flow map'));\n      key = resolveNode(doc, item);\n    } else {\n      if (next !== ',') doc.errors.push(new YAMLSemanticError(item, 'Indicator : missing in flow map entry'));\n      items.push(new Pair(key, resolveNode(doc, item)));\n      key = undefined;\n      explicitKey = false;\n    }\n  }\n\n  checkFlowCollectionEnd(doc.errors, cst);\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments: comments,\n    items: items\n  };\n}\n\nfunction resolveSeq(doc, cst) {\n  if (cst.type !== Type.SEQ && cst.type !== Type.FLOW_SEQ) {\n    var msg = \"A \".concat(cst.type, \" node cannot be resolved as a sequence\");\n    doc.errors.push(new YAMLSyntaxError(cst, msg));\n    return null;\n  }\n\n  var _ref = cst.type === Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst),\n      comments = _ref.comments,\n      items = _ref.items;\n\n  var seq = new YAMLSeq();\n  seq.items = items;\n  resolveComments(seq, comments);\n\n  if (!doc.options.mapAsMap && items.some(function (it) {\n    return it instanceof Pair && it.key instanceof resolveSeq_04825f30_Collection;\n  })) {\n    var warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';\n    doc.warnings.push(new YAMLWarning(cst, warn));\n  }\n\n  cst.resolved = seq;\n  return seq;\n}\n\nfunction resolveBlockSeqItems(doc, cst) {\n  var comments = [];\n  var items = [];\n\n  for (var i = 0; i < cst.items.length; ++i) {\n    var item = cst.items[i];\n\n    switch (item.type) {\n      case Type.BLANK_LINE:\n        comments.push({\n          before: items.length\n        });\n        break;\n\n      case Type.COMMENT:\n        comments.push({\n          comment: item.comment,\n          before: items.length\n        });\n        break;\n\n      case Type.SEQ_ITEM:\n        if (item.error) doc.errors.push(item.error);\n        items.push(resolveNode(doc, item.node));\n\n        if (item.hasProps) {\n          var msg = 'Sequence items cannot have tags or anchors before the - indicator';\n          doc.errors.push(new YAMLSemanticError(item, msg));\n        }\n\n        break;\n\n      default:\n        if (item.error) doc.errors.push(item.error);\n        doc.errors.push(new YAMLSyntaxError(item, \"Unexpected \".concat(item.type, \" node in sequence\")));\n    }\n  }\n\n  return {\n    comments: comments,\n    items: items\n  };\n}\n\nfunction resolveFlowSeqItems(doc, cst) {\n  var comments = [];\n  var items = [];\n  var explicitKey = false;\n  var key = undefined;\n  var keyStart = null;\n  var next = '[';\n  var prevItem = null;\n\n  for (var i = 0; i < cst.items.length; ++i) {\n    var item = cst.items[i];\n\n    if (typeof item[\"char\"] === 'string') {\n      var _char3 = item[\"char\"],\n          offset = item.offset;\n\n      if (_char3 !== ':' && (explicitKey || key !== undefined)) {\n        if (explicitKey && key === undefined) key = next ? items.pop() : null;\n        items.push(new Pair(key));\n        explicitKey = false;\n        key = undefined;\n        keyStart = null;\n      }\n\n      if (_char3 === next) {\n        next = null;\n      } else if (!next && _char3 === '?') {\n        explicitKey = true;\n      } else if (next !== '[' && _char3 === ':' && key === undefined) {\n        if (next === ',') {\n          key = items.pop();\n\n          if (key instanceof Pair) {\n            var msg = 'Chaining flow sequence pairs is invalid';\n            var err = new YAMLSemanticError(cst, msg);\n            err.offset = offset;\n            doc.errors.push(err);\n          }\n\n          if (!explicitKey && typeof keyStart === 'number') {\n            var keyEnd = item.range ? item.range.start : item.offset;\n            if (keyEnd > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n            var src = prevItem.context.src;\n\n            for (var _i = keyStart; _i < keyEnd; ++_i) {\n              if (src[_i] === '\\n') {\n                var _msg = 'Implicit keys of flow sequence pairs need to be on a single line';\n                doc.errors.push(new YAMLSemanticError(prevItem, _msg));\n                break;\n              }\n            }\n          }\n        } else {\n          key = null;\n        }\n\n        keyStart = null;\n        explicitKey = false;\n        next = null;\n      } else if (next === '[' || _char3 !== ']' || i < cst.items.length - 1) {\n        var _msg2 = \"Flow sequence contains an unexpected \".concat(_char3);\n\n        var _err = new YAMLSyntaxError(cst, _msg2);\n\n        _err.offset = offset;\n        doc.errors.push(_err);\n      }\n    } else if (item.type === Type.BLANK_LINE) {\n      comments.push({\n        before: items.length\n      });\n    } else if (item.type === Type.COMMENT) {\n      checkFlowCommentSpace(doc.errors, item);\n      comments.push({\n        comment: item.comment,\n        before: items.length\n      });\n    } else {\n      if (next) {\n        var _msg3 = \"Expected a \".concat(next, \" in flow sequence\");\n\n        doc.errors.push(new YAMLSemanticError(item, _msg3));\n      }\n\n      var value = resolveNode(doc, item);\n\n      if (key === undefined) {\n        items.push(value);\n        prevItem = item;\n      } else {\n        items.push(new Pair(key, value));\n        key = undefined;\n      }\n\n      keyStart = item.range.start;\n      next = ',';\n    }\n  }\n\n  checkFlowCollectionEnd(doc.errors, cst);\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments: comments,\n    items: items\n  };\n}\n\n\n;// CONCATENATED MODULE: ./node_modules/yaml/browser/dist/warnings-0e4b70d3.js\n/* provided dependency */ var Buffer = __webpack_require__(48764)[\"Buffer\"];\n/* provided dependency */ var process = __webpack_require__(34155);\n\n\n/* global atob, btoa, Buffer */\n\nvar binary = {\n  identify: function identify(value) {\n    return value instanceof Uint8Array;\n  },\n  // Buffer inherits from Uint8Array\n  \"default\": false,\n  tag: 'tag:yaml.org,2002:binary',\n\n  /**\n   * Returns a Buffer in node and an Uint8Array in browsers\n   *\n   * To use the resulting buffer as an image, you'll want to do something like:\n   *\n   *   const blob = new Blob([buffer], { type: 'image/jpeg' })\n   *   document.querySelector('#photo').src = URL.createObjectURL(blob)\n   */\n  resolve: function resolve(doc, node) {\n    var src = resolveString(doc, node);\n\n    if (typeof Buffer === 'function') {\n      return Buffer.from(src, 'base64');\n    } else if (typeof atob === 'function') {\n      // On IE 11, atob() can't handle newlines\n      var str = atob(src.replace(/[\\n\\r]/g, ''));\n      var buffer = new Uint8Array(str.length);\n\n      for (var i = 0; i < str.length; ++i) {\n        buffer[i] = str.charCodeAt(i);\n      }\n\n      return buffer;\n    } else {\n      var msg = 'This environment does not support reading binary tags; either Buffer or atob is required';\n      doc.errors.push(new YAMLReferenceError(node, msg));\n      return null;\n    }\n  },\n  options: binaryOptions,\n  stringify: function stringify(_ref, ctx, onComment, onChompKeep) {\n    var comment = _ref.comment,\n        type = _ref.type,\n        value = _ref.value;\n    var src;\n\n    if (typeof Buffer === 'function') {\n      src = value instanceof Buffer ? value.toString('base64') : Buffer.from(value.buffer).toString('base64');\n    } else if (typeof btoa === 'function') {\n      var s = '';\n\n      for (var i = 0; i < value.length; ++i) {\n        s += String.fromCharCode(value[i]);\n      }\n\n      src = btoa(s);\n    } else {\n      throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');\n    }\n\n    if (!type) type = binaryOptions.defaultType;\n\n    if (type === Type.QUOTE_DOUBLE) {\n      value = src;\n    } else {\n      var lineWidth = binaryOptions.lineWidth;\n      var n = Math.ceil(src.length / lineWidth);\n      var lines = new Array(n);\n\n      for (var _i = 0, o = 0; _i < n; ++_i, o += lineWidth) {\n        lines[_i] = src.substr(o, lineWidth);\n      }\n\n      value = lines.join(type === Type.BLOCK_LITERAL ? '\\n' : ' ');\n    }\n\n    return stringifyString({\n      comment: comment,\n      type: type,\n      value: value\n    }, ctx, onComment, onChompKeep);\n  }\n};\n\nfunction parsePairs(doc, cst) {\n  var seq = resolveSeq(doc, cst);\n\n  for (var i = 0; i < seq.items.length; ++i) {\n    var item = seq.items[i];\n    if (item instanceof Pair) continue;else if (item instanceof YAMLMap) {\n      if (item.items.length > 1) {\n        var msg = 'Each pair must have its own sequence indicator';\n        throw new YAMLSemanticError(cst, msg);\n      }\n\n      var pair = item.items[0] || new Pair();\n      if (item.commentBefore) pair.commentBefore = pair.commentBefore ? \"\".concat(item.commentBefore, \"\\n\").concat(pair.commentBefore) : item.commentBefore;\n      if (item.comment) pair.comment = pair.comment ? \"\".concat(item.comment, \"\\n\").concat(pair.comment) : item.comment;\n      item = pair;\n    }\n    seq.items[i] = item instanceof Pair ? item : new Pair(item);\n  }\n\n  return seq;\n}\n\nfunction createPairs(schema, iterable, ctx) {\n  var pairs = new YAMLSeq(schema);\n  pairs.tag = 'tag:yaml.org,2002:pairs';\n\n  var _iterator = _createForOfIteratorHelper(iterable),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var it = _step.value;\n      var key = void 0,\n          value = void 0;\n\n      if (Array.isArray(it)) {\n        if (it.length === 2) {\n          key = it[0];\n          value = it[1];\n        } else throw new TypeError(\"Expected [key, value] tuple: \".concat(it));\n      } else if (it && it instanceof Object) {\n        var keys = Object.keys(it);\n\n        if (keys.length === 1) {\n          key = keys[0];\n          value = it[key];\n        } else throw new TypeError(\"Expected { key: value } tuple: \".concat(it));\n      } else {\n        key = it;\n      }\n\n      var pair = schema.createPair(key, value, ctx);\n      pairs.items.push(pair);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return pairs;\n}\n\nvar pairs = {\n  \"default\": false,\n  tag: 'tag:yaml.org,2002:pairs',\n  resolve: parsePairs,\n  createNode: createPairs\n};\n\nvar YAMLOMap = /*#__PURE__*/function (_YAMLSeq) {\n  _inherits(YAMLOMap, _YAMLSeq);\n\n  var _super = _createSuper(YAMLOMap);\n\n  function YAMLOMap() {\n    var _this;\n\n    _classCallCheck(this, YAMLOMap);\n\n    _this = _super.call(this);\n\n    _defineProperty(_assertThisInitialized(_this), \"add\", YAMLMap.prototype.add.bind(_assertThisInitialized(_this)));\n\n    _defineProperty(_assertThisInitialized(_this), \"delete\", YAMLMap.prototype.delete.bind(_assertThisInitialized(_this)));\n\n    _defineProperty(_assertThisInitialized(_this), \"get\", YAMLMap.prototype.get.bind(_assertThisInitialized(_this)));\n\n    _defineProperty(_assertThisInitialized(_this), \"has\", YAMLMap.prototype.has.bind(_assertThisInitialized(_this)));\n\n    _defineProperty(_assertThisInitialized(_this), \"set\", YAMLMap.prototype.set.bind(_assertThisInitialized(_this)));\n\n    _this.tag = YAMLOMap.tag;\n    return _this;\n  }\n\n  _createClass(YAMLOMap, [{\n    key: \"toJSON\",\n    value: function toJSON$1(_, ctx) {\n      var map = new Map();\n      if (ctx && ctx.onCreate) ctx.onCreate(map);\n\n      var _iterator = _createForOfIteratorHelper(this.items),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var pair = _step.value;\n          var key = void 0,\n              value = void 0;\n\n          if (pair instanceof Pair) {\n            key = toJSON(pair.key, '', ctx);\n            value = toJSON(pair.value, key, ctx);\n          } else {\n            key = toJSON(pair, '', ctx);\n          }\n\n          if (map.has(key)) throw new Error('Ordered maps must not include duplicate keys');\n          map.set(key, value);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return map;\n    }\n  }]);\n\n  return YAMLOMap;\n}(YAMLSeq);\n\n_defineProperty(YAMLOMap, \"tag\", 'tag:yaml.org,2002:omap');\n\nfunction parseOMap(doc, cst) {\n  var pairs = parsePairs(doc, cst);\n  var seenKeys = [];\n\n  var _iterator2 = _createForOfIteratorHelper(pairs.items),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var key = _step2.value.key;\n\n      if (key instanceof Scalar) {\n        if (seenKeys.includes(key.value)) {\n          var msg = 'Ordered maps must not include duplicate keys';\n          throw new YAMLSemanticError(cst, msg);\n        } else {\n          seenKeys.push(key.value);\n        }\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return Object.assign(new YAMLOMap(), pairs);\n}\n\nfunction createOMap(schema, iterable, ctx) {\n  var pairs = createPairs(schema, iterable, ctx);\n  var omap = new YAMLOMap();\n  omap.items = pairs.items;\n  return omap;\n}\n\nvar omap = {\n  identify: function identify(value) {\n    return value instanceof Map;\n  },\n  nodeClass: YAMLOMap,\n  \"default\": false,\n  tag: 'tag:yaml.org,2002:omap',\n  resolve: parseOMap,\n  createNode: createOMap\n};\n\nvar YAMLSet = /*#__PURE__*/function (_YAMLMap) {\n  _inherits(YAMLSet, _YAMLMap);\n\n  var _super = _createSuper(YAMLSet);\n\n  function YAMLSet() {\n    var _this;\n\n    _classCallCheck(this, YAMLSet);\n\n    _this = _super.call(this);\n    _this.tag = YAMLSet.tag;\n    return _this;\n  }\n\n  _createClass(YAMLSet, [{\n    key: \"add\",\n    value: function add(key) {\n      var pair = key instanceof Pair ? key : new Pair(key);\n      var prev = findPair(this.items, pair.key);\n      if (!prev) this.items.push(pair);\n    }\n  }, {\n    key: \"get\",\n    value: function get(key, keepPair) {\n      var pair = findPair(this.items, key);\n      return !keepPair && pair instanceof Pair ? pair.key instanceof Scalar ? pair.key.value : pair.key : pair;\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      if (typeof value !== 'boolean') throw new Error(\"Expected boolean value for set(key, value) in a YAML set, not \".concat(_typeof(value)));\n      var prev = findPair(this.items, key);\n\n      if (prev && !value) {\n        this.items.splice(this.items.indexOf(prev), 1);\n      } else if (!prev && value) {\n        this.items.push(new Pair(key));\n      }\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(_, ctx) {\n      return _get(_getPrototypeOf(YAMLSet.prototype), \"toJSON\", this).call(this, _, ctx, Set);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(ctx, onComment, onChompKeep) {\n      if (!ctx) return JSON.stringify(this);\n      if (this.hasAllNullValues()) return _get(_getPrototypeOf(YAMLSet.prototype), \"toString\", this).call(this, ctx, onComment, onChompKeep);else throw new Error('Set items must all have null values');\n    }\n  }]);\n\n  return YAMLSet;\n}(YAMLMap);\n\n_defineProperty(YAMLSet, \"tag\", 'tag:yaml.org,2002:set');\n\nfunction parseSet(doc, cst) {\n  var map = resolveMap(doc, cst);\n  if (!map.hasAllNullValues()) throw new YAMLSemanticError(cst, 'Set items must all have null values');\n  return Object.assign(new YAMLSet(), map);\n}\n\nfunction createSet(schema, iterable, ctx) {\n  var set = new YAMLSet();\n\n  var _iterator = _createForOfIteratorHelper(iterable),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var value = _step.value;\n      set.items.push(schema.createPair(value, null, ctx));\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return set;\n}\n\nvar set = {\n  identify: function identify(value) {\n    return value instanceof Set;\n  },\n  nodeClass: YAMLSet,\n  \"default\": false,\n  tag: 'tag:yaml.org,2002:set',\n  resolve: parseSet,\n  createNode: createSet\n};\n\nvar parseSexagesimal = function parseSexagesimal(sign, parts) {\n  var n = parts.split(':').reduce(function (n, p) {\n    return n * 60 + Number(p);\n  }, 0);\n  return sign === '-' ? -n : n;\n}; // hhhh:mm:ss.sss\n\n\nvar stringifySexagesimal = function stringifySexagesimal(_ref) {\n  var value = _ref.value;\n  if (isNaN(value) || !isFinite(value)) return stringifyNumber(value);\n  var sign = '';\n\n  if (value < 0) {\n    sign = '-';\n    value = Math.abs(value);\n  }\n\n  var parts = [value % 60]; // seconds, including ms\n\n  if (value < 60) {\n    parts.unshift(0); // at least one : is required\n  } else {\n    value = Math.round((value - parts[0]) / 60);\n    parts.unshift(value % 60); // minutes\n\n    if (value >= 60) {\n      value = Math.round((value - parts[0]) / 60);\n      parts.unshift(value); // hours\n    }\n  }\n\n  return sign + parts.map(function (n) {\n    return n < 10 ? '0' + String(n) : String(n);\n  }).join(':').replace(/000000\\d*$/, '') // % 60 may introduce error\n  ;\n};\n\nvar intTime = {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  \"default\": true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'TIME',\n  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,\n  resolve: function resolve(str, sign, parts) {\n    return parseSexagesimal(sign, parts.replace(/_/g, ''));\n  },\n  stringify: stringifySexagesimal\n};\nvar floatTime = {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  \"default\": true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'TIME',\n  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*)$/,\n  resolve: function resolve(str, sign, parts) {\n    return parseSexagesimal(sign, parts.replace(/_/g, ''));\n  },\n  stringify: stringifySexagesimal\n};\nvar timestamp = {\n  identify: function identify(value) {\n    return value instanceof Date;\n  },\n  \"default\": true,\n  tag: 'tag:yaml.org,2002:timestamp',\n  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part\n  // may be omitted altogether, resulting in a date format. In such a case, the time part is\n  // assumed to be 00:00:00Z (start of day, UTC).\n  test: RegExp('^(?:' + '([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd\n  '(?:(?:t|T|[ \\\\t]+)' + // t | T | whitespace\n  '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?\n  '(?:[ \\\\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30\n  ')?' + ')$'),\n  resolve: function resolve(str, year, month, day, hour, minute, second, millisec, tz) {\n    if (millisec) millisec = (millisec + '00').substr(1, 3);\n    var date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);\n\n    if (tz && tz !== 'Z') {\n      var d = parseSexagesimal(tz[0], tz.slice(1));\n      if (Math.abs(d) < 30) d *= 60;\n      date -= 60000 * d;\n    }\n\n    return new Date(date);\n  },\n  stringify: function stringify(_ref2) {\n    var value = _ref2.value;\n    return value.toISOString().replace(/((T00:00)?:00)?\\.000Z$/, '');\n  }\n};\n/* global console, process, YAML_SILENCE_DEPRECATION_WARNINGS, YAML_SILENCE_WARNINGS */\n\nfunction shouldWarn(deprecation) {\n  var env = typeof process !== 'undefined' && process.env || {};\n\n  if (deprecation) {\n    if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== 'undefined') return !YAML_SILENCE_DEPRECATION_WARNINGS;\n    return !env.YAML_SILENCE_DEPRECATION_WARNINGS;\n  }\n\n  if (typeof YAML_SILENCE_WARNINGS !== 'undefined') return !YAML_SILENCE_WARNINGS;\n  return !env.YAML_SILENCE_WARNINGS;\n}\n\nfunction warn(warning, type) {\n  if (shouldWarn(false)) {\n    var emit = typeof process !== 'undefined' && process.emitWarning; // This will throw in Jest if `warning` is an Error instance due to\n    // https://github.com/facebook/jest/issues/2549\n\n    if (emit) emit(warning, type);else {\n      // eslint-disable-next-line no-console\n      console.warn(type ? \"\".concat(type, \": \").concat(warning) : warning);\n    }\n  }\n}\n\nfunction warnFileDeprecation(filename) {\n  if (shouldWarn(true)) {\n    var path = filename.replace(/.*yaml[/\\\\]/i, '').replace(/\\.js$/, '').replace(/\\\\/g, '/');\n    warn(\"The endpoint 'yaml/\".concat(path, \"' will be removed in a future release.\"), 'DeprecationWarning');\n  }\n}\n\nvar warned = {};\n\nfunction warnOptionDeprecation(name, alternative) {\n  if (!warned[name] && shouldWarn(true)) {\n    warned[name] = true;\n    var msg = \"The option '\".concat(name, \"' will be removed in a future release\");\n    msg += alternative ? \", use '\".concat(alternative, \"' instead.\") : '.';\n    warn(msg, 'DeprecationWarning');\n  }\n}\n\n\n;// CONCATENATED MODULE: ./node_modules/yaml/browser/dist/Schema-2bf2c74e.js\n\n\n\n\nfunction createMap(schema, obj, ctx) {\n  var map = new YAMLMap(schema);\n\n  if (obj instanceof Map) {\n    var _iterator = _createForOfIteratorHelper(obj),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = _slicedToArray(_step.value, 2),\n            key = _step$value[0],\n            value = _step$value[1];\n\n        map.items.push(schema.createPair(key, value, ctx));\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  } else if (obj && _typeof(obj) === 'object') {\n    for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {\n      var _key = _Object$keys[_i];\n      map.items.push(schema.createPair(_key, obj[_key], ctx));\n    }\n  }\n\n  if (typeof schema.sortMapEntries === 'function') {\n    map.items.sort(schema.sortMapEntries);\n  }\n\n  return map;\n}\n\nvar map = {\n  createNode: createMap,\n  \"default\": true,\n  nodeClass: YAMLMap,\n  tag: 'tag:yaml.org,2002:map',\n  resolve: resolveMap\n};\n\nfunction createSeq(schema, obj, ctx) {\n  var seq = new YAMLSeq(schema);\n\n  if (obj && obj[Symbol.iterator]) {\n    var _iterator = _createForOfIteratorHelper(obj),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var it = _step.value;\n        var v = schema.createNode(it, ctx.wrapScalars, null, ctx);\n        seq.items.push(v);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  return seq;\n}\n\nvar seq = {\n  createNode: createSeq,\n  \"default\": true,\n  nodeClass: YAMLSeq,\n  tag: 'tag:yaml.org,2002:seq',\n  resolve: resolveSeq\n};\nvar string = {\n  identify: function identify(value) {\n    return typeof value === 'string';\n  },\n  \"default\": true,\n  tag: 'tag:yaml.org,2002:str',\n  resolve: resolveString,\n  stringify: function stringify(item, ctx, onComment, onChompKeep) {\n    ctx = Object.assign({\n      actualString: true\n    }, ctx);\n    return stringifyString(item, ctx, onComment, onChompKeep);\n  },\n  options: strOptions\n};\nvar failsafe = [map, seq, string];\n/* global BigInt */\n\nvar intIdentify = function intIdentify(value) {\n  return typeof value === 'bigint' || Number.isInteger(value);\n};\n\nvar intResolve = function intResolve(src, part, radix) {\n  return intOptions.asBigInt ? BigInt(src) : parseInt(part, radix);\n};\n\nfunction intStringify(node, radix, prefix) {\n  var value = node.value;\n  if (intIdentify(value) && value >= 0) return prefix + value.toString(radix);\n  return stringifyNumber(node);\n}\n\nvar nullObj = {\n  identify: function identify(value) {\n    return value == null;\n  },\n  createNode: function createNode(schema, value, ctx) {\n    return ctx.wrapScalars ? new Scalar(null) : null;\n  },\n  \"default\": true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^(?:~|[Nn]ull|NULL)?$/,\n  resolve: function resolve() {\n    return null;\n  },\n  options: nullOptions,\n  stringify: function stringify() {\n    return nullOptions.nullStr;\n  }\n};\nvar boolObj = {\n  identify: function identify(value) {\n    return typeof value === 'boolean';\n  },\n  \"default\": true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,\n  resolve: function resolve(str) {\n    return str[0] === 't' || str[0] === 'T';\n  },\n  options: boolOptions,\n  stringify: function stringify(_ref) {\n    var value = _ref.value;\n    return value ? boolOptions.trueStr : boolOptions.falseStr;\n  }\n};\nvar octObj = {\n  identify: function identify(value) {\n    return intIdentify(value) && value >= 0;\n  },\n  \"default\": true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'OCT',\n  test: /^0o([0-7]+)$/,\n  resolve: function resolve(str, oct) {\n    return intResolve(str, oct, 8);\n  },\n  options: intOptions,\n  stringify: function stringify(node) {\n    return intStringify(node, 8, '0o');\n  }\n};\nvar intObj = {\n  identify: intIdentify,\n  \"default\": true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^[-+]?[0-9]+$/,\n  resolve: function resolve(str) {\n    return intResolve(str, str, 10);\n  },\n  options: intOptions,\n  stringify: stringifyNumber\n};\nvar hexObj = {\n  identify: function identify(value) {\n    return intIdentify(value) && value >= 0;\n  },\n  \"default\": true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'HEX',\n  test: /^0x([0-9a-fA-F]+)$/,\n  resolve: function resolve(str, hex) {\n    return intResolve(str, hex, 16);\n  },\n  options: intOptions,\n  stringify: function stringify(node) {\n    return intStringify(node, 16, '0x');\n  }\n};\nvar nanObj = {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  \"default\": true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^(?:[-+]?\\.inf|(\\.nan))$/i,\n  resolve: function resolve(str, nan) {\n    return nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n  },\n  stringify: stringifyNumber\n};\nvar expObj = {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  \"default\": true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'EXP',\n  test: /^[-+]?(?:\\.[0-9]+|[0-9]+(?:\\.[0-9]*)?)[eE][-+]?[0-9]+$/,\n  resolve: function resolve(str) {\n    return parseFloat(str);\n  },\n  stringify: function stringify(_ref2) {\n    var value = _ref2.value;\n    return Number(value).toExponential();\n  }\n};\nvar floatObj = {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  \"default\": true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^[-+]?(?:\\.([0-9]+)|[0-9]+\\.([0-9]*))$/,\n  resolve: function resolve(str, frac1, frac2) {\n    var frac = frac1 || frac2;\n    var node = new Scalar(parseFloat(str));\n    if (frac && frac[frac.length - 1] === '0') node.minFractionDigits = frac.length;\n    return node;\n  },\n  stringify: stringifyNumber\n};\nvar core = failsafe.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);\n/* global BigInt */\n\nvar intIdentify$1 = function intIdentify(value) {\n  return typeof value === 'bigint' || Number.isInteger(value);\n};\n\nvar stringifyJSON = function stringifyJSON(_ref) {\n  var value = _ref.value;\n  return JSON.stringify(value);\n};\n\nvar json = [map, seq, {\n  identify: function identify(value) {\n    return typeof value === 'string';\n  },\n  \"default\": true,\n  tag: 'tag:yaml.org,2002:str',\n  resolve: resolveString,\n  stringify: stringifyJSON\n}, {\n  identify: function identify(value) {\n    return value == null;\n  },\n  createNode: function createNode(schema, value, ctx) {\n    return ctx.wrapScalars ? new Scalar(null) : null;\n  },\n  \"default\": true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^null$/,\n  resolve: function resolve() {\n    return null;\n  },\n  stringify: stringifyJSON\n}, {\n  identify: function identify(value) {\n    return typeof value === 'boolean';\n  },\n  \"default\": true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^true|false$/,\n  resolve: function resolve(str) {\n    return str === 'true';\n  },\n  stringify: stringifyJSON\n}, {\n  identify: intIdentify$1,\n  \"default\": true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^-?(?:0|[1-9][0-9]*)$/,\n  resolve: function resolve(str) {\n    return intOptions.asBigInt ? BigInt(str) : parseInt(str, 10);\n  },\n  stringify: function stringify(_ref2) {\n    var value = _ref2.value;\n    return intIdentify$1(value) ? value.toString() : JSON.stringify(value);\n  }\n}, {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  \"default\": true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^-?(?:0|[1-9][0-9]*)(?:\\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,\n  resolve: function resolve(str) {\n    return parseFloat(str);\n  },\n  stringify: stringifyJSON\n}];\n\njson.scalarFallback = function (str) {\n  throw new SyntaxError(\"Unresolved plain scalar \".concat(JSON.stringify(str)));\n};\n/* global BigInt */\n\n\nvar boolStringify = function boolStringify(_ref) {\n  var value = _ref.value;\n  return value ? boolOptions.trueStr : boolOptions.falseStr;\n};\n\nvar intIdentify$2 = function intIdentify(value) {\n  return typeof value === 'bigint' || Number.isInteger(value);\n};\n\nfunction intResolve$1(sign, src, radix) {\n  var str = src.replace(/_/g, '');\n\n  if (intOptions.asBigInt) {\n    switch (radix) {\n      case 2:\n        str = \"0b\".concat(str);\n        break;\n\n      case 8:\n        str = \"0o\".concat(str);\n        break;\n\n      case 16:\n        str = \"0x\".concat(str);\n        break;\n    }\n\n    var _n = BigInt(str);\n\n    return sign === '-' ? BigInt(-1) * _n : _n;\n  }\n\n  var n = parseInt(str, radix);\n  return sign === '-' ? -1 * n : n;\n}\n\nfunction intStringify$1(node, radix, prefix) {\n  var value = node.value;\n\n  if (intIdentify$2(value)) {\n    var str = value.toString(radix);\n    return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;\n  }\n\n  return stringifyNumber(node);\n}\n\nvar yaml11 = failsafe.concat([{\n  identify: function identify(value) {\n    return value == null;\n  },\n  createNode: function createNode(schema, value, ctx) {\n    return ctx.wrapScalars ? new Scalar(null) : null;\n  },\n  \"default\": true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^(?:~|[Nn]ull|NULL)?$/,\n  resolve: function resolve() {\n    return null;\n  },\n  options: nullOptions,\n  stringify: function stringify() {\n    return nullOptions.nullStr;\n  }\n}, {\n  identify: function identify(value) {\n    return typeof value === 'boolean';\n  },\n  \"default\": true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,\n  resolve: function resolve() {\n    return true;\n  },\n  options: boolOptions,\n  stringify: boolStringify\n}, {\n  identify: function identify(value) {\n    return typeof value === 'boolean';\n  },\n  \"default\": true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,\n  resolve: function resolve() {\n    return false;\n  },\n  options: boolOptions,\n  stringify: boolStringify\n}, {\n  identify: intIdentify$2,\n  \"default\": true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'BIN',\n  test: /^([-+]?)0b([0-1_]+)$/,\n  resolve: function resolve(str, sign, bin) {\n    return intResolve$1(sign, bin, 2);\n  },\n  stringify: function stringify(node) {\n    return intStringify$1(node, 2, '0b');\n  }\n}, {\n  identify: intIdentify$2,\n  \"default\": true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'OCT',\n  test: /^([-+]?)0([0-7_]+)$/,\n  resolve: function resolve(str, sign, oct) {\n    return intResolve$1(sign, oct, 8);\n  },\n  stringify: function stringify(node) {\n    return intStringify$1(node, 8, '0');\n  }\n}, {\n  identify: intIdentify$2,\n  \"default\": true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^([-+]?)([0-9][0-9_]*)$/,\n  resolve: function resolve(str, sign, abs) {\n    return intResolve$1(sign, abs, 10);\n  },\n  stringify: stringifyNumber\n}, {\n  identify: intIdentify$2,\n  \"default\": true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'HEX',\n  test: /^([-+]?)0x([0-9a-fA-F_]+)$/,\n  resolve: function resolve(str, sign, hex) {\n    return intResolve$1(sign, hex, 16);\n  },\n  stringify: function stringify(node) {\n    return intStringify$1(node, 16, '0x');\n  }\n}, {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  \"default\": true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^(?:[-+]?\\.inf|(\\.nan))$/i,\n  resolve: function resolve(str, nan) {\n    return nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n  },\n  stringify: stringifyNumber\n}, {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  \"default\": true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'EXP',\n  test: /^[-+]?([0-9][0-9_]*)?(\\.[0-9_]*)?[eE][-+]?[0-9]+$/,\n  resolve: function resolve(str) {\n    return parseFloat(str.replace(/_/g, ''));\n  },\n  stringify: function stringify(_ref2) {\n    var value = _ref2.value;\n    return Number(value).toExponential();\n  }\n}, {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  \"default\": true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^[-+]?(?:[0-9][0-9_]*)?\\.([0-9_]*)$/,\n  resolve: function resolve(str, frac) {\n    var node = new Scalar(parseFloat(str.replace(/_/g, '')));\n\n    if (frac) {\n      var f = frac.replace(/_/g, '');\n      if (f[f.length - 1] === '0') node.minFractionDigits = f.length;\n    }\n\n    return node;\n  },\n  stringify: stringifyNumber\n}], binary, omap, pairs, set, intTime, floatTime, timestamp);\nvar schemas = {\n  core: core,\n  failsafe: failsafe,\n  json: json,\n  yaml11: yaml11\n};\nvar tags = {\n  binary: binary,\n  bool: boolObj,\n  \"float\": floatObj,\n  floatExp: expObj,\n  floatNaN: nanObj,\n  floatTime: floatTime,\n  \"int\": intObj,\n  intHex: hexObj,\n  intOct: octObj,\n  intTime: intTime,\n  map: map,\n  \"null\": nullObj,\n  omap: omap,\n  pairs: pairs,\n  seq: seq,\n  set: set,\n  timestamp: timestamp\n};\n\nfunction findTagObject(value, tagName, tags) {\n  if (tagName) {\n    var match = tags.filter(function (t) {\n      return t.tag === tagName;\n    });\n    var tagObj = match.find(function (t) {\n      return !t.format;\n    }) || match[0];\n    if (!tagObj) throw new Error(\"Tag \".concat(tagName, \" not found\"));\n    return tagObj;\n  } // TODO: deprecate/remove class check\n\n\n  return tags.find(function (t) {\n    return (t.identify && t.identify(value) || t[\"class\"] && value instanceof t[\"class\"]) && !t.format;\n  });\n}\n\nfunction createNode(value, tagName, ctx) {\n  if (value instanceof resolveSeq_04825f30_Node) return value;\n  var defaultPrefix = ctx.defaultPrefix,\n      onTagObj = ctx.onTagObj,\n      prevObjects = ctx.prevObjects,\n      schema = ctx.schema,\n      wrapScalars = ctx.wrapScalars;\n  if (tagName && tagName.startsWith('!!')) tagName = defaultPrefix + tagName.slice(2);\n  var tagObj = findTagObject(value, tagName, schema.tags);\n\n  if (!tagObj) {\n    if (typeof value.toJSON === 'function') value = value.toJSON();\n    if (_typeof(value) !== 'object') return wrapScalars ? new Scalar(value) : value;\n    tagObj = value instanceof Map ? map : value[Symbol.iterator] ? seq : map;\n  }\n\n  if (onTagObj) {\n    onTagObj(tagObj);\n    delete ctx.onTagObj;\n  } // Detect duplicate references to the same object & use Alias nodes for all\n  // after first. The `obj` wrapper allows for circular references to resolve.\n\n\n  var obj = {};\n\n  if (value && _typeof(value) === 'object' && prevObjects) {\n    var prev = prevObjects.get(value);\n\n    if (prev) {\n      var alias = new resolveSeq_04825f30_Alias(prev); // leaves source dirty; must be cleaned by caller\n\n      ctx.aliasNodes.push(alias); // defined along with prevObjects\n\n      return alias;\n    }\n\n    obj.value = value;\n    prevObjects.set(value, obj);\n  }\n\n  obj.node = tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : wrapScalars ? new Scalar(value) : value;\n  if (tagName && obj.node instanceof resolveSeq_04825f30_Node) obj.node.tag = tagName;\n  return obj.node;\n}\n\nfunction getSchemaTags(schemas, knownTags, customTags, schemaId) {\n  var tags = schemas[schemaId.replace(/\\W/g, '')]; // 'yaml-1.1' -> 'yaml11'\n\n  if (!tags) {\n    var keys = Object.keys(schemas).map(function (key) {\n      return JSON.stringify(key);\n    }).join(', ');\n    throw new Error(\"Unknown schema \\\"\".concat(schemaId, \"\\\"; use one of \").concat(keys));\n  }\n\n  if (Array.isArray(customTags)) {\n    var _iterator = _createForOfIteratorHelper(customTags),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var tag = _step.value;\n        tags = tags.concat(tag);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  } else if (typeof customTags === 'function') {\n    tags = customTags(tags.slice());\n  }\n\n  for (var i = 0; i < tags.length; ++i) {\n    var _tag = tags[i];\n\n    if (typeof _tag === 'string') {\n      var tagObj = knownTags[_tag];\n\n      if (!tagObj) {\n        var _keys = Object.keys(knownTags).map(function (key) {\n          return JSON.stringify(key);\n        }).join(', ');\n\n        throw new Error(\"Unknown custom tag \\\"\".concat(_tag, \"\\\"; use one of \").concat(_keys));\n      }\n\n      tags[i] = tagObj;\n    }\n  }\n\n  return tags;\n}\n\nvar sortMapEntriesByKey = function sortMapEntriesByKey(a, b) {\n  return a.key < b.key ? -1 : a.key > b.key ? 1 : 0;\n};\n\nvar Schema = /*#__PURE__*/function () {\n  // TODO: remove in v2\n  // TODO: remove in v2\n  function Schema(_ref) {\n    var customTags = _ref.customTags,\n        merge = _ref.merge,\n        schema = _ref.schema,\n        sortMapEntries = _ref.sortMapEntries,\n        deprecatedCustomTags = _ref.tags;\n\n    _classCallCheck(this, Schema);\n\n    this.merge = !!merge;\n    this.name = schema;\n    this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;\n    if (!customTags && deprecatedCustomTags) warnOptionDeprecation('tags', 'customTags');\n    this.tags = getSchemaTags(schemas, tags, customTags || deprecatedCustomTags, schema);\n  }\n\n  _createClass(Schema, [{\n    key: \"createNode\",\n    value: function createNode$1(value, wrapScalars, tagName, ctx) {\n      var baseCtx = {\n        defaultPrefix: Schema.defaultPrefix,\n        schema: this,\n        wrapScalars: wrapScalars\n      };\n      var createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx;\n      return createNode(value, tagName, createCtx);\n    }\n  }, {\n    key: \"createPair\",\n    value: function createPair(key, value, ctx) {\n      if (!ctx) ctx = {\n        wrapScalars: true\n      };\n      var k = this.createNode(key, ctx.wrapScalars, null, ctx);\n      var v = this.createNode(value, ctx.wrapScalars, null, ctx);\n      return new Pair(k, v);\n    }\n  }]);\n\n  return Schema;\n}();\n\n_defineProperty(Schema, \"defaultPrefix\", defaultTagPrefix);\n\n_defineProperty(Schema, \"defaultTags\", defaultTags);\n\n\n;// CONCATENATED MODULE: ./node_modules/yaml/browser/dist/index.js\n\n\n\n\n\nvar defaultOptions = {\n  anchorPrefix: 'a',\n  customTags: null,\n  indent: 2,\n  indentSeq: true,\n  keepCstNodes: false,\n  keepNodeTypes: true,\n  keepBlobsInJSON: true,\n  mapAsMap: false,\n  maxAliasCount: 100,\n  prettyErrors: false,\n  // TODO Set true in v2\n  simpleKeys: false,\n  version: '1.2'\n};\nvar scalarOptions = {\n  get binary() {\n    return binaryOptions;\n  },\n\n  set binary(opt) {\n    Object.assign(binaryOptions, opt);\n  },\n\n  get bool() {\n    return boolOptions;\n  },\n\n  set bool(opt) {\n    Object.assign(boolOptions, opt);\n  },\n\n  get int() {\n    return intOptions;\n  },\n\n  set int(opt) {\n    Object.assign(intOptions, opt);\n  },\n\n  get null() {\n    return nullOptions;\n  },\n\n  set null(opt) {\n    Object.assign(nullOptions, opt);\n  },\n\n  get str() {\n    return strOptions;\n  },\n\n  set str(opt) {\n    Object.assign(strOptions, opt);\n  }\n\n};\nvar documentOptions = {\n  '1.0': {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: defaultTagPrefix\n    }, {\n      handle: '!!',\n      prefix: 'tag:private.yaml.org,2002:'\n    }]\n  },\n  '1.1': {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: defaultTagPrefix\n    }]\n  },\n  '1.2': {\n    schema: 'core',\n    merge: false,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: defaultTagPrefix\n    }]\n  }\n};\n\nfunction stringifyTag(doc, tag) {\n  if ((doc.version || doc.options.version) === '1.0') {\n    var priv = tag.match(/^tag:private\\.yaml\\.org,2002:([^:/]+)$/);\n    if (priv) return '!' + priv[1];\n    var vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\\.yaml\\.org,2002:(.*)/);\n    return vocab ? \"!\".concat(vocab[1], \"/\").concat(vocab[2]) : \"!\".concat(tag.replace(/^tag:/, ''));\n  }\n\n  var p = doc.tagPrefixes.find(function (p) {\n    return tag.indexOf(p.prefix) === 0;\n  });\n\n  if (!p) {\n    var dtp = doc.getDefaults().tagPrefixes;\n    p = dtp && dtp.find(function (p) {\n      return tag.indexOf(p.prefix) === 0;\n    });\n  }\n\n  if (!p) return tag[0] === '!' ? tag : \"!<\".concat(tag, \">\");\n  var suffix = tag.substr(p.prefix.length).replace(/[!,[\\]{}]/g, function (ch) {\n    return {\n      '!': '%21',\n      ',': '%2C',\n      '[': '%5B',\n      ']': '%5D',\n      '{': '%7B',\n      '}': '%7D'\n    }[ch];\n  });\n  return p.handle + suffix;\n}\n\nfunction getTagObject(tags, item) {\n  if (item instanceof resolveSeq_04825f30_Alias) return resolveSeq_04825f30_Alias;\n\n  if (item.tag) {\n    var match = tags.filter(function (t) {\n      return t.tag === item.tag;\n    });\n    if (match.length > 0) return match.find(function (t) {\n      return t.format === item.format;\n    }) || match[0];\n  }\n\n  var tagObj, obj;\n\n  if (item instanceof Scalar) {\n    obj = item.value; // TODO: deprecate/remove class check\n\n    var _match = tags.filter(function (t) {\n      return t.identify && t.identify(obj) || t[\"class\"] && obj instanceof t[\"class\"];\n    });\n\n    tagObj = _match.find(function (t) {\n      return t.format === item.format;\n    }) || _match.find(function (t) {\n      return !t.format;\n    });\n  } else {\n    obj = item;\n    tagObj = tags.find(function (t) {\n      return t.nodeClass && obj instanceof t.nodeClass;\n    });\n  }\n\n  if (!tagObj) {\n    var name = obj && obj.constructor ? obj.constructor.name : _typeof(obj);\n    throw new Error(\"Tag not resolved for \".concat(name, \" value\"));\n  }\n\n  return tagObj;\n} // needs to be called before value stringifier to allow for circular anchor refs\n\n\nfunction stringifyProps(node, tagObj, _ref) {\n  var anchors = _ref.anchors,\n      doc = _ref.doc;\n  var props = [];\n  var anchor = doc.anchors.getName(node);\n\n  if (anchor) {\n    anchors[anchor] = node;\n    props.push(\"&\".concat(anchor));\n  }\n\n  if (node.tag) {\n    props.push(stringifyTag(doc, node.tag));\n  } else if (!tagObj[\"default\"]) {\n    props.push(stringifyTag(doc, tagObj.tag));\n  }\n\n  return props.join(' ');\n}\n\nfunction stringify(item, ctx, onComment, onChompKeep) {\n  var _ctx$doc = ctx.doc,\n      anchors = _ctx$doc.anchors,\n      schema = _ctx$doc.schema;\n  var tagObj;\n\n  if (!(item instanceof resolveSeq_04825f30_Node)) {\n    var createCtx = {\n      aliasNodes: [],\n      onTagObj: function onTagObj(o) {\n        return tagObj = o;\n      },\n      prevObjects: new Map()\n    };\n    item = schema.createNode(item, true, null, createCtx);\n\n    var _iterator = _createForOfIteratorHelper(createCtx.aliasNodes),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var alias = _step.value;\n        alias.source = alias.source.node;\n        var name = anchors.getName(alias.source);\n\n        if (!name) {\n          name = anchors.newName();\n          anchors.map[name] = alias.source;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  if (item instanceof Pair) return item.toString(ctx, onComment, onChompKeep);\n  if (!tagObj) tagObj = getTagObject(schema.tags, item);\n  var props = stringifyProps(item, tagObj, ctx);\n  if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;\n  var str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof Scalar ? stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);\n  if (!props) return str;\n  return item instanceof Scalar || str[0] === '{' || str[0] === '[' ? \"\".concat(props, \" \").concat(str) : \"\".concat(props, \"\\n\").concat(ctx.indent).concat(str);\n}\n\nvar Anchors = /*#__PURE__*/function () {\n  _createClass(Anchors, null, [{\n    key: \"validAnchorNode\",\n    value: function validAnchorNode(node) {\n      return node instanceof Scalar || node instanceof YAMLSeq || node instanceof YAMLMap;\n    }\n  }]);\n\n  function Anchors(prefix) {\n    _classCallCheck(this, Anchors);\n\n    _defineProperty(this, \"map\", {});\n\n    this.prefix = prefix;\n  }\n\n  _createClass(Anchors, [{\n    key: \"createAlias\",\n    value: function createAlias(node, name) {\n      this.setAnchor(node, name);\n      return new resolveSeq_04825f30_Alias(node);\n    }\n  }, {\n    key: \"createMergePair\",\n    value: function createMergePair() {\n      var _this = this;\n\n      var merge = new Merge();\n\n      for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n        sources[_key] = arguments[_key];\n      }\n\n      merge.value.items = sources.map(function (s) {\n        if (s instanceof resolveSeq_04825f30_Alias) {\n          if (s.source instanceof YAMLMap) return s;\n        } else if (s instanceof YAMLMap) {\n          return _this.createAlias(s);\n        }\n\n        throw new Error('Merge sources must be Map nodes or their Aliases');\n      });\n      return merge;\n    }\n  }, {\n    key: \"getName\",\n    value: function getName(node) {\n      var map = this.map;\n      return Object.keys(map).find(function (a) {\n        return map[a] === node;\n      });\n    }\n  }, {\n    key: \"getNames\",\n    value: function getNames() {\n      return Object.keys(this.map);\n    }\n  }, {\n    key: \"getNode\",\n    value: function getNode(name) {\n      return this.map[name];\n    }\n  }, {\n    key: \"newName\",\n    value: function newName(prefix) {\n      if (!prefix) prefix = this.prefix;\n      var names = Object.keys(this.map);\n\n      for (var i = 1; true; ++i) {\n        var name = \"\".concat(prefix).concat(i);\n        if (!names.includes(name)) return name;\n      }\n    } // During parsing, map & aliases contain CST nodes\n\n  }, {\n    key: \"resolveNodes\",\n    value: function resolveNodes() {\n      var map = this.map,\n          _cstAliases = this._cstAliases;\n      Object.keys(map).forEach(function (a) {\n        map[a] = map[a].resolved;\n      });\n\n      _cstAliases.forEach(function (a) {\n        a.source = a.source.resolved;\n      });\n\n      delete this._cstAliases;\n    }\n  }, {\n    key: \"setAnchor\",\n    value: function setAnchor(node, name) {\n      if (node != null && !Anchors.validAnchorNode(node)) {\n        throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');\n      }\n\n      if (name && /[\\x00-\\x19\\s,[\\]{}]/.test(name)) {\n        throw new Error('Anchor names must not contain whitespace or control characters');\n      }\n\n      var map = this.map;\n      var prev = node && Object.keys(map).find(function (a) {\n        return map[a] === node;\n      });\n\n      if (prev) {\n        if (!name) {\n          return prev;\n        } else if (prev !== name) {\n          delete map[prev];\n          map[name] = node;\n        }\n      } else {\n        if (!name) {\n          if (!node) return null;\n          name = this.newName();\n        }\n\n        map[name] = node;\n      }\n\n      return name;\n    }\n  }]);\n\n  return Anchors;\n}();\n\nvar visit = function visit(node, tags) {\n  if (node && _typeof(node) === 'object') {\n    var tag = node.tag;\n\n    if (node instanceof resolveSeq_04825f30_Collection) {\n      if (tag) tags[tag] = true;\n      node.items.forEach(function (n) {\n        return visit(n, tags);\n      });\n    } else if (node instanceof Pair) {\n      visit(node.key, tags);\n      visit(node.value, tags);\n    } else if (node instanceof Scalar) {\n      if (tag) tags[tag] = true;\n    }\n  }\n\n  return tags;\n};\n\nvar listTagNames = function listTagNames(node) {\n  return Object.keys(visit(node, {}));\n};\n\nfunction parseContents(doc, contents) {\n  var comments = {\n    before: [],\n    after: []\n  };\n  var body = undefined;\n  var spaceBefore = false;\n\n  var _iterator = _createForOfIteratorHelper(contents),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var node = _step.value;\n\n      if (node.valueRange) {\n        if (body !== undefined) {\n          var msg = 'Document contains trailing content not separated by a ... or --- line';\n          doc.errors.push(new YAMLSyntaxError(node, msg));\n          break;\n        }\n\n        var res = resolveNode(doc, node);\n\n        if (spaceBefore) {\n          res.spaceBefore = true;\n          spaceBefore = false;\n        }\n\n        body = res;\n      } else if (node.comment !== null) {\n        var cc = body === undefined ? comments.before : comments.after;\n        cc.push(node.comment);\n      } else if (node.type === Type.BLANK_LINE) {\n        spaceBefore = true;\n\n        if (body === undefined && comments.before.length > 0 && !doc.commentBefore) {\n          // space-separated comments at start are parsed as document comments\n          doc.commentBefore = comments.before.join('\\n');\n          comments.before = [];\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  doc.contents = body || null;\n\n  if (!body) {\n    doc.comment = comments.before.concat(comments.after).join('\\n') || null;\n  } else {\n    var cb = comments.before.join('\\n');\n\n    if (cb) {\n      var cbNode = body instanceof resolveSeq_04825f30_Collection && body.items[0] ? body.items[0] : body;\n      cbNode.commentBefore = cbNode.commentBefore ? \"\".concat(cb, \"\\n\").concat(cbNode.commentBefore) : cb;\n    }\n\n    doc.comment = comments.after.join('\\n') || null;\n  }\n}\n\nfunction resolveTagDirective(_ref, directive) {\n  var tagPrefixes = _ref.tagPrefixes;\n\n  var _directive$parameters = _slicedToArray(directive.parameters, 2),\n      handle = _directive$parameters[0],\n      prefix = _directive$parameters[1];\n\n  if (!handle || !prefix) {\n    var msg = 'Insufficient parameters given for %TAG directive';\n    throw new YAMLSemanticError(directive, msg);\n  }\n\n  if (tagPrefixes.some(function (p) {\n    return p.handle === handle;\n  })) {\n    var _msg = 'The %TAG directive must only be given at most once per handle in the same document.';\n    throw new YAMLSemanticError(directive, _msg);\n  }\n\n  return {\n    handle: handle,\n    prefix: prefix\n  };\n}\n\nfunction resolveYamlDirective(doc, directive) {\n  var _directive$parameters2 = _slicedToArray(directive.parameters, 1),\n      version = _directive$parameters2[0];\n\n  if (directive.name === 'YAML:1.0') version = '1.0';\n\n  if (!version) {\n    var msg = 'Insufficient parameters given for %YAML directive';\n    throw new YAMLSemanticError(directive, msg);\n  }\n\n  if (!documentOptions[version]) {\n    var v0 = doc.version || doc.options.version;\n\n    var _msg2 = \"Document will be parsed as YAML \".concat(v0, \" rather than YAML \").concat(version);\n\n    doc.warnings.push(new YAMLWarning(directive, _msg2));\n  }\n\n  return version;\n}\n\nfunction parseDirectives(doc, directives, prevDoc) {\n  var directiveComments = [];\n  var hasDirectives = false;\n\n  var _iterator = _createForOfIteratorHelper(directives),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var directive = _step.value;\n      var comment = directive.comment,\n          name = directive.name;\n\n      switch (name) {\n        case 'TAG':\n          try {\n            doc.tagPrefixes.push(resolveTagDirective(doc, directive));\n          } catch (error) {\n            doc.errors.push(error);\n          }\n\n          hasDirectives = true;\n          break;\n\n        case 'YAML':\n        case 'YAML:1.0':\n          if (doc.version) {\n            var msg = 'The %YAML directive must only be given at most once per document.';\n            doc.errors.push(new YAMLSemanticError(directive, msg));\n          }\n\n          try {\n            doc.version = resolveYamlDirective(doc, directive);\n          } catch (error) {\n            doc.errors.push(error);\n          }\n\n          hasDirectives = true;\n          break;\n\n        default:\n          if (name) {\n            var _msg3 = \"YAML only supports %TAG and %YAML directives, and not %\".concat(name);\n\n            doc.warnings.push(new YAMLWarning(directive, _msg3));\n          }\n\n      }\n\n      if (comment) directiveComments.push(comment);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (prevDoc && !hasDirectives && '1.1' === (doc.version || prevDoc.version || doc.options.version)) {\n    var copyTagPrefix = function copyTagPrefix(_ref2) {\n      var handle = _ref2.handle,\n          prefix = _ref2.prefix;\n      return {\n        handle: handle,\n        prefix: prefix\n      };\n    };\n\n    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);\n    doc.version = prevDoc.version;\n  }\n\n  doc.commentBefore = directiveComments.join('\\n') || null;\n}\n\nfunction assertCollection(contents) {\n  if (contents instanceof resolveSeq_04825f30_Collection) return true;\n  throw new Error('Expected a YAML collection as document contents');\n}\n\nvar dist_Document = /*#__PURE__*/function () {\n  function Document(options) {\n    _classCallCheck(this, Document);\n\n    this.anchors = new Anchors(options.anchorPrefix);\n    this.commentBefore = null;\n    this.comment = null;\n    this.contents = null;\n    this.directivesEndMarker = null;\n    this.errors = [];\n    this.options = options;\n    this.schema = null;\n    this.tagPrefixes = [];\n    this.version = null;\n    this.warnings = [];\n  }\n\n  _createClass(Document, [{\n    key: \"add\",\n    value: function add(value) {\n      assertCollection(this.contents);\n      return this.contents.add(value);\n    }\n  }, {\n    key: \"addIn\",\n    value: function addIn(path, value) {\n      assertCollection(this.contents);\n      this.contents.addIn(path, value);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      assertCollection(this.contents);\n      return this.contents[\"delete\"](key);\n    }\n  }, {\n    key: \"deleteIn\",\n    value: function deleteIn(path) {\n      if (isEmptyPath(path)) {\n        if (this.contents == null) return false;\n        this.contents = null;\n        return true;\n      }\n\n      assertCollection(this.contents);\n      return this.contents.deleteIn(path);\n    }\n  }, {\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Document.defaults[this.version] || Document.defaults[this.options.version] || {};\n    }\n  }, {\n    key: \"get\",\n    value: function get(key, keepScalar) {\n      return this.contents instanceof resolveSeq_04825f30_Collection ? this.contents.get(key, keepScalar) : undefined;\n    }\n  }, {\n    key: \"getIn\",\n    value: function getIn(path, keepScalar) {\n      if (isEmptyPath(path)) return !keepScalar && this.contents instanceof Scalar ? this.contents.value : this.contents;\n      return this.contents instanceof resolveSeq_04825f30_Collection ? this.contents.getIn(path, keepScalar) : undefined;\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return this.contents instanceof resolveSeq_04825f30_Collection ? this.contents.has(key) : false;\n    }\n  }, {\n    key: \"hasIn\",\n    value: function hasIn(path) {\n      if (isEmptyPath(path)) return this.contents !== undefined;\n      return this.contents instanceof resolveSeq_04825f30_Collection ? this.contents.hasIn(path) : false;\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      assertCollection(this.contents);\n      this.contents.set(key, value);\n    }\n  }, {\n    key: \"setIn\",\n    value: function setIn(path, value) {\n      if (isEmptyPath(path)) this.contents = value;else {\n        assertCollection(this.contents);\n        this.contents.setIn(path, value);\n      }\n    }\n  }, {\n    key: \"setSchema\",\n    value: function setSchema(id, customTags) {\n      if (!id && !customTags && this.schema) return;\n      if (typeof id === 'number') id = id.toFixed(1);\n\n      if (id === '1.0' || id === '1.1' || id === '1.2') {\n        if (this.version) this.version = id;else this.options.version = id;\n        delete this.options.schema;\n      } else if (id && typeof id === 'string') {\n        this.options.schema = id;\n      }\n\n      if (Array.isArray(customTags)) this.options.customTags = customTags;\n      var opt = Object.assign({}, this.getDefaults(), this.options);\n      this.schema = new Schema(opt);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(node, prevDoc) {\n      if (this.options.keepCstNodes) this.cstNode = node;\n      if (this.options.keepNodeTypes) this.type = 'DOCUMENT';\n      var _node$directives = node.directives,\n          directives = _node$directives === void 0 ? [] : _node$directives,\n          _node$contents = node.contents,\n          contents = _node$contents === void 0 ? [] : _node$contents,\n          directivesEndMarker = node.directivesEndMarker,\n          error = node.error,\n          valueRange = node.valueRange;\n\n      if (error) {\n        if (!error.source) error.source = this;\n        this.errors.push(error);\n      }\n\n      parseDirectives(this, directives, prevDoc);\n      if (directivesEndMarker) this.directivesEndMarker = true;\n      this.range = valueRange ? [valueRange.start, valueRange.end] : null;\n      this.setSchema();\n      this.anchors._cstAliases = [];\n      parseContents(this, contents);\n      this.anchors.resolveNodes();\n\n      if (this.options.prettyErrors) {\n        var _iterator = _createForOfIteratorHelper(this.errors),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _error = _step.value;\n            if (_error instanceof YAMLError) _error.makePretty();\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        var _iterator2 = _createForOfIteratorHelper(this.warnings),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var warn = _step2.value;\n            if (warn instanceof YAMLError) warn.makePretty();\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"listNonDefaultTags\",\n    value: function listNonDefaultTags() {\n      return listTagNames(this.contents).filter(function (t) {\n        return t.indexOf(Schema.defaultPrefix) !== 0;\n      });\n    }\n  }, {\n    key: \"setTagPrefix\",\n    value: function setTagPrefix(handle, prefix) {\n      if (handle[0] !== '!' || handle[handle.length - 1] !== '!') throw new Error('Handle must start and end with !');\n\n      if (prefix) {\n        var prev = this.tagPrefixes.find(function (p) {\n          return p.handle === handle;\n        });\n        if (prev) prev.prefix = prefix;else this.tagPrefixes.push({\n          handle: handle,\n          prefix: prefix\n        });\n      } else {\n        this.tagPrefixes = this.tagPrefixes.filter(function (p) {\n          return p.handle !== handle;\n        });\n      }\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON$1(arg, onAnchor) {\n      var _this = this;\n\n      var _this$options = this.options,\n          keepBlobsInJSON = _this$options.keepBlobsInJSON,\n          mapAsMap = _this$options.mapAsMap,\n          maxAliasCount = _this$options.maxAliasCount;\n      var keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof Scalar));\n      var ctx = {\n        doc: this,\n        indentStep: '  ',\n        keep: keep,\n        mapAsMap: keep && !!mapAsMap,\n        maxAliasCount: maxAliasCount,\n        stringify: stringify // Requiring directly in Pair would create circular dependencies\n\n      };\n      var anchorNames = Object.keys(this.anchors.map);\n      if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map(function (name) {\n        return [_this.anchors.map[name], {\n          alias: [],\n          aliasCount: 0,\n          count: 1\n        }];\n      }));\n      var res = toJSON(this.contents, arg, ctx);\n\n      if (typeof onAnchor === 'function' && ctx.anchors) {\n        var _iterator3 = _createForOfIteratorHelper(ctx.anchors.values()),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _step3$value = _step3.value,\n                count = _step3$value.count,\n                _res = _step3$value.res;\n            onAnchor(_res, count);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n\n      return res;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');\n      var indentSize = this.options.indent;\n\n      if (!Number.isInteger(indentSize) || indentSize <= 0) {\n        var s = JSON.stringify(indentSize);\n        throw new Error(\"\\\"indent\\\" option must be a positive integer, not \".concat(s));\n      }\n\n      this.setSchema();\n      var lines = [];\n      var hasDirectives = false;\n\n      if (this.version) {\n        var vd = '%YAML 1.2';\n\n        if (this.schema.name === 'yaml-1.1') {\n          if (this.version === '1.0') vd = '%YAML:1.0';else if (this.version === '1.1') vd = '%YAML 1.1';\n        }\n\n        lines.push(vd);\n        hasDirectives = true;\n      }\n\n      var tagNames = this.listNonDefaultTags();\n      this.tagPrefixes.forEach(function (_ref) {\n        var handle = _ref.handle,\n            prefix = _ref.prefix;\n\n        if (tagNames.some(function (t) {\n          return t.indexOf(prefix) === 0;\n        })) {\n          lines.push(\"%TAG \".concat(handle, \" \").concat(prefix));\n          hasDirectives = true;\n        }\n      });\n      if (hasDirectives || this.directivesEndMarker) lines.push('---');\n\n      if (this.commentBefore) {\n        if (hasDirectives || !this.directivesEndMarker) lines.unshift('');\n        lines.unshift(this.commentBefore.replace(/^/gm, '#'));\n      }\n\n      var ctx = {\n        anchors: {},\n        doc: this,\n        indent: '',\n        indentStep: ' '.repeat(indentSize),\n        stringify: stringify // Requiring directly in nodes would create circular dependencies\n\n      };\n      var chompKeep = false;\n      var contentComment = null;\n\n      if (this.contents) {\n        if (this.contents instanceof resolveSeq_04825f30_Node) {\n          if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push('');\n          if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment\n\n          ctx.forceBlockIndent = !!this.comment;\n          contentComment = this.contents.comment;\n        }\n\n        var onChompKeep = contentComment ? null : function () {\n          return chompKeep = true;\n        };\n        var body = stringify(this.contents, ctx, function () {\n          return contentComment = null;\n        }, onChompKeep);\n        lines.push(addComment(body, '', contentComment));\n      } else if (this.contents !== undefined) {\n        lines.push(stringify(this.contents, ctx));\n      }\n\n      if (this.comment) {\n        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');\n        lines.push(this.comment.replace(/^/gm, '#'));\n      }\n\n      return lines.join('\\n') + '\\n';\n    }\n  }]);\n\n  return Document;\n}();\n\n_defineProperty(dist_Document, \"defaults\", documentOptions);\n\nfunction dist_createNode(value) {\n  var wrapScalars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var tag = arguments.length > 2 ? arguments[2] : undefined;\n\n  if (tag === undefined && typeof wrapScalars === 'string') {\n    tag = wrapScalars;\n    wrapScalars = true;\n  }\n\n  var options = Object.assign({}, dist_Document.defaults[defaultOptions.version], defaultOptions);\n  var schema = new Schema(options);\n  return schema.createNode(value, wrapScalars, tag);\n}\n\nvar Document$1 = /*#__PURE__*/function (_YAMLDocument) {\n  _inherits(Document, _YAMLDocument);\n\n  var _super = _createSuper(Document);\n\n  function Document(options) {\n    _classCallCheck(this, Document);\n\n    return _super.call(this, Object.assign({}, defaultOptions, options));\n  }\n\n  return Document;\n}(dist_Document);\n\nfunction parseAllDocuments(src, options) {\n  var stream = [];\n  var prev;\n\n  var _iterator = _createForOfIteratorHelper(parse(src)),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var cstDoc = _step.value;\n      var doc = new Document$1(options);\n      doc.parse(cstDoc, prev);\n      stream.push(doc);\n      prev = doc;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return stream;\n}\n\nfunction parseDocument(src, options) {\n  var cst = parse(src);\n  var doc = new Document$1(options).parse(cst[0]);\n\n  if (cst.length > 1) {\n    var errMsg = 'Source contains multiple documents; please use YAML.parseAllDocuments()';\n    doc.errors.unshift(new YAMLSemanticError(cst[1], errMsg));\n  }\n\n  return doc;\n}\n\nfunction dist_parse(src, options) {\n  var doc = parseDocument(src, options);\n  doc.warnings.forEach(function (warning) {\n    return warn(warning);\n  });\n  if (doc.errors.length > 0) throw doc.errors[0];\n  return doc.toJSON();\n}\n\nfunction stringify$1(value, options) {\n  var doc = new Document$1(options);\n  doc.contents = value;\n  return String(doc);\n}\n\nvar YAML = {\n  createNode: dist_createNode,\n  defaultOptions: defaultOptions,\n  Document: Document$1,\n  parse: dist_parse,\n  parseAllDocuments: parseAllDocuments,\n  parseCST: parse,\n  parseDocument: parseDocument,\n  scalarOptions: scalarOptions,\n  stringify: stringify$1\n};\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/yaml/browser/dist/index.js_+_5_modules?")},13967:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("var __webpack_unused_export__;\n\n\nvar _interopRequireWildcard = __webpack_require__(20862);\n\nvar _interopRequireDefault = __webpack_require__(95318);\n\n__webpack_unused_export__ = ({\n  value: true\n});\n__webpack_unused_export__ = convertYamlNodeToBabelNodeInner;\n__webpack_unused_export__ = convertYamlNodeToBabelNode;\nexports.s8 = convertText;\n\nvar _typeof2 = _interopRequireDefault(__webpack_require__(50008));\n\nvar t = _interopRequireWildcard(__webpack_require__(38218));\n\nvar _generator = _interopRequireDefault(__webpack_require__(39166));\n\nvar _yaml = _interopRequireDefault(__webpack_require__(69741));\n\nfunction convertPrimitive(value) {\n  switch ((0, _typeof2[\"default\"])(value)) {\n    case 'string':\n      return t.stringLiteral(value);\n\n    case 'number':\n      return t.numericLiteral(value);\n\n    case 'boolean':\n      return t.booleanLiteral(value);\n  }\n}\n\nfunction convertKey(key) {\n  var value = key.value;\n\n  if (/^[_a-z][_a-z0-9]*$/i.test(value)) {\n    return t.identifier(value);\n  }\n\n  return convertPrimitive(value);\n}\n\nfunction convertTag(tag) {\n  switch (tag) {\n    case '!Ref':\n      return t.identifier('Ref');\n\n    default:\n      return t.stringLiteral(tag.replace(/^!/, 'Fn::'));\n  }\n}\n\nfunction convertYamlNodeToBabelNodeInner(yaml) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$indentation = _ref.indentation,\n      indentation = _ref$indentation === void 0 ? 0 : _ref$indentation;\n\n  switch (yaml.type) {\n    case 'PLAIN':\n    case 'QUOTE_SINGLE':\n    case 'QUOTE_DOUBLE':\n      {\n        var _ref2 = yaml,\n            tag = _ref2.tag,\n            value = _ref2.value;\n\n        if (tag) {\n          return t.objectExpression([t.objectProperty(convertTag(tag), convertPrimitive(value))]);\n        } else {\n          return convertPrimitive(value);\n        }\n      }\n\n    case 'BLOCK_LITERAL':\n      {\n        var _ref3 = yaml,\n            _tag = _ref3.tag,\n            _value = _ref3.value;\n        var converted = t.taggedTemplateExpression(t.identifier('dedent'), t.templateLiteral([t.templateElement({\n          raw: ('\\n' + _value).replace(/\\n/gm, function (match, offset) {\n            return '\\n' + '  '.repeat(indentation + (_tag ? 2 : 0) + (offset === _value.length ? -1 : 0));\n          }).replace(/\\$\\{/g, '\\\\${')\n        })], []));\n        return _tag ? t.objectExpression([t.objectProperty(convertTag(_tag), converted)]) : converted;\n      }\n\n    case 'MAP':\n      {\n        var _ref4 = yaml,\n            items = _ref4.items;\n        return t.objectExpression(items.map(function (item) {\n          return convertYamlNodeToBabelNode(item, {\n            indentation: indentation + 1\n          });\n        }));\n      }\n\n    case 'SEQ':\n      {\n        var _ref5 = yaml,\n            _items = _ref5.items;\n        return t.arrayExpression(_items.map(function (item) {\n          return convertYamlNodeToBabelNode(item, {\n            indentation: indentation + 1\n          });\n        }));\n      }\n\n    case 'PAIR':\n      {\n        var _ref6 = yaml,\n            key = _ref6.key,\n            _value2 = _ref6.value;\n        return t.objectProperty(convertKey(key), convertYamlNodeToBabelNode(_value2, {\n          indentation: indentation\n        }));\n      }\n  }\n\n  throw new Error(\"unsupported YAML node type: \".concat(yaml.type));\n}\n\nfunction convertYamlNodeToBabelNode(yaml, options) {\n  var converted = convertYamlNodeToBabelNodeInner(yaml, options);\n  var comment = yaml.comment,\n      commentBefore = yaml.commentBefore;\n\n  if (comment) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = comment.split(/\\r\\n?|\\n/gm)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var line = _step.value;\n        t.addComment(converted, 'trailing', line, true);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  if (commentBefore) {\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = commentBefore.split(/\\r\\n?|\\n/gm).reverse()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var _line = _step2.value;\n        t.addComment(converted, 'leading', _line, true);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n          _iterator2[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  }\n\n  return converted;\n}\n\nfunction convertText(yaml) {\n  var _YAML$parseDocument = _yaml[\"default\"].parseDocument(yaml),\n      contents = _YAML$parseDocument.contents;\n\n  if (!contents) throw new Error('failed to get contents of parsed document');\n  var ast = convertYamlNodeToBabelNode(contents);\n  return (0, _generator[\"default\"])(ast).code;\n}\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/cfn-template-yaml-to-js/index.js?")},3312:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("/* provided dependency */ var Buffer = __webpack_require__(48764)[\"Buffer\"];\n\n\nconst object = {};\nconst hasOwnProperty = object.hasOwnProperty;\nconst forOwn = (object, callback) => {\n\tfor (const key in object) {\n\t\tif (hasOwnProperty.call(object, key)) {\n\t\t\tcallback(key, object[key]);\n\t\t}\n\t}\n};\n\nconst extend = (destination, source) => {\n\tif (!source) {\n\t\treturn destination;\n\t}\n\tforOwn(source, (key, value) => {\n\t\tdestination[key] = value;\n\t});\n\treturn destination;\n};\n\nconst forEach = (array, callback) => {\n\tconst length = array.length;\n\tlet index = -1;\n\twhile (++index < length) {\n\t\tcallback(array[index]);\n\t}\n};\n\nconst toString = object.toString;\nconst isArray = Array.isArray;\nconst isBuffer = Buffer.isBuffer;\nconst isObject = (value) => {\n\t// This is a very simple check, but it’s good enough for what we need.\n\treturn toString.call(value) == '[object Object]';\n};\nconst isString = (value) => {\n\treturn typeof value == 'string' ||\n\t\ttoString.call(value) == '[object String]';\n};\nconst isNumber = (value) => {\n\treturn typeof value == 'number' ||\n\t\ttoString.call(value) == '[object Number]';\n};\nconst isFunction = (value) => {\n\treturn typeof value == 'function';\n};\nconst isMap = (value) => {\n\treturn toString.call(value) == '[object Map]';\n};\nconst isSet = (value) => {\n\treturn toString.call(value) == '[object Set]';\n};\n\n/*--------------------------------------------------------------------------*/\n\n// https://mathiasbynens.be/notes/javascript-escapes#single\nconst singleEscapes = {\n\t'\"': '\\\\\"',\n\t'\\'': '\\\\\\'',\n\t'\\\\': '\\\\\\\\',\n\t'\\b': '\\\\b',\n\t'\\f': '\\\\f',\n\t'\\n': '\\\\n',\n\t'\\r': '\\\\r',\n\t'\\t': '\\\\t'\n\t// `\\v` is omitted intentionally, because in IE < 9, '\\v' == 'v'.\n\t// '\\v': '\\\\x0B'\n};\nconst regexSingleEscape = /[\"'\\\\\\b\\f\\n\\r\\t]/;\n\nconst regexDigit = /[0-9]/;\nconst regexWhitelist = /[ !#-&\\(-\\[\\]-_a-~]/;\n\nconst jsesc = (argument, options) => {\n\tconst increaseIndentation = () => {\n\t\toldIndent = indent;\n\t\t++options.indentLevel;\n\t\tindent = options.indent.repeat(options.indentLevel)\n\t};\n\t// Handle options\n\tconst defaults = {\n\t\t'escapeEverything': false,\n\t\t'minimal': false,\n\t\t'isScriptContext': false,\n\t\t'quotes': 'single',\n\t\t'wrap': false,\n\t\t'es6': false,\n\t\t'json': false,\n\t\t'compact': true,\n\t\t'lowercaseHex': false,\n\t\t'numbers': 'decimal',\n\t\t'indent': '\\t',\n\t\t'indentLevel': 0,\n\t\t'__inline1__': false,\n\t\t'__inline2__': false\n\t};\n\tconst json = options && options.json;\n\tif (json) {\n\t\tdefaults.quotes = 'double';\n\t\tdefaults.wrap = true;\n\t}\n\toptions = extend(defaults, options);\n\tif (\n\t\toptions.quotes != 'single' &&\n\t\toptions.quotes != 'double' &&\n\t\toptions.quotes != 'backtick'\n\t) {\n\t\toptions.quotes = 'single';\n\t}\n\tconst quote = options.quotes == 'double' ?\n\t\t'\"' :\n\t\t(options.quotes == 'backtick' ?\n\t\t\t'`' :\n\t\t\t'\\''\n\t\t);\n\tconst compact = options.compact;\n\tconst lowercaseHex = options.lowercaseHex;\n\tlet indent = options.indent.repeat(options.indentLevel);\n\tlet oldIndent = '';\n\tconst inline1 = options.__inline1__;\n\tconst inline2 = options.__inline2__;\n\tconst newLine = compact ? '' : '\\n';\n\tlet result;\n\tlet isEmpty = true;\n\tconst useBinNumbers = options.numbers == 'binary';\n\tconst useOctNumbers = options.numbers == 'octal';\n\tconst useDecNumbers = options.numbers == 'decimal';\n\tconst useHexNumbers = options.numbers == 'hexadecimal';\n\n\tif (json && argument && isFunction(argument.toJSON)) {\n\t\targument = argument.toJSON();\n\t}\n\n\tif (!isString(argument)) {\n\t\tif (isMap(argument)) {\n\t\t\tif (argument.size == 0) {\n\t\t\t\treturn 'new Map()';\n\t\t\t}\n\t\t\tif (!compact) {\n\t\t\t\toptions.__inline1__ = true;\n\t\t\t\toptions.__inline2__ = false;\n\t\t\t}\n\t\t\treturn 'new Map(' + jsesc(Array.from(argument), options) + ')';\n\t\t}\n\t\tif (isSet(argument)) {\n\t\t\tif (argument.size == 0) {\n\t\t\t\treturn 'new Set()';\n\t\t\t}\n\t\t\treturn 'new Set(' + jsesc(Array.from(argument), options) + ')';\n\t\t}\n\t\tif (isBuffer(argument)) {\n\t\t\tif (argument.length == 0) {\n\t\t\t\treturn 'Buffer.from([])';\n\t\t\t}\n\t\t\treturn 'Buffer.from(' + jsesc(Array.from(argument), options) + ')';\n\t\t}\n\t\tif (isArray(argument)) {\n\t\t\tresult = [];\n\t\t\toptions.wrap = true;\n\t\t\tif (inline1) {\n\t\t\t\toptions.__inline1__ = false;\n\t\t\t\toptions.__inline2__ = true;\n\t\t\t}\n\t\t\tif (!inline2) {\n\t\t\t\tincreaseIndentation();\n\t\t\t}\n\t\t\tforEach(argument, (value) => {\n\t\t\t\tisEmpty = false;\n\t\t\t\tif (inline2) {\n\t\t\t\t\toptions.__inline2__ = false;\n\t\t\t\t}\n\t\t\t\tresult.push(\n\t\t\t\t\t(compact || inline2 ? '' : indent) +\n\t\t\t\t\tjsesc(value, options)\n\t\t\t\t);\n\t\t\t});\n\t\t\tif (isEmpty) {\n\t\t\t\treturn '[]';\n\t\t\t}\n\t\t\tif (inline2) {\n\t\t\t\treturn '[' + result.join(', ') + ']';\n\t\t\t}\n\t\t\treturn '[' + newLine + result.join(',' + newLine) + newLine +\n\t\t\t\t(compact ? '' : oldIndent) + ']';\n\t\t} else if (isNumber(argument)) {\n\t\t\tif (json) {\n\t\t\t\t// Some number values (e.g. `Infinity`) cannot be represented in JSON.\n\t\t\t\treturn JSON.stringify(argument);\n\t\t\t}\n\t\t\tif (useDecNumbers) {\n\t\t\t\treturn String(argument);\n\t\t\t}\n\t\t\tif (useHexNumbers) {\n\t\t\t\tlet hexadecimal = argument.toString(16);\n\t\t\t\tif (!lowercaseHex) {\n\t\t\t\t\thexadecimal = hexadecimal.toUpperCase();\n\t\t\t\t}\n\t\t\t\treturn '0x' + hexadecimal;\n\t\t\t}\n\t\t\tif (useBinNumbers) {\n\t\t\t\treturn '0b' + argument.toString(2);\n\t\t\t}\n\t\t\tif (useOctNumbers) {\n\t\t\t\treturn '0o' + argument.toString(8);\n\t\t\t}\n\t\t} else if (!isObject(argument)) {\n\t\t\tif (json) {\n\t\t\t\t// For some values (e.g. `undefined`, `function` objects),\n\t\t\t\t// `JSON.stringify(value)` returns `undefined` (which isn’t valid\n\t\t\t\t// JSON) instead of `'null'`.\n\t\t\t\treturn JSON.stringify(argument) || 'null';\n\t\t\t}\n\t\t\treturn String(argument);\n\t\t} else { // it’s an object\n\t\t\tresult = [];\n\t\t\toptions.wrap = true;\n\t\t\tincreaseIndentation();\n\t\t\tforOwn(argument, (key, value) => {\n\t\t\t\tisEmpty = false;\n\t\t\t\tresult.push(\n\t\t\t\t\t(compact ? '' : indent) +\n\t\t\t\t\tjsesc(key, options) + ':' +\n\t\t\t\t\t(compact ? '' : ' ') +\n\t\t\t\t\tjsesc(value, options)\n\t\t\t\t);\n\t\t\t});\n\t\t\tif (isEmpty) {\n\t\t\t\treturn '{}';\n\t\t\t}\n\t\t\treturn '{' + newLine + result.join(',' + newLine) + newLine +\n\t\t\t\t(compact ? '' : oldIndent) + '}';\n\t\t}\n\t}\n\n\tconst string = argument;\n\t// Loop over each code unit in the string and escape it\n\tlet index = -1;\n\tconst length = string.length;\n\tresult = '';\n\twhile (++index < length) {\n\t\tconst character = string.charAt(index);\n\t\tif (options.es6) {\n\t\t\tconst first = string.charCodeAt(index);\n\t\t\tif ( // check if it’s the start of a surrogate pair\n\t\t\t\tfirst >= 0xD800 && first <= 0xDBFF && // high surrogate\n\t\t\t\tlength > index + 1 // there is a next code unit\n\t\t\t) {\n\t\t\t\tconst second = string.charCodeAt(index + 1);\n\t\t\t\tif (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate\n\t\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\t\tconst codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n\t\t\t\t\tlet hexadecimal = codePoint.toString(16);\n\t\t\t\t\tif (!lowercaseHex) {\n\t\t\t\t\t\thexadecimal = hexadecimal.toUpperCase();\n\t\t\t\t\t}\n\t\t\t\t\tresult += '\\\\u{' + hexadecimal + '}';\n\t\t\t\t\t++index;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!options.escapeEverything) {\n\t\t\tif (regexWhitelist.test(character)) {\n\t\t\t\t// It’s a printable ASCII character that is not `\"`, `'` or `\\`,\n\t\t\t\t// so don’t escape it.\n\t\t\t\tresult += character;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (character == '\"') {\n\t\t\t\tresult += quote == character ? '\\\\\"' : character;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (character == '`') {\n\t\t\t\tresult += quote == character ? '\\\\`' : character;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (character == '\\'') {\n\t\t\t\tresult += quote == character ? '\\\\\\'' : character;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (\n\t\t\tcharacter == '\\0' &&\n\t\t\t!json &&\n\t\t\t!regexDigit.test(string.charAt(index + 1))\n\t\t) {\n\t\t\tresult += '\\\\0';\n\t\t\tcontinue;\n\t\t}\n\t\tif (regexSingleEscape.test(character)) {\n\t\t\t// no need for a `hasOwnProperty` check here\n\t\t\tresult += singleEscapes[character];\n\t\t\tcontinue;\n\t\t}\n\t\tconst charCode = character.charCodeAt(0);\n\t\tif (options.minimal && charCode != 0x2028 && charCode != 0x2029) {\n\t\t\tresult += character;\n\t\t\tcontinue;\n\t\t}\n\t\tlet hexadecimal = charCode.toString(16);\n\t\tif (!lowercaseHex) {\n\t\t\thexadecimal = hexadecimal.toUpperCase();\n\t\t}\n\t\tconst longhand = hexadecimal.length > 2 || json;\n\t\tconst escaped = '\\\\' + (longhand ? 'u' : 'x') +\n\t\t\t('0000' + hexadecimal).slice(longhand ? -4 : -2);\n\t\tresult += escaped;\n\t\tcontinue;\n\t}\n\tif (options.wrap) {\n\t\tresult = quote + result + quote;\n\t}\n\tif (quote == '`') {\n\t\tresult = result.replace(/\\$\\{/g, '\\\\\\$\\{');\n\t}\n\tif (options.isScriptContext) {\n\t\t// https://mathiasbynens.be/notes/etago\n\t\treturn result\n\t\t\t.replace(/<\\/(script|style)/gi, '<\\\\/$1')\n\t\t\t.replace(/\x3c!--/g, json ? '\\\\u003C!--' : '\\\\x3C!--');\n\t}\n\treturn result;\n};\n\njsesc.version = '2.5.2';\n\nmodule.exports = jsesc;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/jsesc/jsesc.js?")},18552:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var getNative = __webpack_require__(10852),\n    root = __webpack_require__(55639);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nmodule.exports = DataView;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_DataView.js?")},1989:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var hashClear = __webpack_require__(51789),\n    hashDelete = __webpack_require__(80401),\n    hashGet = __webpack_require__(57667),\n    hashHas = __webpack_require__(21327),\n    hashSet = __webpack_require__(81866);\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_Hash.js?")},38407:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var listCacheClear = __webpack_require__(27040),\n    listCacheDelete = __webpack_require__(14125),\n    listCacheGet = __webpack_require__(82117),\n    listCacheHas = __webpack_require__(67518),\n    listCacheSet = __webpack_require__(54705);\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_ListCache.js?")},57071:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var getNative = __webpack_require__(10852),\n    root = __webpack_require__(55639);\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_Map.js?")},83369:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var mapCacheClear = __webpack_require__(24785),\n    mapCacheDelete = __webpack_require__(11285),\n    mapCacheGet = __webpack_require__(96000),\n    mapCacheHas = __webpack_require__(49916),\n    mapCacheSet = __webpack_require__(95265);\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_MapCache.js?")},53818:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var getNative = __webpack_require__(10852),\n    root = __webpack_require__(55639);\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nmodule.exports = Promise;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_Promise.js?")},58525:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var getNative = __webpack_require__(10852),\n    root = __webpack_require__(55639);\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nmodule.exports = Set;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_Set.js?")},46384:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var ListCache = __webpack_require__(38407),\n    stackClear = __webpack_require__(37465),\n    stackDelete = __webpack_require__(63779),\n    stackGet = __webpack_require__(67599),\n    stackHas = __webpack_require__(44758),\n    stackSet = __webpack_require__(34309);\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nmodule.exports = Stack;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_Stack.js?")},11149:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var root = __webpack_require__(55639);\n\n/** Built-in value references. */\nvar Uint8Array = root.Uint8Array;\n\nmodule.exports = Uint8Array;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_Uint8Array.js?")},70577:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var getNative = __webpack_require__(10852),\n    root = __webpack_require__(55639);\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nmodule.exports = WeakMap;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_WeakMap.js?")},77412:module=>{eval("/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_arrayEach.js?")},34963:module=>{eval("/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayFilter;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_arrayFilter.js?")},14636:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var baseTimes = __webpack_require__(22545),\n    isArguments = __webpack_require__(35694),\n    isArray = __webpack_require__(1469),\n    isBuffer = __webpack_require__(44144),\n    isIndex = __webpack_require__(65776),\n    isTypedArray = __webpack_require__(36719);\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_arrayLikeKeys.js?")},62488:module=>{eval("/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_arrayPush.js?")},34865:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var baseAssignValue = __webpack_require__(89465),\n    eq = __webpack_require__(77813);\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignValue;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_assignValue.js?")},18470:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var eq = __webpack_require__(77813);\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_assocIndexOf.js?")},44037:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var copyObject = __webpack_require__(98363),\n    keys = __webpack_require__(3674);\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\nmodule.exports = baseAssign;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_baseAssign.js?")},63886:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var copyObject = __webpack_require__(98363),\n    keysIn = __webpack_require__(81704);\n\n/**\n * The base implementation of `_.assignIn` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssignIn(object, source) {\n  return object && copyObject(source, keysIn(source), object);\n}\n\nmodule.exports = baseAssignIn;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_baseAssignIn.js?")},89465:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var defineProperty = __webpack_require__(38777);\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nmodule.exports = baseAssignValue;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_baseAssignValue.js?")},85990:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var Stack = __webpack_require__(46384),\n    arrayEach = __webpack_require__(77412),\n    assignValue = __webpack_require__(34865),\n    baseAssign = __webpack_require__(44037),\n    baseAssignIn = __webpack_require__(63886),\n    cloneBuffer = __webpack_require__(64626),\n    copyArray = __webpack_require__(278),\n    copySymbols = __webpack_require__(18805),\n    copySymbolsIn = __webpack_require__(1911),\n    getAllKeys = __webpack_require__(58234),\n    getAllKeysIn = __webpack_require__(46904),\n    getTag = __webpack_require__(64160),\n    initCloneArray = __webpack_require__(43824),\n    initCloneByTag = __webpack_require__(29148),\n    initCloneObject = __webpack_require__(38517),\n    isArray = __webpack_require__(1469),\n    isBuffer = __webpack_require__(44144),\n    isMap = __webpack_require__(56688),\n    isObject = __webpack_require__(13218),\n    isSet = __webpack_require__(72928),\n    keys = __webpack_require__(3674),\n    keysIn = __webpack_require__(81704);\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Deep clone\n *  2 - Flatten inherited properties\n *  4 - Clone symbols\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG,\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      result = (isFlat || isFunc) ? {} : initCloneObject(value);\n      if (!isDeep) {\n        return isFlat\n          ? copySymbolsIn(value, baseAssignIn(result, value))\n          : copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (isSet(value)) {\n    value.forEach(function(subValue) {\n      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n    });\n  } else if (isMap(value)) {\n    value.forEach(function(subValue, key) {\n      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n    });\n  }\n\n  var keysFunc = isFull\n    ? (isFlat ? getAllKeysIn : getAllKeys)\n    : (isFlat ? keysIn : keys);\n\n  var props = isArr ? undefined : keysFunc(value);\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n  });\n  return result;\n}\n\nmodule.exports = baseClone;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_baseClone.js?")},3118:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var isObject = __webpack_require__(13218);\n\n/** Built-in value references. */\nvar objectCreate = Object.create;\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\nmodule.exports = baseCreate;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_baseCreate.js?")},68866:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var arrayPush = __webpack_require__(62488),\n    isArray = __webpack_require__(1469);\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\nmodule.exports = baseGetAllKeys;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_baseGetAllKeys.js?")},9454:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var baseGetTag = __webpack_require__(44239),\n    isObjectLike = __webpack_require__(37005);\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_baseIsArguments.js?")},25588:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var getTag = __webpack_require__(64160),\n    isObjectLike = __webpack_require__(37005);\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]';\n\n/**\n * The base implementation of `_.isMap` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n */\nfunction baseIsMap(value) {\n  return isObjectLike(value) && getTag(value) == mapTag;\n}\n\nmodule.exports = baseIsMap;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_baseIsMap.js?")},28458:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var isFunction = __webpack_require__(23560),\n    isMasked = __webpack_require__(15346),\n    isObject = __webpack_require__(13218),\n    toSource = __webpack_require__(80346);\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_baseIsNative.js?")},23933:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var baseGetTag = __webpack_require__(44239),\n    isObjectLike = __webpack_require__(37005);\n\n/** `Object#toString` result references. */\nvar regexpTag = '[object RegExp]';\n\n/**\n * The base implementation of `_.isRegExp` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n */\nfunction baseIsRegExp(value) {\n  return isObjectLike(value) && baseGetTag(value) == regexpTag;\n}\n\nmodule.exports = baseIsRegExp;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_baseIsRegExp.js?")},29221:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var getTag = __webpack_require__(64160),\n    isObjectLike = __webpack_require__(37005);\n\n/** `Object#toString` result references. */\nvar setTag = '[object Set]';\n\n/**\n * The base implementation of `_.isSet` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n */\nfunction baseIsSet(value) {\n  return isObjectLike(value) && getTag(value) == setTag;\n}\n\nmodule.exports = baseIsSet;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_baseIsSet.js?")},38749:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var baseGetTag = __webpack_require__(44239),\n    isLength = __webpack_require__(41780),\n    isObjectLike = __webpack_require__(37005);\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_baseIsTypedArray.js?")},280:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var isPrototype = __webpack_require__(25726),\n    nativeKeys = __webpack_require__(86916);\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_baseKeys.js?")},10313:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var isObject = __webpack_require__(13218),\n    isPrototype = __webpack_require__(25726),\n    nativeKeysIn = __webpack_require__(33498);\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeysIn;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_baseKeysIn.js?")},22545:module=>{eval("/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_baseTimes.js?")},7518:module=>{eval("/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_baseUnary.js?")},74318:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var Uint8Array = __webpack_require__(11149);\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\nmodule.exports = cloneArrayBuffer;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_cloneArrayBuffer.js?")},64626:(module,exports,__webpack_require__)=>{eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar root = __webpack_require__(55639);\n\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && \"object\" == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\nmodule.exports = cloneBuffer;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_cloneBuffer.js?")},57157:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var cloneArrayBuffer = __webpack_require__(74318);\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\nmodule.exports = cloneDataView;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_cloneDataView.js?")},93147:module=>{eval("/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\nmodule.exports = cloneRegExp;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_cloneRegExp.js?")},40419:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var Symbol = __webpack_require__(62705);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\nmodule.exports = cloneSymbol;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_cloneSymbol.js?")},77133:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var cloneArrayBuffer = __webpack_require__(74318);\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\nmodule.exports = cloneTypedArray;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_cloneTypedArray.js?")},278:module=>{eval("/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\nmodule.exports = copyArray;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_copyArray.js?")},98363:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var assignValue = __webpack_require__(34865),\n    baseAssignValue = __webpack_require__(89465);\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\nmodule.exports = copyObject;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_copyObject.js?")},18805:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var copyObject = __webpack_require__(98363),\n    getSymbols = __webpack_require__(99551);\n\n/**\n * Copies own symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\nmodule.exports = copySymbols;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_copySymbols.js?")},1911:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var copyObject = __webpack_require__(98363),\n    getSymbolsIn = __webpack_require__(51442);\n\n/**\n * Copies own and inherited symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbolsIn(source, object) {\n  return copyObject(source, getSymbolsIn(source), object);\n}\n\nmodule.exports = copySymbolsIn;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_copySymbolsIn.js?")},14429:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var root = __webpack_require__(55639);\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_coreJsData.js?")},38777:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var getNative = __webpack_require__(10852);\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nmodule.exports = defineProperty;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_defineProperty.js?")},58234:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var baseGetAllKeys = __webpack_require__(68866),\n    getSymbols = __webpack_require__(99551),\n    keys = __webpack_require__(3674);\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\nmodule.exports = getAllKeys;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_getAllKeys.js?")},46904:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var baseGetAllKeys = __webpack_require__(68866),\n    getSymbolsIn = __webpack_require__(51442),\n    keysIn = __webpack_require__(81704);\n\n/**\n * Creates an array of own and inherited enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeysIn(object) {\n  return baseGetAllKeys(object, keysIn, getSymbolsIn);\n}\n\nmodule.exports = getAllKeysIn;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_getAllKeysIn.js?")},45050:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var isKeyable = __webpack_require__(37019);\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_getMapData.js?")},10852:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var baseIsNative = __webpack_require__(28458),\n    getValue = __webpack_require__(47801);\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_getNative.js?")},85924:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var overArg = __webpack_require__(5569);\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nmodule.exports = getPrototype;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_getPrototype.js?")},99551:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var arrayFilter = __webpack_require__(34963),\n    stubArray = __webpack_require__(70479);\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\nmodule.exports = getSymbols;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_getSymbols.js?")},51442:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var arrayPush = __webpack_require__(62488),\n    getPrototype = __webpack_require__(85924),\n    getSymbols = __webpack_require__(99551),\n    stubArray = __webpack_require__(70479);\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own and inherited enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n  var result = [];\n  while (object) {\n    arrayPush(result, getSymbols(object));\n    object = getPrototype(object);\n  }\n  return result;\n};\n\nmodule.exports = getSymbolsIn;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_getSymbolsIn.js?")},64160:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var DataView = __webpack_require__(18552),\n    Map = __webpack_require__(57071),\n    Promise = __webpack_require__(53818),\n    Set = __webpack_require__(58525),\n    WeakMap = __webpack_require__(70577),\n    baseGetTag = __webpack_require__(44239),\n    toSource = __webpack_require__(80346);\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nmodule.exports = getTag;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_getTag.js?")},47801:module=>{eval("/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_getValue.js?")},51789:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var nativeCreate = __webpack_require__(94536);\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_hashClear.js?")},80401:module=>{eval("/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_hashDelete.js?")},57667:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var nativeCreate = __webpack_require__(94536);\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_hashGet.js?")},21327:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var nativeCreate = __webpack_require__(94536);\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_hashHas.js?")},81866:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var nativeCreate = __webpack_require__(94536);\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_hashSet.js?")},43824:module=>{eval("/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = new array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\nmodule.exports = initCloneArray;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_initCloneArray.js?")},29148:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var cloneArrayBuffer = __webpack_require__(74318),\n    cloneDataView = __webpack_require__(57157),\n    cloneRegExp = __webpack_require__(93147),\n    cloneSymbol = __webpack_require__(40419),\n    cloneTypedArray = __webpack_require__(77133);\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return new Ctor;\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return new Ctor;\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\nmodule.exports = initCloneByTag;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_initCloneByTag.js?")},38517:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var baseCreate = __webpack_require__(3118),\n    getPrototype = __webpack_require__(85924),\n    isPrototype = __webpack_require__(25726);\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\nmodule.exports = initCloneObject;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_initCloneObject.js?")},65776:module=>{eval("/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_isIndex.js?")},37019:module=>{eval("/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_isKeyable.js?")},15346:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var coreJsData = __webpack_require__(14429);\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_isMasked.js?")},25726:module=>{eval("/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_isPrototype.js?")},27040:module=>{eval("/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_listCacheClear.js?")},14125:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var assocIndexOf = __webpack_require__(18470);\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_listCacheDelete.js?")},82117:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var assocIndexOf = __webpack_require__(18470);\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_listCacheGet.js?")},67518:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var assocIndexOf = __webpack_require__(18470);\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_listCacheHas.js?")},54705:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var assocIndexOf = __webpack_require__(18470);\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_listCacheSet.js?")},24785:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var Hash = __webpack_require__(1989),\n    ListCache = __webpack_require__(38407),\n    Map = __webpack_require__(57071);\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_mapCacheClear.js?")},11285:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var getMapData = __webpack_require__(45050);\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_mapCacheDelete.js?")},96e3:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var getMapData = __webpack_require__(45050);\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_mapCacheGet.js?")},49916:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var getMapData = __webpack_require__(45050);\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_mapCacheHas.js?")},95265:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var getMapData = __webpack_require__(45050);\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_mapCacheSet.js?")},94536:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var getNative = __webpack_require__(10852);\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_nativeCreate.js?")},86916:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var overArg = __webpack_require__(5569);\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_nativeKeys.js?")},33498:module=>{eval("/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = nativeKeysIn;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_nativeKeysIn.js?")},31167:(module,exports,__webpack_require__)=>{eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar freeGlobal = __webpack_require__(31957);\n\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && \"object\" == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_nodeUtil.js?")},5569:module=>{eval("/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_overArg.js?")},37465:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var ListCache = __webpack_require__(38407);\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\nmodule.exports = stackClear;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_stackClear.js?")},63779:module=>{eval("/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\nmodule.exports = stackDelete;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_stackDelete.js?")},67599:module=>{eval("/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nmodule.exports = stackGet;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_stackGet.js?")},44758:module=>{eval("/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nmodule.exports = stackHas;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_stackHas.js?")},34309:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var ListCache = __webpack_require__(38407),\n    Map = __webpack_require__(57071),\n    MapCache = __webpack_require__(83369);\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nmodule.exports = stackSet;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_stackSet.js?")},80346:module=>{eval("/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/_toSource.js?")},66678:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var baseClone = __webpack_require__(85990);\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * Creates a shallow clone of `value`.\n *\n * **Note:** This method is loosely based on the\n * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n * and supports cloning arrays, array buffers, booleans, date objects, maps,\n * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n * arrays. The own enumerable properties of `arguments` objects are cloned\n * as plain objects. An empty object is returned for uncloneable values such\n * as error objects, functions, DOM nodes, and WeakMaps.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to clone.\n * @returns {*} Returns the cloned value.\n * @see _.cloneDeep\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var shallow = _.clone(objects);\n * console.log(shallow[0] === objects[0]);\n * // => true\n */\nfunction clone(value) {\n  return baseClone(value, CLONE_SYMBOLS_FLAG);\n}\n\nmodule.exports = clone;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/clone.js?")},77813:module=>{eval("/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/eq.js?")},35694:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var baseIsArguments = __webpack_require__(9454),\n    isObjectLike = __webpack_require__(37005);\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/isArguments.js?")},98612:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var isFunction = __webpack_require__(23560),\n    isLength = __webpack_require__(41780);\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/isArrayLike.js?")},44144:(module,exports,__webpack_require__)=>{eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar root = __webpack_require__(55639),\n    stubFalse = __webpack_require__(95062);\n\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && \"object\" == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/isBuffer.js?")},23560:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var baseGetTag = __webpack_require__(44239),\n    isObject = __webpack_require__(13218);\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/isFunction.js?")},41780:module=>{eval("/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/isLength.js?")},56688:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var baseIsMap = __webpack_require__(25588),\n    baseUnary = __webpack_require__(7518),\n    nodeUtil = __webpack_require__(31167);\n\n/* Node.js helper references. */\nvar nodeIsMap = nodeUtil && nodeUtil.isMap;\n\n/**\n * Checks if `value` is classified as a `Map` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n * @example\n *\n * _.isMap(new Map);\n * // => true\n *\n * _.isMap(new WeakMap);\n * // => false\n */\nvar isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\nmodule.exports = isMap;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/isMap.js?")},68630:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var baseGetTag = __webpack_require__(44239),\n    getPrototype = __webpack_require__(85924),\n    isObjectLike = __webpack_require__(37005);\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nmodule.exports = isPlainObject;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/isPlainObject.js?")},96347:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var baseIsRegExp = __webpack_require__(23933),\n    baseUnary = __webpack_require__(7518),\n    nodeUtil = __webpack_require__(31167);\n\n/* Node.js helper references. */\nvar nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;\n\n/**\n * Checks if `value` is classified as a `RegExp` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n * @example\n *\n * _.isRegExp(/abc/);\n * // => true\n *\n * _.isRegExp('/abc/');\n * // => false\n */\nvar isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\nmodule.exports = isRegExp;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/isRegExp.js?")},72928:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var baseIsSet = __webpack_require__(29221),\n    baseUnary = __webpack_require__(7518),\n    nodeUtil = __webpack_require__(31167);\n\n/* Node.js helper references. */\nvar nodeIsSet = nodeUtil && nodeUtil.isSet;\n\n/**\n * Checks if `value` is classified as a `Set` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n * @example\n *\n * _.isSet(new Set);\n * // => true\n *\n * _.isSet(new WeakSet);\n * // => false\n */\nvar isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\nmodule.exports = isSet;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/isSet.js?")},36719:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var baseIsTypedArray = __webpack_require__(38749),\n    baseUnary = __webpack_require__(7518),\n    nodeUtil = __webpack_require__(31167);\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/isTypedArray.js?")},3674:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var arrayLikeKeys = __webpack_require__(14636),\n    baseKeys = __webpack_require__(280),\n    isArrayLike = __webpack_require__(98612);\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/keys.js?")},81704:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var arrayLikeKeys = __webpack_require__(14636),\n    baseKeysIn = __webpack_require__(10313),\n    isArrayLike = __webpack_require__(98612);\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\nmodule.exports = keysIn;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/keysIn.js?")},70479:module=>{eval("/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\nmodule.exports = stubArray;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/stubArray.js?")},95062:module=>{eval("/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/lodash/stubFalse.js?")},53164:module=>{"use strict";eval('\n\nlet fastProto = null;\n\n// Creates an object with permanently fast properties in V8. See Toon Verwaest\'s\n// post https://medium.com/@tverwaes/setting-up-prototypes-in-v8-ec9c9491dfe2#5f62\n// for more details. Use %HasFastProperties(object) and the Node.js flag\n// --allow-natives-syntax to check whether an object has fast properties.\nfunction FastObject(o) {\n\t// A prototype object will have "fast properties" enabled once it is checked\n\t// against the inline property cache of a function, e.g. fastProto.property:\n\t// https://github.com/v8/v8/blob/6.0.122/test/mjsunit/fast-prototype.js#L48-L63\n\tif (fastProto !== null && typeof fastProto.property) {\n\t\tconst result = fastProto;\n\t\tfastProto = FastObject.prototype = null;\n\t\treturn result;\n\t}\n\tfastProto = FastObject.prototype = o == null ? Object.create(null) : o;\n\treturn new FastObject;\n}\n\n// Initialize the inline property cache of FastObject\nFastObject();\n\nmodule.exports = function toFastproperties(o) {\n\treturn FastObject(o);\n};\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/to-fast-properties/index.js?')},69741:(module,__unused_webpack_exports,__webpack_require__)=>{eval("module.exports = __webpack_require__(74746).YAML\n\n\n//# sourceURL=webpack://@codemodsquad/try-it-pages/./node_modules/yaml/browser/index.js?")}}]);